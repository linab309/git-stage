; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm32l152-eval\mass_mal.o --asm_dir=.\STM32L152-EVAL\ --list_dir=.\STM32L152-EVAL\ --depend=.\stm32l152-eval\mass_mal.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32L1xx\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32L1xx_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM32L152_EVAL -I..\src\user -I..\src\user\include -I..\src\SYSTEM\delay -I..\src\SYSTEM\sys -I..\src\SYSTEM\usart -I..\src\HARDWARE\ADC -I..\src\HARDWARE\BMP -I..\src\HARDWARE\DMA -I..\src\HARDWARE\FLASH -I..\src\HARDWARE\GPS -I..\src\HARDWARE\KEY -I..\src\HARDWARE\PWM -I..\src\HARDWARE\RTC -I..\src\HARDWARE\SPI -I..\src\HARDWARE\USART2 -I..\src\HARDWARE\TIMER -I..\src\EX -I..\src\USMART -I..\..\..\Libraries\CMSIS\Include -I..\src\ff11a\src -I..\src\ff11a\src\option -I..\src\HARDWARE\LED -I..\src\HARDWARE\OLED -I..\src\ff11a\src -I..\src\ff11a\src\option -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.1.0\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32L1xx -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32L1XX_MD -DUSE_STM32L152_EVAL ..\src\mass_mal.c]
                          THUMB

                          AREA ||i.MAL_GetStatus||, CODE, READONLY, ALIGN=2

                  MAL_GetStatus PROC
;;;169    *******************************************************************************/
;;;170    uint16_t MAL_GetStatus (uint8_t lun)
000000  b108              CBZ      r0,|L1.6|
;;;171    {
;;;172    #ifdef USE_STM3210E_EVAL
;;;173      NAND_IDTypeDef NAND_ID;
;;;174      uint32_t DeviceSizeMul = 0, NumberOfBlocks = 0;
;;;175    #else
;;;176     // SD_CSD SD_csd;
;;;177    //  uint32_t DeviceSizeMul = 0;
;;;178    #endif /* USE_STM3210E_EVAL */
;;;179    
;;;180    #ifdef USE_STM32L152D_EVAL
;;;181    
;;;182      uint32_t NumberOfBlocks = 0;
;;;183    #endif
;;;184    
;;;185    
;;;186      if (lun == 0)
;;;187      {
;;;188    
;;;189    
;;;190    #if 0//defined (USE_STM3210E_EVAL)  || defined(USE_STM32L152D_EVAL)
;;;191        if (SD_Init() == SD_OK)
;;;192        {
;;;193          SD_GetCardInfo(&mSDCardInfo);
;;;194          SD_SelectDeselect((uint32_t) (mSDCardInfo.RCA << 16));
;;;195          DeviceSizeMul = (mSDCardInfo.SD_csd.DeviceSizeMul + 2);
;;;196    
;;;197          if(mSDCardInfo.CardType == SDIO_HIGH_CAPACITY_SD_CARD)
;;;198          {
;;;199            Mass_Block_Count[0] = (mSDCardInfo.SD_csd.DeviceSize + 1) * 1024;
;;;200          }
;;;201          else
;;;202          {
;;;203            NumberOfBlocks  = ((1 << (mSDCardInfo.SD_csd.RdBlockLen)) / 512);
;;;204            Mass_Block_Count[0] = ((mSDCardInfo.SD_csd.DeviceSize + 1) * (1 << DeviceSizeMul) << (NumberOfBlocks/2));
;;;205          }
;;;206          Mass_Block_Size[0]  = 512;
;;;207    
;;;208          Status = SD_SelectDeselect((uint32_t) (mSDCardInfo.RCA << 16)); 
;;;209          Status = SD_EnableWideBusOperation(SDIO_BusWide_4b); 
;;;210          if ( Status != SD_OK )
;;;211          {
;;;212            return MAL_FAIL;
;;;213          }
;;;214         
;;;215    #else
;;;216    
;;;217        //uint32_t temp_block_mul = 0;
;;;218        //  SD_GetCSDRegister(&SD_csd);
;;;219        // DeviceSizeMul = SD_csd.DeviceSizeMul + 2;
;;;220        //emp_block_mul = (1 << SD_csd.RdBlockLen)/ 512;
;;;221        Mass_Block_Count[0] =  NAND_BLOCK_SIZE*NAND_ZONE_SIZE ;
;;;222        Mass_Block_Size[0] = NAND_PAGE_SIZE;
;;;223        Mass_Memory_Size[0] = (Mass_Block_Count[0] * Mass_Block_Size[0]);
;;;224    #endif /* USE_STM3210E_EVAL */
;;;225      //    Mass_Memory_Size[0] = Mass_Block_Count[0] * Mass_Block_Size[0];
;;;226    //      STM_EVAL_LEDOn(LED2);
;;;227        system_flag_table->usbdisk_flag = 1;
;;;228        return MAL_OK;
;;;229    
;;;230    #if defined (USE_STM3210E_EVAL) || defined(USE_STM32L152D_EVAL)
;;;231        }
;;;232    #endif /* USE_STM3210E_EVAL */
;;;233      }
;;;234    #ifdef USE_STM3210E_EVAL
;;;235      else
;;;236      {
;;;237        FSMC_NAND_ReadID(&NAND_ID);
;;;238        if (NAND_ID.Device_ID != 0 )
;;;239        {
;;;240          /* only one zone is used */
;;;241          Mass_Block_Count[1] = NAND_ZONE_SIZE * NAND_BLOCK_SIZE * NAND_MAX_ZONE ;
;;;242          Mass_Block_Size[1]  = NAND_PAGE_SIZE;
;;;243          Mass_Memory_Size[1] = (Mass_Block_Count[1] * Mass_Block_Size[1]);
;;;244          return MAL_OK;
;;;245        }
;;;246      }
;;;247    #endif /* USE_STM3210E_EVAL */
;;;248    //  STM_EVAL_LEDOn(LED2);
;;;249      return MAL_FAIL;
000002  2001              MOVS     r0,#1
;;;250    }
000004  4770              BX       lr
                  |L1.6|
000006  4909              LDR      r1,|L1.44|
000008  f64770f8          MOV      r0,#0x7ff8            ;221
00000c  6008              STR      r0,[r1,#0]            ;222  ; Mass_Block_Count
00000e  3908              SUBS     r1,r1,#8              ;222
000010  f44f7000          MOV      r0,#0x200             ;222
000014  6008              STR      r0,[r1,#0]            ;223  ; Mass_Block_Size
000016  3908              SUBS     r1,r1,#8              ;223
000018  4805              LDR      r0,|L1.48|
00001a  6008              STR      r0,[r1,#0]            ;227  ; Mass_Memory_Size
00001c  4905              LDR      r1,|L1.52|
00001e  2001              MOVS     r0,#1                 ;227
000020  6809              LDR      r1,[r1,#0]            ;227  ; system_flag_table
000022  f8810038          STRB     r0,[r1,#0x38]         ;227
000026  2000              MOVS     r0,#0                 ;228
000028  4770              BX       lr
;;;251    
                          ENDP

00002a  0000              DCW      0x0000
                  |L1.44|
                          DCD      ||area_number.8||+0x10
                  |L1.48|
                          DCD      0x00fff000
                  |L1.52|
                          DCD      system_flag_table

                          AREA ||i.MAL_Init||, CODE, READONLY, ALIGN=1

                  MAL_Init PROC
;;;58     *******************************************************************************/
;;;59     uint16_t MAL_Init(uint8_t lun)
000000  2100              MOVS     r1,#0
;;;60     {
000002  b108              CBZ      r0,|L2.8|
;;;61       uint16_t status = MAL_OK;
;;;62     
;;;63       switch (lun)
;;;64       {
;;;65         case 0:
;;;66           //Status = SD_Init();
;;;67           break;
;;;68     #ifdef USE_STM3210E_EVAL
;;;69         case 1:
;;;70           NAND_Init();
;;;71           break;
;;;72     #endif
;;;73         default:
;;;74           return MAL_FAIL;
000004  2001              MOVS     r0,#1
;;;75       }
;;;76       return status;
;;;77     }
000006  4770              BX       lr
                  |L2.8|
000008  4608              MOV      r0,r1                 ;76
00000a  4770              BX       lr
;;;78     /*******************************************************************************
                          ENDP


                          AREA ||i.MAL_Read||, CODE, READONLY, ALIGN=1

                  MAL_Read PROC
;;;124    *******************************************************************************/
;;;125    uint16_t MAL_Read(uint8_t lun, uint32_t Memory_Offset, uint32_t *Readbuff, uint16_t Transfer_Length)
000000  b510              PUSH     {r4,lr}
;;;126    {
000002  4614              MOV      r4,r2
000004  b108              CBZ      r0,|L3.10|
;;;127    
;;;128      switch (lun)
;;;129      {
;;;130        case 0:
;;;131    #if defined(USE_STM3210E_EVAL) 
;;;132    //|| defined(USE_STM32L152D_EVAL)
;;;133    
;;;134          SD_ReadMultiBlocks((uint8_t*)Readbuff, Memory_Offset, Transfer_Length, 1);
;;;135    
;;;136          Status = SD_WaitReadOperation();
;;;137          while(SD_GetStatus() != SD_TRANSFER_OK)
;;;138          {
;;;139          }
;;;140          
;;;141          if ( Status != SD_OK )
;;;142          {
;;;143            return MAL_FAIL;
;;;144          }
;;;145    #else
;;;146    
;;;147         // v1000_debug("read Memory_Offset = %x,Transfer_Length = %x \r\n",Memory_Offset,Transfer_Length);
;;;148          SPI_Flash_Read((uint8_t*)Readbuff,Memory_Offset, Transfer_Length);
;;;149          //v1000_debug("read ok\n");
;;;150    #endif /* USE_STM3210E_EVAL */      
;;;151          break;
;;;152    #ifdef USE_STM3210E_EVAL
;;;153        case 1:
;;;154          NAND_Read(Memory_Offset, Readbuff, Transfer_Length);
;;;155          break;
;;;156    #endif
;;;157        default:
;;;158          return MAL_FAIL;
000006  2001              MOVS     r0,#1
;;;159      }
;;;160      return MAL_OK;
;;;161    }
000008  bd10              POP      {r4,pc}
                  |L3.10|
00000a  461a              MOV      r2,r3                 ;148
00000c  4620              MOV      r0,r4                 ;148
00000e  f7fffffe          BL       SPI_Flash_Read
000012  2000              MOVS     r0,#0                 ;160
000014  bd10              POP      {r4,pc}
;;;162    
                          ENDP


                          AREA ||i.MAL_Write||, CODE, READONLY, ALIGN=1

                  MAL_Write PROC
;;;84     *******************************************************************************/
;;;85     uint16_t MAL_Write(uint8_t lun, uint32_t Memory_Offset, uint32_t *Writebuff, uint16_t Transfer_Length)
000000  b510              PUSH     {r4,lr}
;;;86     {
000002  4614              MOV      r4,r2
000004  b108              CBZ      r0,|L4.10|
;;;87     
;;;88       switch (lun)
;;;89       {
;;;90         case 0:
;;;91     #if defined(USE_STM3210E_EVAL) 
;;;92     //|| defined(USE_STM32L152D_EVAL)        
;;;93         Status = SD_WriteMultiBlocks((uint8_t*)Writebuff, Memory_Offset, Transfer_Length,1);
;;;94     
;;;95         Status = SD_WaitWriteOperation();  
;;;96         while(SD_GetStatus() != SD_TRANSFER_OK);
;;;97           if ( Status != SD_OK )
;;;98           {
;;;99             return MAL_FAIL;
;;;100          }     
;;;101    #else
;;;102         //v1000_debug("write Memory_Offset = %x,Transfer_Length = %x \r\n",Memory_Offset,Transfer_Length);
;;;103         //SPI_Flash_writePage((uint8_t*)Writebuff, Memory_Offset, Transfer_Length);
;;;104         SPI_Flash_Write((uint8_t*)Writebuff, Memory_Offset, Transfer_Length);
;;;105    #endif /* USE_STM3210E_EVAL ||USE_STM32L152D_EVAL*/      
;;;106          break;
;;;107    #ifdef USE_STM3210E_EVAL
;;;108        case 1:
;;;109          NAND_Write(Memory_Offset, Writebuff, Transfer_Length);
;;;110          break;
;;;111    #endif /* USE_STM3210E_EVAL */  
;;;112        default:
;;;113          return MAL_FAIL;
000006  2001              MOVS     r0,#1
;;;114      }
;;;115      return MAL_OK;
;;;116    }
000008  bd10              POP      {r4,pc}
                  |L4.10|
00000a  461a              MOV      r2,r3                 ;104
00000c  4620              MOV      r0,r4                 ;104
00000e  f7fffffe          BL       SPI_Flash_Write
000012  2000              MOVS     r0,#0                 ;115
000014  bd10              POP      {r4,pc}
;;;117    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  Status
                          DCD      0x00000000

                          AREA ||area_number.8||, DATA, ALIGN=2

                          EXPORTAS ||area_number.8||, ||.data||
                  Mass_Memory_Size
                          %        8
                  Mass_Block_Size
                          %        8
                  Mass_Block_Count
                          %        8

;*** Start embedded assembler ***

#line 1 "..\\src\\mass_mal.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_mass_mal_c_Status____REV16|
#line 114 "..\\..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___10_mass_mal_c_Status____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_mass_mal_c_Status____REVSH|
#line 128
|__asm___10_mass_mal_c_Status____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
