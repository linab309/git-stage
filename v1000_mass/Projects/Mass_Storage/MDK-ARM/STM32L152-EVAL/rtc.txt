; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm32l152-eval\rtc.o --asm_dir=.\STM32L152-EVAL\ --list_dir=.\STM32L152-EVAL\ --depend=.\stm32l152-eval\rtc.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32L1xx\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32L1xx_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM32L152_EVAL -I..\src\user -I..\src\user\include -I..\src\SYSTEM\delay -I..\src\SYSTEM\sys -I..\src\SYSTEM\usart -I..\src\HARDWARE\ADC -I..\src\HARDWARE\BMP -I..\src\HARDWARE\DMA -I..\src\HARDWARE\FLASH -I..\src\HARDWARE\GPS -I..\src\HARDWARE\KEY -I..\src\HARDWARE\PWM -I..\src\HARDWARE\RTC -I..\src\HARDWARE\SPI -I..\src\HARDWARE\USART2 -I..\src\HARDWARE\TIMER -I..\src\EX -I..\src\USMART -I..\..\..\Libraries\CMSIS\Include -I..\src\ff11a\src -I..\src\ff11a\src\option -I..\src\HARDWARE\LED -I..\src\HARDWARE\OLED -I..\src\ff11a\src -I..\src\ff11a\src\option -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.1.0\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32L1xx -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32L1XX_MD -DUSE_STM32L152_EVAL ..\src\HARDWARE\RTC\rtc.c]
                          THUMB

                          AREA ||i.Auto_Time_Set||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  Auto_Time_Set PROC
;;;199    //void show_data
;;;200    void Auto_Time_Set(void)
000000  e92d47ff          PUSH     {r0-r10,lr}
;;;201    {
;;;202    	u8 temp[3];
;;;203    	u8 i,mon;
;;;204    	u8 date;
;;;205    	u16 year;
;;;206    	u8 sec,min,hour;
;;;207    	for(i=0;i<3;i++)temp[i]=COMPILED_DATE[i];
000004  4d36              LDR      r5,|L1.224|
000006  2000              MOVS     r0,#0
000008  aa03              ADD      r2,sp,#0xc            ;202
00000a  6829              LDR      r1,[r5,#0]
                  |L1.12|
00000c  5c0b              LDRB     r3,[r1,r0]
00000e  5413              STRB     r3,[r2,r0]
000010  1c40              ADDS     r0,r0,#1
000012  b2c0              UXTB     r0,r0
000014  2803              CMP      r0,#3
000016  d3f9              BCC      |L1.12|
;;;208    	for(i=0;i<12;i++)if(str_cmpx((u8*)Month_Tab[i],temp,3))break;
000018  4e32              LDR      r6,|L1.228|
00001a  2400              MOVS     r4,#0
                  |L1.28|
00001c  eb040044          ADD      r0,r4,r4,LSL #1
000020  4430              ADD      r0,r0,r6
000022  2203              MOVS     r2,#3
000024  a903              ADD      r1,sp,#0xc
000026  f7fffffe          BL       str_cmpx
00002a  b918              CBNZ     r0,|L1.52|
00002c  1c64              ADDS     r4,r4,#1
00002e  b2e4              UXTB     r4,r4
000030  2c0c              CMP      r4,#0xc
000032  d3f3              BCC      |L1.28|
                  |L1.52|
;;;209    	mon=i+1;//得到月份
;;;210    	if(COMPILED_DATE[4]==' ')date=COMPILED_DATE[5]-'0';
000034  6828              LDR      r0,[r5,#0]  ; COMPILED_DATE
000036  1c64              ADDS     r4,r4,#1              ;208
000038  b2e6              UXTB     r6,r4                 ;209
00003a  7902              LDRB     r2,[r0,#4]
;;;211    	else date=10*(COMPILED_DATE[4]-'0')+COMPILED_DATE[5]-'0';
00003c  f06f012f          MVN      r1,#0x2f
000040  2a20              CMP      r2,#0x20              ;210
000042  d04a              BEQ      |L1.218|
000044  3a30              SUBS     r2,r2,#0x30
000046  7943              LDRB     r3,[r0,#5]
000048  eb020282          ADD      r2,r2,r2,LSL #2
00004c  eb010242          ADD      r2,r1,r2,LSL #1
000050  441a              ADD      r2,r2,r3
                  |L1.82|
000052  b2d4              UXTB     r4,r2
;;;212    	year=/*1000*(COMPILED_DATE[7]-'0')+100*(COMPILED_DATE[8]-'0')*/+10*(COMPILED_DATE[9]-'0')+COMPILED_DATE[10]-'0';
000054  7a82              LDRB     r2,[r0,#0xa]
000056  7a40              LDRB     r0,[r0,#9]
000058  3830              SUBS     r0,r0,#0x30
00005a  eb000080          ADD      r0,r0,r0,LSL #2
00005e  eb010040          ADD      r0,r1,r0,LSL #1
000062  4410              ADD      r0,r0,r2
;;;213    	hour=10*(COMPILED_TIME[0]-'0')+COMPILED_TIME[1]-'0';
000064  4a20              LDR      r2,|L1.232|
000066  6812              LDR      r2,[r2,#0]  ; COMPILED_TIME
000068  7813              LDRB     r3,[r2,#0]
00006a  7855              LDRB     r5,[r2,#1]
00006c  3b30              SUBS     r3,r3,#0x30
00006e  eb030383          ADD      r3,r3,r3,LSL #2
000072  eb010343          ADD      r3,r1,r3,LSL #1
000076  442b              ADD      r3,r3,r5
000078  b2df              UXTB     r7,r3
;;;214    	min=10*(COMPILED_TIME[3]-'0')+COMPILED_TIME[4]-'0';
00007a  78d3              LDRB     r3,[r2,#3]
00007c  7915              LDRB     r5,[r2,#4]
00007e  3b30              SUBS     r3,r3,#0x30
000080  eb030383          ADD      r3,r3,r3,LSL #2
000084  eb010343          ADD      r3,r1,r3,LSL #1
000088  442b              ADD      r3,r3,r5
00008a  f00308ff          AND      r8,r3,#0xff
;;;215    	sec=10*(COMPILED_TIME[6]-'0')+COMPILED_TIME[7]-'0';
00008e  79d3              LDRB     r3,[r2,#7]
000090  7992              LDRB     r2,[r2,#6]
000092  3a30              SUBS     r2,r2,#0x30
000094  eb020282          ADD      r2,r2,r2,LSL #2
000098  eb010142          ADD      r1,r1,r2,LSL #1
00009c  4419              ADD      r1,r1,r3
00009e  f00109ff          AND      r9,r1,#0xff
;;;216    //	RTC_Set(year,mon,date,hour,min,sec)	;
;;;217    	RTC_TimeStructure.RTC_Hours =hour;
0000a2  4912              LDR      r1,|L1.236|
;;;218    	RTC_TimeStructure.RTC_Minutes = min;
;;;219    	RTC_TimeStructure.RTC_Seconds = sec;
;;;220    
;;;221    
;;;222    	RTC_DateStructure.RTC_Date = date;
;;;223    	RTC_DateStructure.RTC_Month = mon;
;;;224    	RTC_DateStructure.RTC_Year = (u8)(year&0xff);
;;;225    	RTC_DateStructure.RTC_WeekDay =   RTC_Get_Week(year+2000,mon, date);
0000a4  4622              MOV      r2,r4
0000a6  1d0d              ADDS     r5,r1,#4              ;222
0000a8  700f              STRB     r7,[r1,#0]            ;217
0000aa  f8818001          STRB     r8,[r1,#1]            ;218
0000ae  f8819002          STRB     r9,[r1,#2]            ;219
0000b2  70ac              STRB     r4,[r5,#2]            ;222
0000b4  706e              STRB     r6,[r5,#1]            ;223
0000b6  70e8              STRB     r0,[r5,#3]            ;224
0000b8  f50060fa          ADD      r0,r0,#0x7d0          ;224
0000bc  b280              UXTH     r0,r0
0000be  4631              MOV      r1,r6
0000c0  f7fffffe          BL       RTC_Get_Week
0000c4  7028              STRB     r0,[r5,#0]
0000c6  e88d0380          STM      sp,{r7-r9}
;;;226    	v1000_debug("Auto_Time_Set %d-%d-%d  %d:%d:%d\n",RTC_DateStructure.RTC_Year ,mon,date,hour,min,sec);
0000ca  78e9              LDRB     r1,[r5,#3]  ; RTC_DateStructure
0000cc  4623              MOV      r3,r4
0000ce  4632              MOV      r2,r6
0000d0  a007              ADR      r0,|L1.240|
0000d2  f7fffffe          BL       __2printf
;;;227    }
0000d6  e8bd87ff          POP      {r0-r10,pc}
                  |L1.218|
0000da  7942              LDRB     r2,[r0,#5]            ;210
0000dc  3a30              SUBS     r2,r2,#0x30           ;210
0000de  e7b8              B        |L1.82|
;;;228    
                          ENDP

                  |L1.224|
                          DCD      COMPILED_DATE
                  |L1.228|
                          DCD      ||.constdata||
                  |L1.232|
                          DCD      COMPILED_TIME
                  |L1.236|
                          DCD      ||.data||+0x10
                  |L1.240|
0000f0  4175746f          DCB      "Auto_Time_Set %d-%d-%d  %d:%d:%d\n",0
0000f4  5f54696d
0000f8  655f5365
0000fc  74202564
000100  2d25642d
000104  25642020
000108  25643a25
00010c  643a2564
000110  0a00    
000112  00                DCB      0
000113  00                DCB      0

                          AREA ||i.GetLSIFrequency||, CODE, READONLY, ALIGN=2

                  GetLSIFrequency PROC
;;;44       */
;;;45     u32 GetLSIFrequency(void)
000000  b570              PUSH     {r4-r6,lr}
;;;46     {
000002  b088              SUB      sp,sp,#0x20
;;;47       NVIC_InitTypeDef   NVIC_InitStructure;
;;;48       TIM_ICInitTypeDef  TIM_ICInitStructure;
;;;49       RCC_ClocksTypeDef  RCC_ClockFreq;
;;;50     
;;;51       /* Enable the LSI oscillator ************************************************/
;;;52       RCC_LSICmd(ENABLE);
000004  2001              MOVS     r0,#1
000006  f7fffffe          BL       RCC_LSICmd
                  |L2.10|
;;;53     
;;;54       /* Wait till LSI is ready */
;;;55       while (RCC_GetFlagStatus(RCC_FLAG_LSIRDY) == RESET)
00000a  2041              MOVS     r0,#0x41
00000c  f7fffffe          BL       RCC_GetFlagStatus
000010  2800              CMP      r0,#0
000012  d0fa              BEQ      |L2.10|
;;;56       {}
;;;57     
;;;58       /* TIM10 configuration *******************************************************/
;;;59       /* Enable TIM10 clock */
;;;60       RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM10, ENABLE);
000014  2101              MOVS     r1,#1
000016  2008              MOVS     r0,#8
000018  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;61     
;;;62       /* Reset TIM10 registers */
;;;63       TIM_DeInit(TIM10);
00001c  4e26              LDR      r6,|L2.184|
00001e  4630              MOV      r0,r6
000020  f7fffffe          BL       TIM_DeInit
;;;64     
;;;65       /* Configure TIM10 prescaler */
;;;66       TIM_PrescalerConfig(TIM10, 0, TIM_PSCReloadMode_Immediate);
000024  2201              MOVS     r2,#1
000026  2100              MOVS     r1,#0
000028  4630              MOV      r0,r6
00002a  f7fffffe          BL       TIM_PrescalerConfig
;;;67     
;;;68       /* Connect LSI clock to TIM10 Input Capture 1 */
;;;69       TIM_RemapConfig(TIM10, TIM10_LSE);
00002e  4923              LDR      r1,|L2.188|
000030  4630              MOV      r0,r6
000032  f7fffffe          BL       TIM_RemapConfig
;;;70     
;;;71       /* TIM10 configuration: Input Capture mode ---------------------
;;;72          The reference clock(LSE or external) is connected to TIM10 CH1
;;;73          The Rising edge is used as active edge,
;;;74          The TIM10 CCR1 is used to compute the frequency value
;;;75       ------------------------------------------------------------ */
;;;76       TIM_ICInitStructure.TIM_Channel     = TIM_Channel_1;
000036  2400              MOVS     r4,#0
;;;77       TIM_ICInitStructure.TIM_ICPolarity  = TIM_ICPolarity_Rising;
;;;78       TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;
000038  2501              MOVS     r5,#1
00003a  f8ad5004          STRH     r5,[sp,#4]
;;;79       TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV8;
00003e  200c              MOVS     r0,#0xc
000040  f8ad4000          STRH     r4,[sp,#0]            ;76
000044  f8ad0006          STRH     r0,[sp,#6]
000048  f8ad4002          STRH     r4,[sp,#2]            ;77
;;;80       TIM_ICInitStructure.TIM_ICFilter = 0x0;
00004c  f8ad4008          STRH     r4,[sp,#8]
;;;81       TIM_ICInit(TIM10, &TIM_ICInitStructure);
000050  4669              MOV      r1,sp
000052  4630              MOV      r0,r6
000054  f7fffffe          BL       TIM_ICInit
;;;82     
;;;83       /* Enable the TIM10 global Interrupt */
;;;84       NVIC_InitStructure.NVIC_IRQChannel = TIM10_IRQn;
000058  201a              MOVS     r0,#0x1a
00005a  f88d001c          STRB     r0,[sp,#0x1c]
;;;85       NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
00005e  f88d401d          STRB     r4,[sp,#0x1d]
;;;86       NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000062  f88d401e          STRB     r4,[sp,#0x1e]
;;;87       NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000066  f88d501f          STRB     r5,[sp,#0x1f]
;;;88       NVIC_Init(&NVIC_InitStructure);
00006a  a807              ADD      r0,sp,#0x1c
00006c  f7fffffe          BL       NVIC_Init
;;;89     
;;;90       /* Enable TIM10 counter */
;;;91       TIM_Cmd(TIM10, ENABLE);
000070  2101              MOVS     r1,#1
000072  4630              MOV      r0,r6
000074  f7fffffe          BL       TIM_Cmd
;;;92     
;;;93       /* Reset the flags */
;;;94       TIM10->SR = 0;
000078  480f              LDR      r0,|L2.184|
00007a  3010              ADDS     r0,r0,#0x10
00007c  8004              STRH     r4,[r0,#0]
;;;95     
;;;96       /* Enable the CC4 Interrupt Request */
;;;97       TIM_ITConfig(TIM10, TIM_IT_CC1, ENABLE);
00007e  2201              MOVS     r2,#1
000080  2102              MOVS     r1,#2
000082  4630              MOV      r0,r6
000084  f7fffffe          BL       TIM_ITConfig
;;;98     
;;;99     
;;;100      /* Wait until the TIM10 get 2 LSI edges (refer to TIM10_IRQHandler() in
;;;101        stm32l1xx_it.c file) ******************************************************/
;;;102      while(CaptureNumber != 2)
000088  4c0d              LDR      r4,|L2.192|
                  |L2.138|
00008a  68a0              LDR      r0,[r4,#8]  ; CaptureNumber
00008c  2802              CMP      r0,#2
00008e  d1fc              BNE      |L2.138|
;;;103      {
;;;104      }
;;;105      /* Deinitialize the TIM10 peripheral registers to their default reset values */
;;;106      TIM_DeInit(TIM10);
000090  4630              MOV      r0,r6
000092  f7fffffe          BL       TIM_DeInit
;;;107    
;;;108    
;;;109      /* Compute the LSI frequency, depending on TIM10 input clock frequency (PCLK1)*/
;;;110      /* Get SYSCLK, HCLK and PCLKx frequency */
;;;111      RCC_GetClocksFreq(&RCC_ClockFreq);
000096  a803              ADD      r0,sp,#0xc
000098  f7fffffe          BL       RCC_GetClocksFreq
;;;112    
;;;113      /* Get PCLK1 prescaler */
;;;114      if ((RCC->CFGR & RCC_CFGR_PPRE1) == 0)
00009c  4809              LDR      r0,|L2.196|
00009e  6800              LDR      r0,[r0,#0]
0000a0  f4106fe0          TST      r0,#0x700
0000a4  9805              LDR      r0,[sp,#0x14]
0000a6  d000              BEQ      |L2.170|
;;;115      {
;;;116        /* PCLK1 prescaler equal to 1 => TIMCLK = PCLK1 */
;;;117        return ((RCC_ClockFreq.PCLK1_Frequency / PeriodValue) * 8);
;;;118      }
;;;119      else
;;;120      { /* PCLK1 prescaler different from 1 => TIMCLK = 2 * PCLK1 */
;;;121        return (((2 * RCC_ClockFreq.PCLK1_Frequency) / PeriodValue) * 8) ;
0000a8  0040              LSLS     r0,r0,#1
                  |L2.170|
0000aa  68e1              LDR      r1,[r4,#0xc]  ; PeriodValue
;;;122      }
;;;123    }
0000ac  b008              ADD      sp,sp,#0x20
0000ae  fbb0f0f1          UDIV     r0,r0,r1              ;121
0000b2  00c0              LSLS     r0,r0,#3              ;121
0000b4  bd70              POP      {r4-r6,pc}
;;;124    
                          ENDP

0000b6  0000              DCW      0x0000
                  |L2.184|
                          DCD      0x40010c00
                  |L2.188|
                          DCD      0xfff40002
                  |L2.192|
                          DCD      ||.data||
                  |L2.196|
                          DCD      0x40023808

                          AREA ||i.Is_Leap_Year||, CODE, READONLY, ALIGN=1

                  Is_Leap_Year PROC
;;;559    //输出:该年份是不是闰年.1,是.0,不是
;;;560    u8 Is_Leap_Year(u16 year)
000000  0781              LSLS     r1,r0,#30
;;;561    {
000002  d10c              BNE      |L3.30|
;;;562    	if(year%4==0) //必须能被4整除
;;;563    	{
;;;564    		if(year%100==0)
000004  2164              MOVS     r1,#0x64
000006  fbb0f2f1          UDIV     r2,r0,r1
00000a  fb010112          MLS      r1,r1,r2,r0
00000e  b941              CBNZ     r1,|L3.34|
;;;565    		{
;;;566    			if(year%400==0)return 1;//如果以00结尾,还要能被400整除
000010  f44f71c8          MOV      r1,#0x190
000014  fbb0f2f1          UDIV     r2,r0,r1
000018  fb010012          MLS      r0,r1,r2,r0
00001c  b108              CBZ      r0,|L3.34|
                  |L3.30|
;;;567    			else return 0;
;;;568    		}else return 1;
;;;569    	}else return 0;
00001e  2000              MOVS     r0,#0
;;;570    }
000020  4770              BX       lr
                  |L3.34|
000022  2001              MOVS     r0,#1                 ;568
000024  4770              BX       lr
;;;571    
                          ENDP


                          AREA ||i.My_RTC_Init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  My_RTC_Init PROC
;;;405    
;;;406    void My_RTC_Init(void)
000000  b50e              PUSH     {r1-r3,lr}
;;;407    {
;;;408    RTC_InitTypeDef RTC_InitStructure;
;;;409    
;;;410    	//检查是不是第一次配置时钟
;;;411      /* Output a message on Hyperterminal using v1000_debug function */
;;;412      v1000_debug("\n\r  *********************** RTC Time Stamp Example *********************** %d\n\r",RTC_ReadBackupRegister(RTC_BKP_DR1));
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       RTC_ReadBackupRegister
000008  4601              MOV      r1,r0
00000a  4820              LDR      r0,|L4.140|
00000c  f7fffffe          BL       __2printf
;;;413    
;;;414      if (RTC_ReadBackupRegister(RTC_BKP_DR1) != 0x32F1)
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       RTC_ReadBackupRegister
000016  f5a05148          SUB      r1,r0,#0x3200
00001a  39f1              SUBS     r1,r1,#0xf1
00001c  d014              BEQ      |L4.72|
;;;415      {
;;;416        /* RTC configuration  */
;;;417        RTC_Config();
00001e  f7fffffe          BL       RTC_Config
;;;418    
;;;419        /* Configure the RTC data register and RTC prescaler */
;;;420        RTC_InitStructure.RTC_AsynchPrediv = AsynchPrediv;
000022  481b              LDR      r0,|L4.144|
000024  6801              LDR      r1,[r0,#0]  ; AsynchPrediv
;;;421        RTC_InitStructure.RTC_SynchPrediv = SynchPrediv;
000026  9101              STR      r1,[sp,#4]
000028  6840              LDR      r0,[r0,#4]  ; SynchPrediv
;;;422        RTC_InitStructure.RTC_HourFormat = RTC_HourFormat_24;
00002a  9002              STR      r0,[sp,#8]
00002c  2000              MOVS     r0,#0
;;;423    
;;;424        /* Check on RTC init */
;;;425        if (RTC_Init(&RTC_InitStructure) == ERROR)
00002e  9000              STR      r0,[sp,#0]
000030  4668              MOV      r0,sp
000032  f7fffffe          BL       RTC_Init
000036  b910              CBNZ     r0,|L4.62|
;;;426        {
;;;427          v1000_debug("\n\r        /!\\***** RTC Prescaler Config failed ********/!\\ \n\r");
000038  a016              ADR      r0,|L4.148|
00003a  f7fffffe          BL       __2printf
                  |L4.62|
;;;428        }
;;;429    
;;;430        /* Configure the time register */
;;;431        Auto_Time_Set();
00003e  f7fffffe          BL       Auto_Time_Set
;;;432        RTC_TimeRegulate();
000042  f7fffffe          BL       RTC_TimeRegulate
;;;433    
;;;434    
;;;435    
;;;436    
;;;437      }
;;;438      else
;;;439      {
;;;440        /* Check if the Power On Reset flag is set */
;;;441        if (RCC_GetFlagStatus(RCC_FLAG_PORRST) != RESET)
;;;442        {
;;;443          v1000_debug("\r\n Power On Reset occurred....\n\r");
;;;444        }
;;;445        /* Check if the Pin Reset flag is set */
;;;446        else if (RCC_GetFlagStatus(RCC_FLAG_PINRST) != RESET)
;;;447        {
;;;448          v1000_debug("\r\n External Reset occurred....\n\r");
;;;449        }
;;;450    
;;;451        v1000_debug("\r\n No need to configure RTC....\n\r");
;;;452    
;;;453        /* Enable the PWR clock */
;;;454        RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);
;;;455    
;;;456        /* Allow access to RTC */
;;;457        PWR_RTCAccessCmd(ENABLE);
;;;458    
;;;459        /* Wait for RTC APB registers synchronisation */
;;;460        RTC_WaitForSynchro();
;;;461    
;;;462        /* Clear the RTC Alarm Flag */
;;;463        RTC_ClearFlag(RTC_FLAG_ALRAF);
;;;464    
;;;465        /* Clear the EXTI Line 17 Pending bit (Connected internally to RTC Alarm) */
;;;466      //  EXTI_ClearITPendingBit(EXTI_Line17);
;;;467    
;;;468        /* Display the RTC Time/Date and TimeStamp Time/Date */
;;;469        RTC_TimeShow();
;;;470        RTC_DateShow();
;;;471      //  RTC_TimeStampShow();
;;;472      }
;;;473    #if 0//defined (RTC_CLOCK_SOURCE_LSI)  /* LSI used as RTC source clock*/
;;;474      LsiFreq = GetLSIFrequency();
;;;475      v1000_debug("\n\r     LsiFreq :%d! \n\r",LsiFreq);
;;;476      /* Calendar Configuration */
;;;477      RTC_InitStructure.RTC_AsynchPrediv = 0x7;
;;;478      RTC_InitStructure.RTC_SynchPrediv	=  0x1001;
;;;479      //RTC_InitStructure.RTC_AsynchPrediv = 0x7F;
;;;480      //RTC_InitStructure.RTC_SynchPrediv	=  (LsiFreq/128) - 1;
;;;481      RTC_InitStructure.RTC_HourFormat = RTC_HourFormat_24;
;;;482      RTC_Init(&RTC_InitStructure);
;;;483      #endif
;;;484    
;;;485      //RTC_CoarseCalibConfig(RTC_CalibSign_Negative, 0x1f);
;;;486      //RTC_CoarseCalibCmd(ENABLE);
;;;487    }
000046  bd0e              POP      {r1-r3,pc}
                  |L4.72|
000048  205b              MOVS     r0,#0x5b              ;441
00004a  f7fffffe          BL       RCC_GetFlagStatus
00004e  b108              CBZ      r0,|L4.84|
000050  a020              ADR      r0,|L4.212|
000052  e004              B        |L4.94|
                  |L4.84|
000054  205a              MOVS     r0,#0x5a              ;446
000056  f7fffffe          BL       RCC_GetFlagStatus
00005a  b110              CBZ      r0,|L4.98|
00005c  a026              ADR      r0,|L4.248|
                  |L4.94|
00005e  f7fffffe          BL       __2printf
                  |L4.98|
000062  a02e              ADR      r0,|L4.284|
000064  f7fffffe          BL       __2printf
000068  2101              MOVS     r1,#1                 ;454
00006a  0708              LSLS     r0,r1,#28             ;454
00006c  f7fffffe          BL       RCC_APB1PeriphClockCmd
000070  2001              MOVS     r0,#1                 ;457
000072  f7fffffe          BL       PWR_RTCAccessCmd
000076  f7fffffe          BL       RTC_WaitForSynchro
00007a  f44f7080          MOV      r0,#0x100             ;463
00007e  f7fffffe          BL       RTC_ClearFlag
000082  f7fffffe          BL       RTC_TimeShow
000086  f7fffffe          BL       RTC_DateShow
00008a  bd0e              POP      {r1-r3,pc}
;;;488    
                          ENDP

                  |L4.140|
                          DCD      ||.conststring||+0x178
                  |L4.144|
                          DCD      ||.data||
                  |L4.148|
000094  0a0d2020          DCB      "\n\r        /!\\***** RTC Prescaler Config failed *****"
000098  20202020
00009c  20202f21
0000a0  5c2a2a2a
0000a4  2a2a2052
0000a8  54432050
0000ac  72657363
0000b0  616c6572
0000b4  20436f6e
0000b8  66696720
0000bc  6661696c
0000c0  6564202a
0000c4  2a2a2a2a
0000c8  2a2a2a2f          DCB      "***/!\\ \n\r",0
0000cc  215c200a
0000d0  0d00    
0000d2  00                DCB      0
0000d3  00                DCB      0
                  |L4.212|
0000d4  0d0a2050          DCB      "\r\n Power On Reset occurred....\n\r",0
0000d8  6f776572
0000dc  204f6e20
0000e0  52657365
0000e4  74206f63
0000e8  63757272
0000ec  65642e2e
0000f0  2e2e0a0d
0000f4  00      
0000f5  00                DCB      0
0000f6  00                DCB      0
0000f7  00                DCB      0
                  |L4.248|
0000f8  0d0a2045          DCB      "\r\n External Reset occurred....\n\r",0
0000fc  78746572
000100  6e616c20
000104  52657365
000108  74206f63
00010c  63757272
000110  65642e2e
000114  2e2e0a0d
000118  00      
000119  00                DCB      0
00011a  00                DCB      0
00011b  00                DCB      0
                  |L4.284|
00011c  0d0a204e          DCB      "\r\n No need to configure RTC....\n\r",0
000120  6f206e65
000124  65642074
000128  6f20636f
00012c  6e666967
000130  75726520
000134  5254432e
000138  2e2e2e0a
00013c  0d00    
00013e  00                DCB      0
00013f  00                DCB      0

                          AREA ||i.RTC_Config||, CODE, READONLY, ALIGN=2

                  RTC_Config PROC
;;;129      */
;;;130    void RTC_Config(void)
000000  b510              PUSH     {r4,lr}
;;;131    {
;;;132      /* Enable the PWR clock */
;;;133      RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);
000002  2101              MOVS     r1,#1
000004  0708              LSLS     r0,r1,#28
000006  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;134    
;;;135      /* Allow access to RTC */
;;;136      PWR_RTCAccessCmd(ENABLE);
00000a  2001              MOVS     r0,#1
00000c  f7fffffe          BL       PWR_RTCAccessCmd
;;;137    
;;;138    #if defined (RTC_CLOCK_SOURCE_LSI)  /* LSI used as RTC source clock*/
;;;139    /* The RTC Clock may varies due to LSI frequency dispersion. */
;;;140      /* Enable the LSI OSC */
;;;141      RCC_LSICmd(ENABLE);
;;;142    //	LsiFreq = GetLSIFrequency();
;;;143      /* Wait till LSI is ready */
;;;144      while(RCC_GetFlagStatus(RCC_FLAG_LSIRDY) == RESET)
;;;145      {
;;;146      }
;;;147    
;;;148      /* Select the RTC Clock Source */
;;;149      RCC_RTCCLKConfig(RCC_RTCCLKSource_LSI);
;;;150    
;;;151      SynchPrediv = 0x120;
;;;152      AsynchPrediv = 0x7F;
;;;153    
;;;154    #elif defined (RTC_CLOCK_SOURCE_LSE) /* LSE used as RTC source clock */
;;;155      /* Enable the LSE OSC */
;;;156      RCC_LSEConfig(RCC_LSE_ON);
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       RCC_LSEConfig
                  |L5.22|
;;;157    
;;;158      /* Wait till LSE is ready */
;;;159      while(RCC_GetFlagStatus(RCC_FLAG_LSERDY) == RESET)
000016  2049              MOVS     r0,#0x49
000018  f7fffffe          BL       RCC_GetFlagStatus
00001c  2800              CMP      r0,#0
00001e  d0fa              BEQ      |L5.22|
;;;160      {
;;;161      }
;;;162    
;;;163      /* Select the RTC Clock Source */
;;;164      RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);
000020  f44f3080          MOV      r0,#0x10000
000024  f7fffffe          BL       RCC_RTCCLKConfig
;;;165    
;;;166      SynchPrediv = 0xFF;
000028  4805              LDR      r0,|L5.64|
00002a  21ff              MOVS     r1,#0xff
00002c  6041              STR      r1,[r0,#4]  ; SynchPrediv
;;;167      AsynchPrediv = 0x7F;
00002e  217f              MOVS     r1,#0x7f
000030  6001              STR      r1,[r0,#0]  ; AsynchPrediv
;;;168    
;;;169    #else
;;;170      #error Please select the RTC Clock source inside the main.c file
;;;171    #endif /* RTC_CLOCK_SOURCE_LSI */
;;;172    
;;;173      /* Enable the RTC Clock */
;;;174      RCC_RTCCLKCmd(ENABLE);
000032  2001              MOVS     r0,#1
000034  f7fffffe          BL       RCC_RTCCLKCmd
;;;175    
;;;176      /* Wait for RTC APB registers synchronisation */
;;;177      RTC_WaitForSynchro();
000038  e8bd4010          POP      {r4,lr}
00003c  f7ffbffe          B.W      RTC_WaitForSynchro
;;;178    
;;;179      /* Enable The TimeStamp */
;;;180    //  RTC_TimeStampCmd(RTC_TimeStampEdge_Falling, ENABLE);
;;;181    }
;;;182    
                          ENDP

                  |L5.64|
                          DCD      ||.data||

                          AREA ||i.RTC_DateShow||, CODE, READONLY, ALIGN=2

                  RTC_DateShow PROC
;;;376      */
;;;377    void RTC_DateShow(void)
000000  4901              LDR      r1,|L6.8|
;;;378    {
;;;379      /* Get the current Date */
;;;380      RTC_GetDate(RTC_Format_BIN, &RTC_DateStructure);
000002  2000              MOVS     r0,#0
000004  f7ffbffe          B.W      RTC_GetDate
;;;381    
;;;382    
;;;383     // v1000_debug("\n\r============== Current Date Display ============================\n\r");
;;;384     // v1000_debug("\n\r  The current date (WeekDay-Date-Month-Year) is :  %0.2d-%0.2d-%0.2d-%0.2d \n\r", RTC_DateStructure.RTC_WeekDay, RTC_DateStructure.RTC_Date, RTC_DateStructure.RTC_Month, RTC_DateStructure.RTC_Year);
;;;385    }
;;;386    
                          ENDP

                  |L6.8|
                          DCD      ||.data||+0x14

                          AREA ||i.RTC_Get||, CODE, READONLY, ALIGN=2

                  RTC_Get PROC
;;;576    //返回值:0,成功;其他:错误代码.
;;;577    u8 RTC_Get(u8 flag,tm *my_timer)
000000  b510              PUSH     {r4,lr}
;;;578    {
000002  460c              MOV      r4,r1
000004  0002              MOVS     r2,r0
;;;579    //	extern tm my_timer;
;;;580    	u16 temp1=0;
;;;581    	if(flag)
;;;582    	{
;;;583    		my_timer->w_date +=1;  //得到日期
;;;584    		if(Is_Leap_Year(my_timer->w_year)&&(my_timer->w_month == 1))
;;;585    		{
;;;586    			temp1 = 29;
;;;587    		}
;;;588    		else
;;;589    		{
;;;590    			temp1 = mon_table[my_timer->w_month - 1];
000006  4b21              LDR      r3,|L7.140|
000008  78c9              LDRB     r1,[r1,#3]            ;583
00000a  8820              LDRH     r0,[r4,#0]            ;584
00000c  d01a              BEQ      |L7.68|
00000e  1c49              ADDS     r1,r1,#1              ;578
000010  70e1              STRB     r1,[r4,#3]            ;583
000012  f7fffffe          BL       Is_Leap_Year
000016  b110              CBZ      r0,|L7.30|
000018  78a0              LDRB     r0,[r4,#2]            ;584
00001a  2801              CMP      r0,#1                 ;584
00001c  d010              BEQ      |L7.64|
                  |L7.30|
00001e  78a0              LDRB     r0,[r4,#2]
000020  5cc0              LDRB     r0,[r0,r3]
                  |L7.34|
;;;591    	    }
;;;592    
;;;593    		if(my_timer->w_date>temp1 )
000022  78e1              LDRB     r1,[r4,#3]
000024  4281              CMP      r1,r0
000026  d928              BLS      |L7.122|
;;;594    	    {
;;;595    			my_timer->w_date=1;//平年
000028  2001              MOVS     r0,#1
00002a  70e0              STRB     r0,[r4,#3]
;;;596    			my_timer->w_month++;//得到月份
00002c  78a1              LDRB     r1,[r4,#2]
00002e  1c49              ADDS     r1,r1,#1
000030  b2c9              UXTB     r1,r1
000032  70a1              STRB     r1,[r4,#2]
;;;597    			if(my_timer->w_month>12)
000034  290c              CMP      r1,#0xc
000036  d920              BLS      |L7.122|
;;;598    				{
;;;599    				my_timer->w_month = 1;
000038  70a0              STRB     r0,[r4,#2]
;;;600    				my_timer->w_year++;
00003a  8820              LDRH     r0,[r4,#0]
00003c  1c40              ADDS     r0,r0,#1
00003e  e01b              B        |L7.120|
                  |L7.64|
000040  201d              MOVS     r0,#0x1d              ;586
000042  e7ee              B        |L7.34|
                  |L7.68|
000044  1e49              SUBS     r1,r1,#1              ;586
;;;601    				}
;;;602    	    }
;;;603    
;;;604    	}
;;;605        else
;;;606    	{
;;;607    	    my_timer->w_date -=1;  //得到日期
000046  f01101ff          ANDS     r1,r1,#0xff
00004a  70e1              STRB     r1,[r4,#3]
;;;608    	    if(my_timer->w_date == 0)
00004c  d115              BNE      |L7.122|
;;;609    		{
;;;610    	    	my_timer->w_month--;//得到月份
00004e  78a1              LDRB     r1,[r4,#2]
000050  1e49              SUBS     r1,r1,#1
000052  70a1              STRB     r1,[r4,#2]
;;;611    
;;;612    		    if(Is_Leap_Year(my_timer->w_year)&&my_timer->w_month==1)
000054  f7fffffe          BL       Is_Leap_Year
000058  b110              CBZ      r0,|L7.96|
00005a  78a0              LDRB     r0,[r4,#2]
00005c  2801              CMP      r0,#1
00005e  d005              BEQ      |L7.108|
                  |L7.96|
;;;613    			{
;;;614    			    temp1 = 29;
;;;615    			}
;;;616    		    else
;;;617    			    temp1 = mon_table[my_timer->w_month - 1];
000060  78a0              LDRB     r0,[r4,#2]
000062  5cc0              LDRB     r0,[r0,r3]
                  |L7.100|
;;;618    
;;;619    
;;;620    		    my_timer->w_date= temp1;//平年
000064  70e0              STRB     r0,[r4,#3]
;;;621    
;;;622    		    if(my_timer->w_month == 0)
000066  78a0              LDRB     r0,[r4,#2]
000068  b110              CBZ      r0,|L7.112|
00006a  e006              B        |L7.122|
                  |L7.108|
00006c  201d              MOVS     r0,#0x1d              ;614
00006e  e7f9              B        |L7.100|
                  |L7.112|
;;;623    			{
;;;624    			    my_timer->w_month = 12;
000070  200c              MOVS     r0,#0xc
000072  70a0              STRB     r0,[r4,#2]
;;;625    			    my_timer->w_year--;
000074  8820              LDRH     r0,[r4,#0]
000076  1e40              SUBS     r0,r0,#1
                  |L7.120|
000078  8020              STRH     r0,[r4,#0]
                  |L7.122|
;;;626    			}
;;;627    		}
;;;628    
;;;629        }
;;;630    
;;;631    	my_timer->week = RTC_Get_Week(my_timer->w_year,my_timer->w_month,my_timer->w_date);//获取星期
00007a  78e2              LDRB     r2,[r4,#3]
00007c  78a1              LDRB     r1,[r4,#2]
00007e  8820              LDRH     r0,[r4,#0]
000080  f7fffffe          BL       RTC_Get_Week
000084  7120              STRB     r0,[r4,#4]
;;;632    	return 0;
000086  2000              MOVS     r0,#0
;;;633    }
000088  bd10              POP      {r4,pc}
;;;634    
                          ENDP

00008a  0000              DCW      0x0000
                  |L7.140|
                          DCD      ||.constdata||+0x2f

                          AREA ||i.RTC_Get_Week||, CODE, READONLY, ALIGN=2

                  RTC_Get_Week PROC
;;;537    //返回值：星期号
;;;538    u8 RTC_Get_Week(u16 year,u8 month,u8 day)
000000  b530              PUSH     {r4,r5,lr}
;;;539    {
;;;540    	u16 temp2;
;;;541    	u8 yearH,yearL;
;;;542    
;;;543    	yearH=year/100;	yearL=year%100;
000002  2464              MOVS     r4,#0x64
000004  fbb0f5f4          UDIV     r5,r0,r4
000008  b2eb              UXTB     r3,r5
00000a  fb040015          MLS      r0,r4,r5,r0
;;;544    	// 如果为21世纪,年份数加100
;;;545    	if (yearH>19)yearL+=100;
00000e  2b13              CMP      r3,#0x13
000010  d901              BLS      |L8.22|
000012  3064              ADDS     r0,r0,#0x64           ;539
000014  b2c0              UXTB     r0,r0
                  |L8.22|
;;;546    	// 所过闰年数只算1900年之后的
;;;547    	temp2=yearL+yearL/4;
000016  eb000490          ADD      r4,r0,r0,LSR #2
;;;548    	temp2=temp2%7;
00001a  2307              MOVS     r3,#7
00001c  fbb4f5f3          UDIV     r5,r4,r3
000020  fb034415          MLS      r4,r3,r5,r4
;;;549    	temp2=temp2+day+table_week[month-1];
000024  4d08              LDR      r5,|L8.72|
000026  4422              ADD      r2,r2,r4
000028  440d              ADD      r5,r5,r1
;;;550    	if (yearL%4==0&&month<3)temp2--;
00002a  0780              LSLS     r0,r0,#30
00002c  f8155c01          LDRB     r5,[r5,#-1]           ;549
000030  442a              ADD      r2,r2,r5              ;549
000032  b292              UXTH     r2,r2                 ;549
000034  d103              BNE      |L8.62|
000036  2903              CMP      r1,#3
000038  d201              BCS      |L8.62|
00003a  1e52              SUBS     r2,r2,#1
00003c  b292              UXTH     r2,r2
                  |L8.62|
;;;551    	return(temp2%7);
00003e  fbb2f0f3          UDIV     r0,r2,r3
000042  fb032010          MLS      r0,r3,r0,r2
;;;552    }
000046  bd30              POP      {r4,r5,pc}
;;;553    
                          ENDP

                  |L8.72|
                          DCD      ||.constdata||+0x24

                          AREA ||i.RTC_TimeRegulate||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  RTC_TimeRegulate PROC
;;;234      */
;;;235    void RTC_TimeRegulate(void)
000000  b510              PUSH     {r4,lr}
;;;236    {
;;;237    //  uint32_t tmp_hh = 0xFF, tmp_mm = 0xFF, tmp_ss = 0xFF;
;;;238    
;;;239      v1000_debug("\n\r==============Time Settings=====================================\n\r");
000002  481e              LDR      r0,|L9.124|
000004  f7fffffe          BL       __2printf
;;;240      RTC_TimeStructure.RTC_H12     = RTC_H12_AM;
000008  491d              LDR      r1,|L9.128|
00000a  2000              MOVS     r0,#0
00000c  70c8              STRB     r0,[r1,#3]
;;;241    
;;;242    #if 0
;;;243      v1000_debug("  Please Set Hours\n\r");
;;;244      while (tmp_hh == 0xFF)
;;;245      {
;;;246        tmp_hh = USART_Scanf(0, 23);
;;;247        RTC_TimeStructure.RTC_Hours = tmp_hh;
;;;248      }
;;;249      v1000_debug(":  %0.2d\n\r", tmp_hh);
;;;250    
;;;251      v1000_debug("  Please Set Minutes\n\r");
;;;252      while (tmp_mm == 0xFF)
;;;253      {
;;;254        tmp_mm = USART_Scanf(0, 59);
;;;255        RTC_TimeStructure.RTC_Minutes = tmp_mm;
;;;256      }
;;;257      v1000_debug(":  %0.2d\n\r", tmp_mm);
;;;258    
;;;259      v1000_debug("  Please Set Seconds\n\r");
;;;260      while (tmp_ss == 0xFF)
;;;261      {
;;;262        tmp_ss = USART_Scanf(0, 59);
;;;263        RTC_TimeStructure.RTC_Seconds = tmp_ss;
;;;264      }
;;;265      v1000_debug(":  %0.2d\n\r", tmp_ss);
;;;266    #endif
;;;267    
;;;268    
;;;269      /* Configure the RTC time register */
;;;270      if(RTC_SetTime(RTC_Format_BIN, &RTC_TimeStructure) == ERROR)
00000e  f7fffffe          BL       RTC_SetTime
000012  2800              CMP      r0,#0
000014  d029              BEQ      |L9.106|
;;;271      {
;;;272        v1000_debug("\n\r>> !! RTC Set Time failed. !! <<\n\r");
;;;273      }
;;;274      else
;;;275      {
;;;276        v1000_debug("\n\r>> !! RTC Set Time success. !! <<\n\r");
000016  a01b              ADR      r0,|L9.132|
000018  f7fffffe          BL       __2printf
;;;277        RTC_TimeShow();
00001c  f7fffffe          BL       RTC_TimeShow
;;;278        /* Indicator for the RTC configuration */
;;;279        RTC_WriteBackupRegister(RTC_BKP_DR1, 0x32F0);
000020  f24321f0          MOV      r1,#0x32f0
000024  2001              MOVS     r0,#1
000026  f7fffffe          BL       RTC_WriteBackupRegister
                  |L9.42|
;;;280      }
;;;281    
;;;282    //  tmp_hh = 0xFF;
;;;283    //  tmp_mm = 0xFF;
;;;284    //  tmp_ss = 0xFF;
;;;285    
;;;286      v1000_debug("\n\r==============Date Settings=====================================\n\r");
00002a  4820              LDR      r0,|L9.172|
00002c  f7fffffe          BL       __2printf
;;;287    
;;;288      v1000_debug("  Please Set WeekDay (01-07)\n\r");
000030  a01f              ADR      r0,|L9.176|
000032  f7fffffe          BL       __2printf
;;;289    
;;;290    #if 0
;;;291      while (tmp_hh == 0xFF)
;;;292      {
;;;293        tmp_hh = USART_Scanf(1, 7);
;;;294        RTC_DateStructure.RTC_WeekDay = tmp_hh;
;;;295      }
;;;296      v1000_debug(":  %0.2d\n\r", tmp_hh);
;;;297      tmp_hh = 0xFF;
;;;298      v1000_debug("  Please Set Date (01-31)\n\r");
;;;299      while (tmp_hh == 0xFF)
;;;300      {
;;;301        tmp_hh = USART_Scanf(1, 31);
;;;302        RTC_DateStructure.RTC_Date = tmp_hh;
;;;303      }
;;;304      v1000_debug(":  %0.2d\n\r", tmp_hh);
;;;305    
;;;306      v1000_debug("  Please Set Month (01-12)\n\r");
;;;307      while (tmp_mm == 0xFF)
;;;308      {
;;;309        tmp_mm = USART_Scanf(1, 12);
;;;310        RTC_DateStructure.RTC_Month = tmp_mm;
;;;311      }
;;;312      v1000_debug(":  %0.2d\n\r", tmp_mm);
;;;313    
;;;314      v1000_debug("  Please Set Year (00-99)\n\r");
;;;315      while (tmp_ss == 0xFF)
;;;316      {
;;;317        tmp_ss = USART_Scanf(0, 99);
;;;318        RTC_DateStructure.RTC_Year = tmp_ss;
;;;319      }
;;;320      v1000_debug(":  %0.2d\n\r", tmp_ss);
;;;321    #endif
;;;322    
;;;323    
;;;324    /* Configure the RTC date register */
;;;325      if(RTC_SetDate(RTC_Format_BIN, &RTC_DateStructure) == ERROR)
000036  4912              LDR      r1,|L9.128|
000038  2000              MOVS     r0,#0
00003a  1d09              ADDS     r1,r1,#4
00003c  f7fffffe          BL       RTC_SetDate
000040  2800              CMP      r0,#0
000042  d016              BEQ      |L9.114|
;;;326      {
;;;327        v1000_debug("\n\r>> !! RTC Set Date failed. !! <<\n\r");
;;;328      }
;;;329      else
;;;330      {
;;;331        v1000_debug("\n\r>> !! RTC Set Date success. !! <<\n\r");
000044  a022              ADR      r0,|L9.208|
000046  f7fffffe          BL       __2printf
;;;332        RTC_DateShow();
00004a  f7fffffe          BL       RTC_DateShow
;;;333        /* Indicator for the RTC configuration */
;;;334        RTC_WriteBackupRegister(RTC_BKP_DR1, 0x32F1);
00004e  f24321f1          MOV      r1,#0x32f1
000052  2001              MOVS     r0,#1
000054  f7fffffe          BL       RTC_WriteBackupRegister
                  |L9.88|
;;;335      }
;;;336      v1000_debug("\n\r  RTC_BKP_DR1 : %x\n\r",RTC_ReadBackupRegister(RTC_BKP_DR1));
000058  2001              MOVS     r0,#1
00005a  f7fffffe          BL       RTC_ReadBackupRegister
00005e  4601              MOV      r1,r0
000060  e8bd4010          POP      {r4,lr}
000064  a024              ADR      r0,|L9.248|
000066  f7ffbffe          B.W      __2printf
                  |L9.106|
00006a  a029              ADR      r0,|L9.272|
00006c  f7fffffe          BL       __2printf
000070  e7db              B        |L9.42|
                  |L9.114|
000072  a031              ADR      r0,|L9.312|
000074  f7fffffe          BL       __2printf
000078  e7ee              B        |L9.88|
;;;337    }
;;;338    //rtc_set(13,09,30,09,19,28,1)
                          ENDP

00007a  0000              DCW      0x0000
                  |L9.124|
                          DCD      ||.conststring||
                  |L9.128|
                          DCD      ||.data||+0x10
                  |L9.132|
000084  0a0d3e3e          DCB      "\n\r>> !! RTC Set Time success. !! <<\n\r",0
000088  20212120
00008c  52544320
000090  53657420
000094  54696d65
000098  20737563
00009c  63657373
0000a0  2e202121
0000a4  203c3c0a
0000a8  0d00    
0000aa  00                DCB      0
0000ab  00                DCB      0
                  |L9.172|
                          DCD      ||.conststring||+0x48
                  |L9.176|
0000b0  2020506c          DCB      "  Please Set WeekDay (01-07)\n\r",0
0000b4  65617365
0000b8  20536574
0000bc  20576565
0000c0  6b446179
0000c4  20283031
0000c8  2d303729
0000cc  0a0d00  
0000cf  00                DCB      0
                  |L9.208|
0000d0  0a0d3e3e          DCB      "\n\r>> !! RTC Set Date success. !! <<\n\r",0
0000d4  20212120
0000d8  52544320
0000dc  53657420
0000e0  44617465
0000e4  20737563
0000e8  63657373
0000ec  2e202121
0000f0  203c3c0a
0000f4  0d00    
0000f6  00                DCB      0
0000f7  00                DCB      0
                  |L9.248|
0000f8  0a0d2020          DCB      "\n\r  RTC_BKP_DR1 : %x\n\r",0
0000fc  5254435f
000100  424b505f
000104  44523120
000108  3a202578
00010c  0a0d00  
00010f  00                DCB      0
                  |L9.272|
000110  0a0d3e3e          DCB      "\n\r>> !! RTC Set Time failed. !! <<\n\r",0
000114  20212120
000118  52544320
00011c  53657420
000120  54696d65
000124  20666169
000128  6c65642e
00012c  20212120
000130  3c3c0a0d
000134  00      
000135  00                DCB      0
000136  00                DCB      0
000137  00                DCB      0
                  |L9.312|
000138  0a0d3e3e          DCB      "\n\r>> !! RTC Set Date failed. !! <<\n\r",0
00013c  20212120
000140  52544320
000144  53657420
000148  44617465
00014c  20666169
000150  6c65642e
000154  20212120
000158  3c3c0a0d
00015c  00      
00015d  00                DCB      0
00015e  00                DCB      0
00015f  00                DCB      0

                          AREA ||i.RTC_TimeShow||, CODE, READONLY, ALIGN=2

                  RTC_TimeShow PROC
;;;361      */
;;;362    void RTC_TimeShow(void)
000000  b510              PUSH     {r4,lr}
;;;363    {
;;;364      /* Get the current Time and Date */
;;;365      RTC_GetTime(RTC_Format_BIN, &RTC_TimeStructure);
000002  4903              LDR      r1,|L10.16|
000004  2000              MOVS     r0,#0
000006  f7fffffe          BL       RTC_GetTime
;;;366     // v1000_debug("\n\r============== Current Time Display ============================\n\r");
;;;367     // v1000_debug("\n\r  The current time (Hour-Minute-Second) is :  %0.2d:%0.2d:%0.2d \n\r", RTC_TimeStructure.RTC_Hours, RTC_TimeStructure.RTC_Minutes, RTC_TimeStructure.RTC_Seconds);
;;;368      /* Unfreeze the RTC DR Register */
;;;369      (void)RTC->DR;
00000a  4802              LDR      r0,|L10.20|
00000c  6800              LDR      r0,[r0,#0]
;;;370    }
00000e  bd10              POP      {r4,pc}
;;;371    
                          ENDP

                  |L10.16|
                          DCD      ||.data||+0x10
                  |L10.20|
                          DCD      0x40002804

                          AREA ||i.RTC_TimeStampShow||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  RTC_TimeStampShow PROC
;;;392      */
;;;393    void RTC_TimeStampShow(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;394    {
;;;395      RTC_TimeTypeDef  RTC_TimeStampStructure;
;;;396      RTC_DateTypeDef  RTC_TimeStampDateStructure;
;;;397    
;;;398      /* Get the current TimeStamp */
;;;399      RTC_GetTimeStamp(RTC_Format_BIN, &RTC_TimeStampStructure, &RTC_TimeStampDateStructure);
000002  aa01              ADD      r2,sp,#4
000004  4669              MOV      r1,sp
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       RTC_GetTimeStamp
;;;400      v1000_debug("\n\r==============TimeStamp Display (Time and Date)=================\n\r");
00000c  480a              LDR      r0,|L11.56|
00000e  f7fffffe          BL       __2printf
;;;401      v1000_debug("\n\r  The current time stamp time (Hour-Minute-Second) is :  %0.2d:%0.2d:%0.2d \n\r", RTC_TimeStampStructure.RTC_Hours, RTC_TimeStampStructure.RTC_Minutes, RTC_TimeStampStructure.RTC_Seconds);
000012  f89d3002          LDRB     r3,[sp,#2]
000016  f89d2001          LDRB     r2,[sp,#1]
00001a  f89d1000          LDRB     r1,[sp,#0]
00001e  4807              LDR      r0,|L11.60|
000020  f7fffffe          BL       __2printf
;;;402      v1000_debug("\n\r  The current timestamp date (WeekDay-Date-Month) is :  %0.2d-%0.2d-%0.2d \n\r", RTC_TimeStampDateStructure.RTC_WeekDay, RTC_TimeStampDateStructure.RTC_Date, RTC_TimeStampDateStructure.RTC_Month);
000024  f89d3005          LDRB     r3,[sp,#5]
000028  f89d2006          LDRB     r2,[sp,#6]
00002c  f89d1004          LDRB     r1,[sp,#4]
000030  4803              LDR      r0,|L11.64|
000032  f7fffffe          BL       __2printf
;;;403    }
000036  bd1c              POP      {r2-r4,pc}
;;;404    
                          ENDP

                  |L11.56|
                          DCD      ||.conststring||+0x90
                  |L11.60|
                          DCD      ||.conststring||+0xd8
                  |L11.64|
                          DCD      ||.conststring||+0x128

                          AREA ||i.get_fattime||, CODE, READONLY, ALIGN=2

                  get_fattime PROC
;;;506    
;;;507    DWORD get_fattime (void)
000000  b510              PUSH     {r4,lr}
;;;508    {
;;;509        DWORD fattime = 0;
;;;510    
;;;511        //RTC_TimeRegulate();
;;;512        RTC_DateShow();
000002  f7fffffe          BL       RTC_DateShow
;;;513        RTC_TimeShow();
000006  f7fffffe          BL       RTC_TimeShow
;;;514    
;;;515        fattime =  ((DWORD)((RTC_DateStructure.RTC_Year + 20) << 25) | (DWORD)(RTC_DateStructure.RTC_Month<< 21) | (DWORD)(RTC_DateStructure.RTC_Date<< 16));
00000a  480b              LDR      r0,|L12.56|
00000c  78c1              LDRB     r1,[r0,#3]  ; RTC_DateStructure
00000e  7842              LDRB     r2,[r0,#1]  ; RTC_DateStructure
000010  0649              LSLS     r1,r1,#25
000012  f1015120          ADD      r1,r1,#0x28000000
000016  7880              LDRB     r0,[r0,#2]  ; RTC_DateStructure
000018  ea415142          ORR      r1,r1,r2,LSL #21
00001c  ea414100          ORR      r1,r1,r0,LSL #16
;;;516        fattime |= ((DWORD)((RTC_TimeStructure.RTC_Hours) << 11) | (DWORD)(RTC_TimeStructure.RTC_Minutes<< 5)|((DWORD)(RTC_TimeStructure.RTC_Seconds)/2));
000020  4805              LDR      r0,|L12.56|
000022  1f00              SUBS     r0,r0,#4
000024  7802              LDRB     r2,[r0,#0]  ; RTC_TimeStructure
000026  7843              LDRB     r3,[r0,#1]  ; RTC_TimeStructure
000028  02d2              LSLS     r2,r2,#11
00002a  7880              LDRB     r0,[r0,#2]  ; RTC_TimeStructure
00002c  ea421243          ORR      r2,r2,r3,LSL #5
000030  ea420050          ORR      r0,r2,r0,LSR #1
000034  4308              ORRS     r0,r0,r1
;;;517    
;;;518        
;;;519        return fattime;
;;;520    
;;;521        
;;;522            
;;;523    }
000036  bd10              POP      {r4,pc}
;;;524    
                          ENDP

                  |L12.56|
                          DCD      ||.data||+0x14

                          AREA ||i.rtc_set||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  rtc_set PROC
;;;338    //rtc_set(13,09,30,09,19,28,1)
;;;339    void  rtc_set(u16 syear,u8 smon,u8 sday,u8 hour,u8 min,u8 sec,u8 week)
000000  e92d47ff          PUSH     {r0-r10,lr}
;;;340    {
000004  4604              MOV      r4,r0
000006  e9dd600d          LDRD     r6,r0,[sp,#0x34]
;;;341    
;;;342    
;;;343    	v1000_debug("rtc_set %d-%d-%d  %d:%d:%d %d\n",syear ,smon,sday,hour,min,sec,week);
00000a  9f0c              LDR      r7,[sp,#0x30]
00000c  461d              MOV      r5,r3                 ;340
00000e  e9cd6002          STRD     r6,r0,[sp,#8]
000012  4690              MOV      r8,r2                 ;340
000014  4613              MOV      r3,r2
000016  e9cd5700          STRD     r5,r7,[sp,#0]
00001a  4689              MOV      r9,r1                 ;340
00001c  460a              MOV      r2,r1
00001e  4621              MOV      r1,r4
000020  a00d              ADR      r0,|L13.88|
000022  f7fffffe          BL       __2printf
;;;344    	RTC_TimeStructure.RTC_Hours =hour;
000026  4814              LDR      r0,|L13.120|
;;;345    	RTC_TimeStructure.RTC_Minutes = min;
;;;346    	RTC_TimeStructure.RTC_Seconds = sec;
;;;347    
;;;348    
;;;349    
;;;350    	RTC_DateStructure.RTC_WeekDay =  RTC_Get_Week(syear+2000, smon, sday);
000028  4642              MOV      r2,r8
00002a  4649              MOV      r1,r9
00002c  7005              STRB     r5,[r0,#0]            ;344
00002e  7047              STRB     r7,[r0,#1]            ;345
000030  7086              STRB     r6,[r0,#2]            ;346
000032  f50460fa          ADD      r0,r4,#0x7d0
000036  b280              UXTH     r0,r0
000038  f7fffffe          BL       RTC_Get_Week
00003c  4601              MOV      r1,r0
00003e  480e              LDR      r0,|L13.120|
000040  1d00              ADDS     r0,r0,#4
000042  7001              STRB     r1,[r0,#0]
;;;351    	RTC_DateStructure.RTC_Date = sday;
000044  f8808002          STRB     r8,[r0,#2]
;;;352    	RTC_DateStructure.RTC_Month = smon;
000048  f8809001          STRB     r9,[r0,#1]
;;;353    	RTC_DateStructure.RTC_Year = syear;
00004c  70c4              STRB     r4,[r0,#3]
;;;354    	RTC_TimeRegulate();
00004e  e8bd47ff          POP      {r0-r10,lr}
000052  f7ffbffe          B.W      RTC_TimeRegulate
;;;355    }
;;;356    
                          ENDP

000056  0000              DCW      0x0000
                  |L13.88|
000058  7274635f          DCB      "rtc_set %d-%d-%d  %d:%d:%d %d\n",0
00005c  73657420
000060  25642d25
000064  642d2564
000068  20202564
00006c  3a25643a
000070  25642025
000074  640a00  
000077  00                DCB      0
                  |L13.120|
                          DCD      ||.data||+0x10

                          AREA ||i.str_cmpx||, CODE, READONLY, ALIGN=2

                  str_cmpx PROC
;;;185    //返回值:1,相等;0,不相等
;;;186    u8 str_cmpx(u8*s1,u8*s2,u8 len)
000000  b530              PUSH     {r4,r5,lr}
;;;187    {
;;;188    	u8 i;
;;;189    	for(i=0;i<len;i++)if((*s1++)!=*s2++)return 0;
000002  2300              MOVS     r3,#0
000004  e00a              B        |L14.28|
000006  bf00              NOP      
                  |L14.8|
000008  f8104b01          LDRB     r4,[r0],#1
00000c  f8115b01          LDRB     r5,[r1],#1
000010  42ac              CMP      r4,r5
000012  d001              BEQ      |L14.24|
000014  2000              MOVS     r0,#0
;;;190    	return 1;
;;;191    }
000016  bd30              POP      {r4,r5,pc}
                  |L14.24|
000018  1c5b              ADDS     r3,r3,#1
00001a  b2db              UXTB     r3,r3                 ;189
                  |L14.28|
00001c  4293              CMP      r3,r2                 ;189
00001e  d3f3              BCC      |L14.8|
000020  2001              MOVS     r0,#1                 ;190
000022  bd30              POP      {r4,r5,pc}
;;;192    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  Month_Tab
000000  4a616e46          DCB      0x4a,0x61,0x6e,0x46
000004  65624d61          DCB      0x65,0x62,0x4d,0x61
000008  72417072          DCB      0x72,0x41,0x70,0x72
00000c  4d61794a          DCB      0x4d,0x61,0x79,0x4a
000010  756e4a75          DCB      0x75,0x6e,0x4a,0x75
000014  6c417567          DCB      0x6c,0x41,0x75,0x67
000018  5365704f          DCB      0x53,0x65,0x70,0x4f
00001c  63744e6f          DCB      0x63,0x74,0x4e,0x6f
000020  76446563          DCB      0x76,0x44,0x65,0x63
                  table_week
000024  00030306          DCB      0x00,0x03,0x03,0x06
000028  01040602          DCB      0x01,0x04,0x06,0x02
00002c  05000305          DCB      0x05,0x00,0x03,0x05
                  mon_table
000030  1f1c1f1e          DCB      0x1f,0x1c,0x1f,0x1e
000034  1f1e1f1f          DCB      0x1f,0x1e,0x1f,0x1f
000038  1e1f1e1f          DCB      0x1e,0x1f,0x1e,0x1f

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  0a0d3d3d          DCB      "\n\r==============Time Settings========================"
000004  3d3d3d3d
000008  3d3d3d3d
00000c  3d3d3d3d
000010  54696d65
000014  20536574
000018  74696e67
00001c  733d3d3d
000020  3d3d3d3d
000024  3d3d3d3d
000028  3d3d3d3d
00002c  3d3d3d3d
000030  3d3d3d3d
000034  3d      
000035  3d3d3d3d          DCB      "=============\n\r",0
000039  3d3d3d3d
00003d  3d3d3d3d
000041  3d0a0d00
000045  00                DCB      0
000046  00                DCB      0
000047  00                DCB      0
000048  0a0d3d3d          DCB      "\n\r==============Date Settings========================"
00004c  3d3d3d3d
000050  3d3d3d3d
000054  3d3d3d3d
000058  44617465
00005c  20536574
000060  74696e67
000064  733d3d3d
000068  3d3d3d3d
00006c  3d3d3d3d
000070  3d3d3d3d
000074  3d3d3d3d
000078  3d3d3d3d
00007c  3d      
00007d  3d3d3d3d          DCB      "=============\n\r",0
000081  3d3d3d3d
000085  3d3d3d3d
000089  3d0a0d00
00008d  00                DCB      0
00008e  00                DCB      0
00008f  00                DCB      0
000090  0a0d3d3d          DCB      "\n\r==============TimeStamp Display (Time and Date)===="
000094  3d3d3d3d
000098  3d3d3d3d
00009c  3d3d3d3d
0000a0  54696d65
0000a4  5374616d
0000a8  70204469
0000ac  73706c61
0000b0  79202854
0000b4  696d6520
0000b8  616e6420
0000bc  44617465
0000c0  293d3d3d
0000c4  3d      
0000c5  3d3d3d3d          DCB      "=============\n\r",0
0000c9  3d3d3d3d
0000cd  3d3d3d3d
0000d1  3d0a0d00
0000d5  00                DCB      0
0000d6  00                DCB      0
0000d7  00                DCB      0
0000d8  0a0d2020          DCB      "\n\r  The current time stamp time (Hour-Minute-Second) "
0000dc  54686520
0000e0  63757272
0000e4  656e7420
0000e8  74696d65
0000ec  20737461
0000f0  6d702074
0000f4  696d6520
0000f8  28486f75
0000fc  722d4d69
000100  6e757465
000104  2d536563
000108  6f6e6429
00010c  20      
00010d  6973203a          DCB      "is :  %0.2d:%0.2d:%0.2d \n\r",0
000111  20202530
000115  2e32643a
000119  25302e32
00011d  643a2530
000121  2e326420
000125  0a0d00  
000128  0a0d2020          DCB      "\n\r  The current timestamp date (WeekDay-Date-Month) i"
00012c  54686520
000130  63757272
000134  656e7420
000138  74696d65
00013c  7374616d
000140  70206461
000144  74652028
000148  5765656b
00014c  4461792d
000150  44617465
000154  2d4d6f6e
000158  74682920
00015c  69      
00015d  73203a20          DCB      "s :  %0.2d-%0.2d-%0.2d \n\r",0
000161  2025302e
000165  32642d25
000169  302e3264
00016d  2d25302e
000171  3264200a
000175  0d00    
000177  00                DCB      0
000178  0a0d2020          DCB      "\n\r  *********************** RTC Time Stamp Example **"
00017c  2a2a2a2a
000180  2a2a2a2a
000184  2a2a2a2a
000188  2a2a2a2a
00018c  2a2a2a2a
000190  2a2a2a20
000194  52544320
000198  54696d65
00019c  20537461
0001a0  6d702045
0001a4  78616d70
0001a8  6c65202a
0001ac  2a      
0001ad  2a2a2a2a          DCB      "********************* %d\n\r",0
0001b1  2a2a2a2a
0001b5  2a2a2a2a
0001b9  2a2a2a2a
0001bd  2a2a2a2a
0001c1  2a202564
0001c5  0a0d00  

                          AREA ||.data||, DATA, ALIGN=2

                  AsynchPrediv
                          DCD      0x00000000
                  SynchPrediv
                          DCD      0x00000000
                  CaptureNumber
                          DCD      0x00000000
                  PeriodValue
                          DCD      0x00000000
                  RTC_TimeStructure
                          DCD      0x00000000
                  RTC_DateStructure
                          DCD      0x00000000

                          AREA ||area_number.20||, DATA, ALIGN=2

                          EXPORTAS ||area_number.20||, ||.data||
                  LsiFreq
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\src\\HARDWARE\\RTC\\rtc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_rtc_c_0ef083ce____REV16|
#line 114 "..\\..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___5_rtc_c_0ef083ce____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_rtc_c_0ef083ce____REVSH|
#line 128
|__asm___5_rtc_c_0ef083ce____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
