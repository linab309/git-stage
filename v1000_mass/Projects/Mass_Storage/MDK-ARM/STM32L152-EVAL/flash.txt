; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm32l152-eval\flash.o --asm_dir=.\STM32L152-EVAL\ --list_dir=.\STM32L152-EVAL\ --depend=.\stm32l152-eval\flash.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32L1xx\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32L1xx_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM32L152_EVAL -I..\src\user -I..\src\user\include -I..\src\SYSTEM\delay -I..\src\SYSTEM\sys -I..\src\SYSTEM\usart -I..\src\HARDWARE\ADC -I..\src\HARDWARE\BMP -I..\src\HARDWARE\DMA -I..\src\HARDWARE\FLASH -I..\src\HARDWARE\GPS -I..\src\HARDWARE\KEY -I..\src\HARDWARE\PWM -I..\src\HARDWARE\RTC -I..\src\HARDWARE\SPI -I..\src\HARDWARE\USART2 -I..\src\HARDWARE\TIMER -I..\src\EX -I..\src\USMART -I..\..\..\Libraries\CMSIS\Include -I..\src\ff11a\src -I..\src\ff11a\src\option -I..\src\HARDWARE\LED -I..\src\HARDWARE\OLED -I..\src\ff11a\src -I..\src\ff11a\src\option -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.1.0\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32L1xx -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32L1XX_MD -DUSE_STM32L152_EVAL ..\src\HARDWARE\FLASH\flash.c]
                          THUMB

                          AREA ||i.SPI_FLASH_Write_Disable||, CODE, READONLY, ALIGN=2

                  SPI_FLASH_Write_Disable PROC
;;;77     //将WEL清零  
;;;78     void SPI_FLASH_Write_Disable(void)   
000000  b510              PUSH     {r4,lr}
;;;79     {  
;;;80     	SPI_FLASH_CS=0;                            //使能器件   
000002  4c06              LDR      r4,|L1.28|
000004  2000              MOVS     r0,#0
000006  f8c40290          STR      r0,[r4,#0x290]
;;;81         SPIx_ReadWriteByte(W25X_WriteDisable);     //发送写禁止指令    
00000a  2004              MOVS     r0,#4
00000c  f5047424          ADD      r4,r4,#0x290
000010  f7fffffe          BL       SPIx_ReadWriteByte
;;;82     	SPI_FLASH_CS=1;                            //取消片选     	      
000014  2001              MOVS     r0,#1
000016  6020              STR      r0,[r4,#0]
;;;83     } 			    
000018  bd10              POP      {r4,pc}
;;;84     //读取芯片ID W25X16的ID:0XEF14
                          ENDP

00001a  0000              DCW      0x0000
                  |L1.28|
                          DCD      0x42400000

                          AREA ||i.SPI_FLASH_Write_Enable||, CODE, READONLY, ALIGN=2

                  SPI_FLASH_Write_Enable PROC
;;;69     //将WEL置位   
;;;70     void SPI_FLASH_Write_Enable(void)   
000000  b510              PUSH     {r4,lr}
;;;71     {
;;;72     	SPI_FLASH_CS=0;                            //使能器件   
000002  4c06              LDR      r4,|L2.28|
000004  2000              MOVS     r0,#0
000006  f8c40290          STR      r0,[r4,#0x290]
;;;73         SPIx_ReadWriteByte(W25X_WriteEnable);      //发送写使能  
00000a  2006              MOVS     r0,#6
00000c  f5047424          ADD      r4,r4,#0x290
000010  f7fffffe          BL       SPIx_ReadWriteByte
;;;74     	SPI_FLASH_CS=1;                            //取消片选     	      
000014  2001              MOVS     r0,#1
000016  6020              STR      r0,[r4,#0]
;;;75     } 
000018  bd10              POP      {r4,pc}
;;;76     //SPI_FLASH写禁止	
                          ENDP

00001a  0000              DCW      0x0000
                  |L2.28|
                          DCD      0x42400000

                          AREA ||i.SPI_FLASH_Write_SR||, CODE, READONLY, ALIGN=2

                  SPI_FLASH_Write_SR PROC
;;;60     //只有SPR,TB,BP2,BP1,BP0(bit 7,5,4,3,2)可以写!!!
;;;61     void SPI_FLASH_Write_SR(u8 sr)   
000000  b570              PUSH     {r4-r6,lr}
;;;62     {   
;;;63     	SPI_FLASH_CS=0;                            //使能器件   
000002  4c08              LDR      r4,|L3.36|
000004  4605              MOV      r5,r0                 ;62
000006  2000              MOVS     r0,#0
000008  f8c40290          STR      r0,[r4,#0x290]
;;;64     	SPIx_ReadWriteByte(W25X_WriteStatusReg);   //发送写取状态寄存器命令    
00000c  2001              MOVS     r0,#1
00000e  f5047424          ADD      r4,r4,#0x290
000012  f7fffffe          BL       SPIx_ReadWriteByte
;;;65     	SPIx_ReadWriteByte(sr);               //写入一个字节  
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       SPIx_ReadWriteByte
;;;66     	SPI_FLASH_CS=1;                            //取消片选     	      
00001c  2001              MOVS     r0,#1
00001e  6020              STR      r0,[r4,#0]
;;;67     }   
000020  bd70              POP      {r4-r6,pc}
;;;68     //SPI_FLASH写使能	
                          ENDP

000022  0000              DCW      0x0000
                  |L3.36|
                          DCD      0x42400000

                          AREA ||i.SPI_Flash_Erase_Chip||, CODE, READONLY, ALIGN=2

                  SPI_Flash_Erase_Chip PROC
;;;245    //等待时间超长...
;;;246    void SPI_Flash_Erase_Chip(void)   
000000  b510              PUSH     {r4,lr}
;;;247    {                                             
;;;248        SPI_FLASH_Write_Enable();                  //SET WEL 
000002  f7fffffe          BL       SPI_FLASH_Write_Enable
;;;249        SPI_Flash_Wait_Busy();   
000006  f7fffffe          BL       SPI_Flash_Wait_Busy
;;;250      	SPI_FLASH_CS=0;                            //使能器件   
00000a  4c07              LDR      r4,|L4.40|
00000c  2000              MOVS     r0,#0
00000e  f8c40290          STR      r0,[r4,#0x290]
;;;251        SPIx_ReadWriteByte(W25X_ChipErase);        //发送片擦除命令  
000012  20c7              MOVS     r0,#0xc7
000014  f5047424          ADD      r4,r4,#0x290
000018  f7fffffe          BL       SPIx_ReadWriteByte
;;;252    	SPI_FLASH_CS=1;                            //取消片选     	      
00001c  2001              MOVS     r0,#1
00001e  6020              STR      r0,[r4,#0]
;;;253    	SPI_Flash_Wait_Busy();   				   //等待芯片擦除结束
000020  e8bd4010          POP      {r4,lr}
000024  f7ffbffe          B.W      SPI_Flash_Wait_Busy
;;;254    }   
;;;255    //擦除一个扇区
                          ENDP

                  |L4.40|
                          DCD      0x42400000

                          AREA ||i.SPI_Flash_Erase_Sector||, CODE, READONLY, ALIGN=2

                  SPI_Flash_Erase_Sector PROC
;;;257    //擦除一个山区的最少时间:150ms
;;;258    void SPI_Flash_Erase_Sector(u32 Dst_Addr)   
000000  b570              PUSH     {r4-r6,lr}
;;;259    {   
;;;260    	Dst_Addr*=4096;
000002  0304              LSLS     r4,r0,#12
;;;261        SPI_FLASH_Write_Enable();                  //SET WEL 	 
000004  f7fffffe          BL       SPI_FLASH_Write_Enable
;;;262        SPI_Flash_Wait_Busy();   
000008  f7fffffe          BL       SPI_Flash_Wait_Busy
;;;263      	SPI_FLASH_CS=0;                            //使能器件   
00000c  4d0c              LDR      r5,|L5.64|
00000e  2000              MOVS     r0,#0
000010  f8c50290          STR      r0,[r5,#0x290]
;;;264        SPIx_ReadWriteByte(W25X_SectorErase);      //发送扇区擦除指令 
000014  2020              MOVS     r0,#0x20
000016  f5057524          ADD      r5,r5,#0x290
00001a  f7fffffe          BL       SPIx_ReadWriteByte
;;;265        SPIx_ReadWriteByte((u8)((Dst_Addr)>>16));  //发送24bit地址    
00001e  f3c44007          UBFX     r0,r4,#16,#8
000022  f7fffffe          BL       SPIx_ReadWriteByte
;;;266        SPIx_ReadWriteByte((u8)((Dst_Addr)>>8));   
000026  f3c42007          UBFX     r0,r4,#8,#8
00002a  f7fffffe          BL       SPIx_ReadWriteByte
;;;267        SPIx_ReadWriteByte((u8)Dst_Addr);  
00002e  b2e0              UXTB     r0,r4
000030  f7fffffe          BL       SPIx_ReadWriteByte
;;;268    	SPI_FLASH_CS=1;                            //取消片选     	      
000034  2001              MOVS     r0,#1
000036  6028              STR      r0,[r5,#0]
;;;269        SPI_Flash_Wait_Busy();   				   //等待擦除完成
000038  e8bd4070          POP      {r4-r6,lr}
00003c  f7ffbffe          B.W      SPI_Flash_Wait_Busy
;;;270    }  
;;;271    //等待空闲
                          ENDP

                  |L5.64|
                          DCD      0x42400000

                          AREA ||i.SPI_Flash_Init||, CODE, READONLY, ALIGN=1

                  SPI_Flash_Init PROC
;;;29     //初始化SPI FLASH的IO口
;;;30     void SPI_Flash_Init(void)
000000  f7ffbffe          B.W      SPIx_Init
;;;31     {
;;;32     #if 0
;;;33     	RCC->APB2ENR|=1<<2;       //PORTA时钟使能 	    
;;;34     	//这里 
;;;35     	GPIOA->CRL&=0XFFF0F0FF; 
;;;36     	GPIOA->CRL|=0X00030300;//PA2.3.4 推挽 	    
;;;37     	GPIOA->ODR|=0X5<<2;    //PA2.3.4上拉
;;;38     #endif
;;;39     	SPIx_Init();		   //初始化SPI
;;;40     }  
;;;41     
                          ENDP


                          AREA ||i.SPI_Flash_PowerDown||, CODE, READONLY, ALIGN=2

                  SPI_Flash_PowerDown PROC
;;;276    //进入掉电模式
;;;277    void SPI_Flash_PowerDown(void)   
000000  b510              PUSH     {r4,lr}
;;;278    { 
;;;279      	SPI_FLASH_CS=0;                            //使能器件   
000002  4c08              LDR      r4,|L7.36|
000004  2000              MOVS     r0,#0
000006  f8c40290          STR      r0,[r4,#0x290]
;;;280        SPIx_ReadWriteByte(W25X_PowerDown);        //发送掉电命令  
00000a  20b9              MOVS     r0,#0xb9
00000c  f5047424          ADD      r4,r4,#0x290
000010  f7fffffe          BL       SPIx_ReadWriteByte
;;;281    	SPI_FLASH_CS=1;                            //取消片选     	      
000014  2001              MOVS     r0,#1
000016  6020              STR      r0,[r4,#0]
;;;282        delay_us(3);                               //等待TPD  
000018  e8bd4010          POP      {r4,lr}
00001c  2003              MOVS     r0,#3
00001e  f7ffbffe          B.W      delay_us
;;;283    }   
;;;284    //唤醒
                          ENDP

000022  0000              DCW      0x0000
                  |L7.36|
                          DCD      0x42400000

                          AREA ||i.SPI_Flash_Read||, CODE, READONLY, ALIGN=2

                  SPI_Flash_Read PROC
;;;102    //NumByteToRead:要读取的字节数(最大65535)
;;;103    void SPI_Flash_Read(u8* pBuffer,u32 ReadAddr,u16 NumByteToRead)   
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;104    { 
;;;105     	u16 i;    												    
;;;106    	SPI_FLASH_CS=0;                            //使能器件   
000004  4e11              LDR      r6,|L8.76|
000006  4607              MOV      r7,r0                 ;104
000008  2000              MOVS     r0,#0
00000a  4615              MOV      r5,r2                 ;104
00000c  460c              MOV      r4,r1                 ;104
00000e  f8c60290          STR      r0,[r6,#0x290]
;;;107        SPIx_ReadWriteByte(W25X_ReadData);         //发送读取命令   
000012  2003              MOVS     r0,#3
000014  f7fffffe          BL       SPIx_ReadWriteByte
;;;108        SPIx_ReadWriteByte((u8)((ReadAddr)>>16));  //发送24bit地址    
000018  f3c44007          UBFX     r0,r4,#16,#8
00001c  f7fffffe          BL       SPIx_ReadWriteByte
;;;109        SPIx_ReadWriteByte((u8)((ReadAddr)>>8));   
000020  f3c42007          UBFX     r0,r4,#8,#8
000024  f7fffffe          BL       SPIx_ReadWriteByte
;;;110        SPIx_ReadWriteByte((u8)ReadAddr);   
000028  b2e0              UXTB     r0,r4
00002a  f7fffffe          BL       SPIx_ReadWriteByte
;;;111        for(i=0;i<NumByteToRead;i++)
00002e  2400              MOVS     r4,#0
000030  e005              B        |L8.62|
                  |L8.50|
;;;112    	{ 
;;;113            pBuffer[i]=SPIx_ReadWriteByte(0XFF);   //循环读数  
000032  20ff              MOVS     r0,#0xff
000034  f7fffffe          BL       SPIx_ReadWriteByte
000038  5538              STRB     r0,[r7,r4]
00003a  1c64              ADDS     r4,r4,#1
00003c  b2a4              UXTH     r4,r4                 ;111
                  |L8.62|
00003e  42ac              CMP      r4,r5                 ;111
000040  d3f7              BCC      |L8.50|
;;;114        }
;;;115    	SPI_FLASH_CS=1;                            //取消片选     
000042  2001              MOVS     r0,#1
000044  f8c60290          STR      r0,[r6,#0x290]
;;;116    }  
000048  e8bd81f0          POP      {r4-r8,pc}
;;;117    //SPI在一页(0~65535)内写入少于256个字节的数据
                          ENDP

                  |L8.76|
                          DCD      0x42400000

                          AREA ||i.SPI_Flash_ReadID||, CODE, READONLY, ALIGN=2

                  SPI_Flash_ReadID PROC
;;;84     //读取芯片ID W25X16的ID:0XEF14
;;;85     u16 SPI_Flash_ReadID(void)
000000  b570              PUSH     {r4-r6,lr}
;;;86     {
;;;87     	u16 Temp = 0;	  
;;;88     	SPI_FLASH_CS=0;				    
000002  4c0f              LDR      r4,|L9.64|
000004  2500              MOVS     r5,#0
000006  f8c45290          STR      r5,[r4,#0x290]
;;;89     	SPIx_ReadWriteByte(0x90);//发送读取ID命令	    
00000a  2090              MOVS     r0,#0x90
00000c  f5047424          ADD      r4,r4,#0x290
000010  f7fffffe          BL       SPIx_ReadWriteByte
;;;90     	SPIx_ReadWriteByte(0x00); 	    
000014  2000              MOVS     r0,#0
000016  f7fffffe          BL       SPIx_ReadWriteByte
;;;91     	SPIx_ReadWriteByte(0x00); 	    
00001a  2000              MOVS     r0,#0
00001c  f7fffffe          BL       SPIx_ReadWriteByte
;;;92     	SPIx_ReadWriteByte(0x00); 	 			   
000020  2000              MOVS     r0,#0
000022  f7fffffe          BL       SPIx_ReadWriteByte
;;;93     	Temp|=SPIx_ReadWriteByte(0xFF)<<8;  
000026  20ff              MOVS     r0,#0xff
000028  f7fffffe          BL       SPIx_ReadWriteByte
00002c  ea452500          ORR      r5,r5,r0,LSL #8
;;;94     	Temp|=SPIx_ReadWriteByte(0xFF);	 
000030  20ff              MOVS     r0,#0xff
000032  f7fffffe          BL       SPIx_ReadWriteByte
000036  4328              ORRS     r0,r0,r5
;;;95     	SPI_FLASH_CS=1;				    
000038  2101              MOVS     r1,#1
00003a  6021              STR      r1,[r4,#0]
;;;96     	return Temp;
;;;97     }   		    
00003c  bd70              POP      {r4-r6,pc}
;;;98     //读取SPI FLASH  
                          ENDP

00003e  0000              DCW      0x0000
                  |L9.64|
                          DCD      0x42400000

                          AREA ||i.SPI_Flash_ReadSR||, CODE, READONLY, ALIGN=2

                  SPI_Flash_ReadSR PROC
;;;49     //默认:0x00
;;;50     u8 SPI_Flash_ReadSR(void)   
000000  b510              PUSH     {r4,lr}
;;;51     {  
;;;52     	u8 byte=0;   
;;;53     	SPI_FLASH_CS=0;                            //使能器件   
000002  4c07              LDR      r4,|L10.32|
000004  2000              MOVS     r0,#0
000006  f8c40290          STR      r0,[r4,#0x290]
;;;54     	SPIx_ReadWriteByte(W25X_ReadStatusReg);    //发送读取状态寄存器命令    
00000a  2005              MOVS     r0,#5
00000c  f5047424          ADD      r4,r4,#0x290
000010  f7fffffe          BL       SPIx_ReadWriteByte
;;;55     	byte=SPIx_ReadWriteByte(0Xff);             //读取一个字节  
000014  20ff              MOVS     r0,#0xff
000016  f7fffffe          BL       SPIx_ReadWriteByte
;;;56     	SPI_FLASH_CS=1;                            //取消片选     
00001a  2101              MOVS     r1,#1
00001c  6021              STR      r1,[r4,#0]
;;;57     	return byte;   
;;;58     } 
00001e  bd10              POP      {r4,pc}
;;;59     //写SPI_FLASH状态寄存器
                          ENDP

                  |L10.32|
                          DCD      0x42400000

                          AREA ||i.SPI_Flash_WAKEUP||, CODE, READONLY, ALIGN=2

                  SPI_Flash_WAKEUP PROC
;;;284    //唤醒
;;;285    void SPI_Flash_WAKEUP(void)   
000000  b510              PUSH     {r4,lr}
;;;286    {  
;;;287      	SPI_FLASH_CS=0;                            //使能器件   
000002  4c08              LDR      r4,|L11.36|
000004  2000              MOVS     r0,#0
000006  f8c40290          STR      r0,[r4,#0x290]
;;;288        SPIx_ReadWriteByte(W25X_ReleasePowerDown);   //  send W25X_PowerDown command 0xAB    
00000a  20ab              MOVS     r0,#0xab
00000c  f5047424          ADD      r4,r4,#0x290
000010  f7fffffe          BL       SPIx_ReadWriteByte
;;;289    	SPI_FLASH_CS=1;                            //取消片选     	      
000014  2001              MOVS     r0,#1
000016  6020              STR      r0,[r4,#0]
;;;290        delay_us(3);                               //等待TRES1
000018  e8bd4010          POP      {r4,lr}
00001c  2003              MOVS     r0,#3
00001e  f7ffbffe          B.W      delay_us
;;;291    
;;;292    
;;;293    }
;;;294    
                          ENDP

000022  0000              DCW      0x0000
                  |L11.36|
                          DCD      0x42400000

                          AREA ||i.SPI_Flash_Wait_Busy||, CODE, READONLY, ALIGN=2

                  SPI_Flash_Wait_Busy PROC
;;;271    //等待空闲
;;;272    void SPI_Flash_Wait_Busy(void)   
000000  e92d4010          PUSH.W   {r4,lr}
                  |L12.4|
;;;273    {   
;;;274    	while ((SPI_Flash_ReadSR()&0x01)==0x01);   // 等待BUSY位清空
000004  f7fffffe          BL       SPI_Flash_ReadSR
000008  07c0              LSLS     r0,r0,#31
00000a  d1fb              BNE      |L12.4|
;;;275    }  
00000c  bd10              POP      {r4,pc}
;;;276    //进入掉电模式
                          ENDP


                          AREA ||i.SPI_Flash_Write||, CODE, READONLY, ALIGN=2

                  SPI_Flash_Write PROC
;;;171    
;;;172    void SPI_Flash_Write(u8* pBuffer,u32 WriteAddr,u16 NumByteToWrite)   
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;173    { 
;;;174    	u32 secpos;
;;;175    	u16 secoff;
;;;176    	u16 secremain;	   
;;;177     	u16 i;    
;;;178           u8 SPI_FLASH_BUF[4096];
;;;179    
;;;180    	
;;;181    	secpos=WriteAddr/4096;//扇区地址 0~511 for w25x16
;;;182    	secoff=WriteAddr%4096;//在扇区内的偏移
000004  f3c1070b          UBFX     r7,r1,#0,#12
000008  b081              SUB      sp,sp,#4              ;173
00000a  0b0e              LSRS     r6,r1,#12             ;181
;;;183    	secremain=4096-secoff;//扇区剩余空间大小   
00000c  f5c75480          RSB      r4,r7,#0x1000
000010  f5ad5d80          SUB      sp,sp,#0x1000         ;173
000014  4688              MOV      r8,r1                 ;173
000016  4682              MOV      r10,r0                ;173
000018  4615              MOV      r5,r2                 ;173
;;;184    
;;;185    	if(NumByteToWrite<=secremain)secremain=NumByteToWrite;//不大于4096个字节
00001a  42a2              CMP      r2,r4
00001c  d800              BHI      |L13.32|
00001e  4614              MOV      r4,r2
                  |L13.32|
000020  46e9              MOV      r9,sp                 ;178
                  |L13.34|
;;;186    	while(1) 
;;;187    	{	
;;;188    		SPI_Flash_Read(SPI_FLASH_BUF,secpos*4096,4096);//读出整个扇区的内容
000022  0331              LSLS     r1,r6,#12
000024  468b              MOV      r11,r1
000026  f44f5280          MOV      r2,#0x1000
00002a  4648              MOV      r0,r9
00002c  f7fffffe          BL       SPI_Flash_Read
;;;189    		for(i=0;i<secremain;i++)//校验数据
000030  2000              MOVS     r0,#0
000032  e006              B        |L13.66|
                  |L13.52|
;;;190    		{
;;;191    			if(SPI_FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除  	  
000034  183a              ADDS     r2,r7,r0
000036  f8191002          LDRB     r1,[r9,r2]
00003a  29ff              CMP      r1,#0xff
00003c  d103              BNE      |L13.70|
00003e  1c40              ADDS     r0,r0,#1
000040  b280              UXTH     r0,r0                 ;189
                  |L13.66|
000042  42a0              CMP      r0,r4                 ;189
000044  d3f6              BCC      |L13.52|
                  |L13.70|
;;;192    		}
;;;193    		if(i<secremain)//需要擦除
000046  42a0              CMP      r0,r4
000048  d222              BCS      |L13.144|
;;;194    		{
;;;195    			SPI_Flash_Erase_Sector(secpos);//擦除这个扇区
00004a  4630              MOV      r0,r6
00004c  f7fffffe          BL       SPI_Flash_Erase_Sector
;;;196    			for(i=0;i<secremain;i++)	   //复制
000050  2000              MOVS     r0,#0
000052  464b              MOV      r3,r9                 ;178
000054  e006              B        |L13.100|
;;;197    			{
;;;198    				SPI_FLASH_BUF[i+secoff]=pBuffer[i];	  
000056  bf00              NOP      
                  |L13.88|
000058  f81a1000          LDRB     r1,[r10,r0]
00005c  19c2              ADDS     r2,r0,r7
00005e  1c40              ADDS     r0,r0,#1
000060  5499              STRB     r1,[r3,r2]
000062  b280              UXTH     r0,r0                 ;196
                  |L13.100|
000064  42a0              CMP      r0,r4                 ;196
000066  d3f7              BCC      |L13.88|
000068  4659              MOV      r1,r11                ;196
;;;199    			}
;;;200    			SPI_Flash_Write_NoCheck(SPI_FLASH_BUF,secpos*4096,4096);//写入整个扇区  
00006a  f44f5280          MOV      r2,#0x1000
00006e  4648              MOV      r0,r9
                  |L13.112|
;;;201    
;;;202    		}else SPI_Flash_Write_NoCheck(pBuffer,WriteAddr,secremain);//写已经擦除了的,直接写入扇区剩余区间. 				   
000070  f7fffffe          BL       SPI_Flash_Write_NoCheck
;;;203    		if(NumByteToWrite==secremain)break;//写入结束了
000074  42a5              CMP      r5,r4
000076  d00f              BEQ      |L13.152|
;;;204    		else//写入未结束
;;;205    		{
;;;206    			secpos++;//扇区地址增1
;;;207    			secoff=0;//偏移位置为0 	 
;;;208    
;;;209    		   	pBuffer+=secremain;  //指针偏移
;;;210    			WriteAddr+=secremain;//写地址偏移	   
;;;211    		   	NumByteToWrite-=secremain;				//字节数递减
000078  1b28              SUBS     r0,r5,r4
00007a  44a2              ADD      r10,r10,r4            ;209
00007c  44a0              ADD      r8,r8,r4              ;210
00007e  2700              MOVS     r7,#0                 ;207
000080  b285              UXTH     r5,r0
;;;212    			if(NumByteToWrite>4096)secremain=4096;	//下一个扇区还是写不完
000082  f44f5480          MOV      r4,#0x1000
000086  1c76              ADDS     r6,r6,#1
000088  42a5              CMP      r5,r4
00008a  d8ca              BHI      |L13.34|
;;;213    			else secremain=NumByteToWrite;			//下一个扇区可以写完了
00008c  462c              MOV      r4,r5
00008e  e7c8              B        |L13.34|
                  |L13.144|
000090  4622              MOV      r2,r4                 ;202
000092  4641              MOV      r1,r8                 ;202
000094  4650              MOV      r0,r10                ;202
000096  e7eb              B        |L13.112|
                  |L13.152|
;;;214    		}	 
;;;215    	};	 	 
;;;216    }
000098  b001              ADD      sp,sp,#4
00009a  f50d5d80          ADD      sp,sp,#0x1000
00009e  e8bd8ff0          POP      {r4-r11,pc}
;;;217    #else
                          ENDP


                          AREA ||i.SPI_Flash_Write_NoCheck||, CODE, READONLY, ALIGN=1

                  SPI_Flash_Write_NoCheck PROC
;;;142    //CHECK OK
;;;143    void SPI_Flash_Write_NoCheck(u8* pBuffer,u32 WriteAddr,u16 NumByteToWrite)   
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;144    { 			 		 
000004  4607              MOV      r7,r0
;;;145    	u16 pageremain;	   
;;;146    	pageremain=256-WriteAddr%256; //单页剩余的字节数		 	    
000006  b2c8              UXTB     r0,r1
000008  f5c07480          RSB      r4,r0,#0x100
00000c  460e              MOV      r6,r1                 ;144
00000e  4615              MOV      r5,r2                 ;144
;;;147    	if(NumByteToWrite<=pageremain)pageremain=NumByteToWrite;//不大于256个字节
000010  42a2              CMP      r2,r4
000012  d800              BHI      |L14.22|
000014  4614              MOV      r4,r2
                  |L14.22|
;;;148    	while(1)
;;;149    	{	   
;;;150    		SPI_Flash_Write_Page(pBuffer,WriteAddr,pageremain);
;;;151    		if(NumByteToWrite==pageremain)break;//写入结束了
;;;152    	 	else //NumByteToWrite>pageremain
;;;153    		{
;;;154    			pBuffer+=pageremain;
;;;155    			WriteAddr+=pageremain;	
;;;156    
;;;157    			NumByteToWrite-=pageremain;			  //减去已经写入了的字节数
;;;158    			if(NumByteToWrite>256)pageremain=256; //一次可以写入256个字节
000016  f44f7880          MOV      r8,#0x100
                  |L14.26|
00001a  4622              MOV      r2,r4                 ;150
00001c  4631              MOV      r1,r6                 ;150
00001e  4638              MOV      r0,r7                 ;150
000020  f7fffffe          BL       SPI_Flash_Write_Page
000024  42a5              CMP      r5,r4                 ;151
000026  d008              BEQ      |L14.58|
000028  1b28              SUBS     r0,r5,r4              ;157
00002a  4427              ADD      r7,r7,r4              ;154
00002c  4426              ADD      r6,r6,r4              ;155
00002e  b285              UXTH     r5,r0                 ;157
000030  4644              MOV      r4,r8
000032  42a5              CMP      r5,r4
000034  d8f1              BHI      |L14.26|
;;;159    			else pageremain=NumByteToWrite; 	  //不够256个字节了
000036  462c              MOV      r4,r5
000038  e7ef              B        |L14.26|
                  |L14.58|
;;;160    		}
;;;161    	};	    
;;;162    } 
00003a  e8bd81f0          POP      {r4-r8,pc}
;;;163    
                          ENDP


                          AREA ||i.SPI_Flash_Write_Page||, CODE, READONLY, ALIGN=2

                  SPI_Flash_Write_Page PROC
;;;121    //NumByteToWrite:要写入的字节数(最大256),该数不应该超过该页的剩余字节数!!!	 
;;;122    void SPI_Flash_Write_Page(u8* pBuffer,u32 WriteAddr,u16 NumByteToWrite)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;123    {
000004  4615              MOV      r5,r2
000006  460c              MOV      r4,r1
000008  4607              MOV      r7,r0
;;;124     	u16 i;  
;;;125        SPI_FLASH_Write_Enable();                  //SET WEL 
00000a  f7fffffe          BL       SPI_FLASH_Write_Enable
;;;126    	SPI_FLASH_CS=0;                            //使能器件   
00000e  4e11              LDR      r6,|L15.84|
000010  2000              MOVS     r0,#0
000012  f8c60290          STR      r0,[r6,#0x290]
;;;127        SPIx_ReadWriteByte(W25X_PageProgram);      //发送写页命令   
000016  2002              MOVS     r0,#2
000018  f7fffffe          BL       SPIx_ReadWriteByte
;;;128        SPIx_ReadWriteByte((u8)((WriteAddr)>>16)); //发送24bit地址    
00001c  f3c44007          UBFX     r0,r4,#16,#8
000020  f7fffffe          BL       SPIx_ReadWriteByte
;;;129        SPIx_ReadWriteByte((u8)((WriteAddr)>>8));   
000024  f3c42007          UBFX     r0,r4,#8,#8
000028  f7fffffe          BL       SPIx_ReadWriteByte
;;;130        SPIx_ReadWriteByte((u8)WriteAddr);   
00002c  b2e0              UXTB     r0,r4
00002e  f7fffffe          BL       SPIx_ReadWriteByte
;;;131        for(i=0;i<NumByteToWrite;i++)SPIx_ReadWriteByte(pBuffer[i]);//循环写数  
000032  2400              MOVS     r4,#0
000034  e004              B        |L15.64|
                  |L15.54|
000036  5d38              LDRB     r0,[r7,r4]
000038  f7fffffe          BL       SPIx_ReadWriteByte
00003c  1c64              ADDS     r4,r4,#1
00003e  b2a4              UXTH     r4,r4
                  |L15.64|
000040  42ac              CMP      r4,r5
000042  d3f8              BCC      |L15.54|
;;;132    	SPI_FLASH_CS=1;                            //取消片选 
000044  2001              MOVS     r0,#1
000046  f8c60290          STR      r0,[r6,#0x290]
;;;133    	SPI_Flash_Wait_Busy();					   //等待写入结束
00004a  e8bd41f0          POP      {r4-r8,lr}
00004e  f7ffbffe          B.W      SPI_Flash_Wait_Busy
;;;134    } 
;;;135    //无检验写SPI FLASH 
                          ENDP

000052  0000              DCW      0x0000
                  |L15.84|
                          DCD      0x42400000

                          AREA ||i.restore_pass||, CODE, READONLY, ALIGN=2

                  restore_pass PROC
;;;503    
;;;504    void restore_pass(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;505    {
000002  f2ad4d84          SUB      sp,sp,#0x484
;;;506        u16 i ;
;;;507        extern int16_t temperature_pass[];
;;;508        extern int16_t speed_pass[];
;;;509        extern s32 pressure_pass[];
;;;510        extern s32 Altitude_pass[];
;;;511        extern u8 old_div_cnt;
;;;512        extern u8 old_spped_div_cnt ;
;;;513        extern u8 old_altiude_div_cnt ;
;;;514    
;;;515    
;;;516        extern s32  most_Altitude ;
;;;517        extern s32 lest_Altitude ;
;;;518        extern int16_t most_temperature ;
;;;519        extern int16_t lest_temperature ;
;;;520        extern int16_t most_speed ;
;;;521        extern int16_t lest_speed ;
;;;522        extern s32 most_pressure ;
;;;523        extern s32 lest_pressure ;
;;;524        u8 SPI_FLASH_BUF[1154];
;;;525    
;;;526        SPI_Flash_Read(SPI_FLASH_BUF,CHANGE_PRE_VAULE_SAVE_ADDRES,1152);//读出整个扇区的内容
000006  f44f6290          MOV      r2,#0x480
00000a  493d              LDR      r1,|L16.256|
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       SPI_Flash_Read
;;;527    
;;;528        if(old_div_cnt<=96)
000012  4c3c              LDR      r4,|L16.260|
000014  466a              MOV      r2,sp                 ;524
000016  7821              LDRB     r1,[r4,#0]  ; old_div_cnt
000018  2960              CMP      r1,#0x60
00001a  d81a              BHI      |L16.82|
;;;529        {
;;;530            for(i = 0;i<96;i++)
;;;531            {
;;;532                temperature_pass[i] = ((SPI_FLASH_BUF[384+(i*2)])|(SPI_FLASH_BUF[385+(i*2)]<<8));
00001c  4b3a              LDR      r3,|L16.264|
00001e  2000              MOVS     r0,#0                 ;530
                  |L16.32|
000020  eb020540          ADD      r5,r2,r0,LSL #1
000024  f8b55180          LDRH     r5,[r5,#0x180]
000028  f8235010          STRH     r5,[r3,r0,LSL #1]
00002c  1c40              ADDS     r0,r0,#1
00002e  b280              UXTH     r0,r0                 ;530
000030  2860              CMP      r0,#0x60              ;530
000032  d3f5              BCC      |L16.32|
;;;533       
;;;534            }
;;;535    
;;;536       
;;;537            for(i = 0;i<96;i++)
;;;538            {
;;;539                pressure_pass[i] = ((SPI_FLASH_BUF[0+(i*4)])|(SPI_FLASH_BUF[1+(i*4)]<<8)|(SPI_FLASH_BUF[2+(i*4)]<<16)|(SPI_FLASH_BUF[3+(i*4)]<<24));
000034  4b35              LDR      r3,|L16.268|
000036  2000              MOVS     r0,#0                 ;537
                  |L16.56|
000038  eb020580          ADD      r5,r2,r0,LSL #2
00003c  78ee              LDRB     r6,[r5,#3]
00003e  f8525020          LDR      r5,[r2,r0,LSL #2]
000042  f366651f          BFI      r5,r6,#24,#8
000046  f8435020          STR      r5,[r3,r0,LSL #2]
00004a  1c40              ADDS     r0,r0,#1
00004c  b280              UXTH     r0,r0                 ;537
00004e  2860              CMP      r0,#0x60              ;537
000050  d3f2              BCC      |L16.56|
                  |L16.82|
;;;540            }
;;;541        }
;;;542    
;;;543        if(old_spped_div_cnt <= 96 )
000052  4d2f              LDR      r5,|L16.272|
000054  7828              LDRB     r0,[r5,#0]  ; old_spped_div_cnt
000056  2860              CMP      r0,#0x60
000058  d80c              BHI      |L16.116|
;;;544        {
;;;545    
;;;546            for(i = 0;i<96;i++)
;;;547            {
;;;548                speed_pass[i] = (SPI_FLASH_BUF[576+(i*2)])|(SPI_FLASH_BUF[577+(i*2)]<<8);
00005a  4b2e              LDR      r3,|L16.276|
00005c  2000              MOVS     r0,#0                 ;546
00005e  bf00              NOP      
                  |L16.96|
000060  eb020640          ADD      r6,r2,r0,LSL #1
000064  f8b66240          LDRH     r6,[r6,#0x240]
000068  f8236010          STRH     r6,[r3,r0,LSL #1]
00006c  1c40              ADDS     r0,r0,#1
00006e  b280              UXTH     r0,r0                 ;546
000070  2860              CMP      r0,#0x60              ;546
000072  d3f5              BCC      |L16.96|
                  |L16.116|
;;;549    
;;;550            }
;;;551        }
;;;552        
;;;553        if(old_altiude_div_cnt <= 96)
000074  4e28              LDR      r6,|L16.280|
000076  7830              LDRB     r0,[r6,#0]  ; old_altiude_div_cnt
000078  2860              CMP      r0,#0x60
00007a  d80f              BHI      |L16.156|
;;;554        {
;;;555            for(i = 0;i<96;i++)
;;;556            {
;;;557                //Altitude_pass[i] = (SPI_FLASH_BUF[768+(i*2)])|(SPI_FLASH_BUF[769+(i*2)]<<8);
;;;558               Altitude_pass[i] = ((SPI_FLASH_BUF[768+(i*4)])|(SPI_FLASH_BUF[769+(i*4)]<<8)|(SPI_FLASH_BUF[770+(i*4)]<<16)|(SPI_FLASH_BUF[771+(i*4)]<<24));
00007c  4f27              LDR      r7,|L16.284|
00007e  2000              MOVS     r0,#0                 ;555
                  |L16.128|
000080  eb020380          ADD      r3,r2,r0,LSL #2
000084  f893c303          LDRB     r12,[r3,#0x303]
000088  f8d33300          LDR      r3,[r3,#0x300]
00008c  f36c631f          BFI      r3,r12,#24,#8
000090  f8473020          STR      r3,[r7,r0,LSL #2]
000094  1c40              ADDS     r0,r0,#1
000096  b280              UXTH     r0,r0                 ;555
000098  2860              CMP      r0,#0x60              ;555
00009a  d3f1              BCC      |L16.128|
                  |L16.156|
;;;559            }
;;;560    
;;;561    
;;;562        }
;;;563    
;;;564    
;;;565        most_temperature = Max_arry(temperature_pass,old_div_cnt);
00009c  481a              LDR      r0,|L16.264|
00009e  f7fffffe          BL       Max_arry
0000a2  491f              LDR      r1,|L16.288|
0000a4  8008              STRH     r0,[r1,#0]
;;;566        lest_temperature = Min_arry(temperature_pass,old_div_cnt);
0000a6  7821              LDRB     r1,[r4,#0]  ; old_div_cnt
0000a8  4817              LDR      r0,|L16.264|
0000aa  f7fffffe          BL       Min_arry
0000ae  491d              LDR      r1,|L16.292|
0000b0  8008              STRH     r0,[r1,#0]
;;;567    
;;;568        most_pressure= Max_arry32(pressure_pass,old_div_cnt);
0000b2  7821              LDRB     r1,[r4,#0]  ; old_div_cnt
0000b4  4815              LDR      r0,|L16.268|
0000b6  f7fffffe          BL       Max_arry32
0000ba  491b              LDR      r1,|L16.296|
;;;569        lest_pressure= Min_arry32(pressure_pass,old_div_cnt);	
0000bc  6008              STR      r0,[r1,#0]  ; most_pressure
0000be  7821              LDRB     r1,[r4,#0]  ; old_div_cnt
0000c0  4812              LDR      r0,|L16.268|
0000c2  f7fffffe          BL       Min_arry32
0000c6  4919              LDR      r1,|L16.300|
;;;570    
;;;571        most_Altitude= Max_arry32(Altitude_pass,old_altiude_div_cnt);
0000c8  6008              STR      r0,[r1,#0]  ; lest_pressure
0000ca  7831              LDRB     r1,[r6,#0]  ; old_altiude_div_cnt
0000cc  4813              LDR      r0,|L16.284|
0000ce  f7fffffe          BL       Max_arry32
0000d2  4917              LDR      r1,|L16.304|
;;;572        lest_Altitude = Min_arry32(Altitude_pass,old_altiude_div_cnt);
0000d4  6008              STR      r0,[r1,#0]  ; most_Altitude
0000d6  7831              LDRB     r1,[r6,#0]  ; old_altiude_div_cnt
0000d8  4810              LDR      r0,|L16.284|
0000da  f7fffffe          BL       Min_arry32
0000de  4915              LDR      r1,|L16.308|
;;;573    
;;;574        most_speed= Max_arry(speed_pass,old_spped_div_cnt);
0000e0  6008              STR      r0,[r1,#0]  ; lest_Altitude
0000e2  7829              LDRB     r1,[r5,#0]  ; old_spped_div_cnt
0000e4  480b              LDR      r0,|L16.276|
0000e6  f7fffffe          BL       Max_arry
0000ea  4913              LDR      r1,|L16.312|
0000ec  8008              STRH     r0,[r1,#0]
;;;575        lest_speed = Min_arry(speed_pass,old_spped_div_cnt);
0000ee  7829              LDRB     r1,[r5,#0]  ; old_spped_div_cnt
0000f0  4808              LDR      r0,|L16.276|
0000f2  f7fffffe          BL       Min_arry
0000f6  4911              LDR      r1,|L16.316|
0000f8  8008              STRH     r0,[r1,#0]
;;;576    
;;;577    }
0000fa  f20d4d84          ADD      sp,sp,#0x484
0000fe  bdf0              POP      {r4-r7,pc}
;;;578    
                          ENDP

                  |L16.256|
                          DCD      0x00fff000
                  |L16.260|
                          DCD      old_div_cnt
                  |L16.264|
                          DCD      temperature_pass
                  |L16.268|
                          DCD      pressure_pass
                  |L16.272|
                          DCD      old_spped_div_cnt
                  |L16.276|
                          DCD      speed_pass
                  |L16.280|
                          DCD      old_altiude_div_cnt
                  |L16.284|
                          DCD      Altitude_pass
                  |L16.288|
                          DCD      most_temperature
                  |L16.292|
                          DCD      lest_temperature
                  |L16.296|
                          DCD      most_pressure
                  |L16.300|
                          DCD      lest_pressure
                  |L16.304|
                          DCD      most_Altitude
                  |L16.308|
                          DCD      lest_Altitude
                  |L16.312|
                          DCD      most_speed
                  |L16.316|
                          DCD      lest_speed

;*** Start embedded assembler ***

#line 1 "..\\src\\HARDWARE\\FLASH\\flash.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_flash_c_34032acc____REV16|
#line 114 "..\\..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___7_flash_c_34032acc____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_flash_c_34032acc____REVSH|
#line 128
|__asm___7_flash_c_34032acc____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
