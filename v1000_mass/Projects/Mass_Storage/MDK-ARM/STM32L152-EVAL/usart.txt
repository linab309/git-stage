; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm32l152-eval\usart.o --asm_dir=.\STM32L152-EVAL\ --list_dir=.\STM32L152-EVAL\ --depend=.\stm32l152-eval\usart.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32L1xx\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32L1xx_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM32L152_EVAL -I..\src\user -I..\src\user\include -I..\src\SYSTEM\delay -I..\src\SYSTEM\sys -I..\src\SYSTEM\usart -I..\src\HARDWARE\ADC -I..\src\HARDWARE\BMP -I..\src\HARDWARE\DMA -I..\src\HARDWARE\FLASH -I..\src\HARDWARE\GPS -I..\src\HARDWARE\KEY -I..\src\HARDWARE\PWM -I..\src\HARDWARE\RTC -I..\src\HARDWARE\SPI -I..\src\HARDWARE\USART2 -I..\src\HARDWARE\TIMER -I..\src\EX -I..\src\USMART -I..\..\..\Libraries\CMSIS\Include -I..\src\ff11a\src -I..\src\ff11a\src\option -I..\src\HARDWARE\LED -I..\src\HARDWARE\OLED -I..\src\ff11a\src -I..\src\ff11a\src\option -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.1.0\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32L1xx -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32L1XX_MD -DUSE_STM32L152_EVAL ..\src\SYSTEM\usart\usart.c]
                          THUMB

                          AREA ||i._sys_exit||, CODE, READONLY, ALIGN=1

                  _sys_exit PROC
;;;49     //定义_sys_exit()以避免使用半主机模式
;;;50     _sys_exit(int x)
000000  4770              BX       lr
;;;51     {
;;;52     	x = x;
;;;53     }
;;;54     //重定义fputc函数
                          ENDP


                          AREA ||i.fputc||, CODE, READONLY, ALIGN=2

                  fputc PROC
;;;54     //重定义fputc函数
;;;55     int fputc(int ch, FILE *f)
000000  4904              LDR      r1,|L2.20|
                  |L2.2|
;;;56     {
;;;57     
;;;58     #if 1
;;;59     	while((USART1->SR&0X40)==0);//循环发送,直到发送完毕
000002  880a              LDRH     r2,[r1,#0]
000004  0652              LSLS     r2,r2,#25
000006  d5fc              BPL      |L2.2|
;;;60     	USART1->DR = (u8) ch;
000008  4a02              LDR      r2,|L2.20|
00000a  b2c1              UXTB     r1,r0
00000c  1d12              ADDS     r2,r2,#4
00000e  8011              STRH     r1,[r2,#0]
;;;61     	return ch;
;;;62     #else
;;;63     	USART_To_USB_Send_Data(ch);
;;;64     #endif
;;;65     //	return ch;
;;;66     }
000010  4770              BX       lr
;;;67     
                          ENDP

000012  0000              DCW      0x0000
                  |L2.20|
                          DCD      0x40013800

                          AREA ||i.uart_init||, CODE, READONLY, ALIGN=2

                  uart_init PROC
;;;165    
;;;166    void uart_init(u32 bound){
000000  b5f0              PUSH     {r4-r7,lr}
;;;167        //GPIO端口设置
;;;168    GPIO_InitTypeDef GPIO_InitStructure;
;;;169    USART_InitTypeDef USART_InitStructure;
;;;170    NVIC_InitTypeDef NVIC_InitStructure;
;;;171    
;;;172    /* Enable GPIO clock */
;;;173    RCC_AHBPeriphClockCmd(USARTx_TX_GPIO_CLK | USARTx_RX_GPIO_CLK, ENABLE);
000002  2101              MOVS     r1,#1
000004  b087              SUB      sp,sp,#0x1c           ;166
000006  4608              MOV      r0,r1
000008  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;174    
;;;175    
;;;176    
;;;177    /* Configure USART Tx and Rx as alternate function push-pull */
;;;178    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
00000c  2002              MOVS     r0,#2
00000e  f88d0004          STRB     r0,[sp,#4]
;;;179    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_40MHz;
000012  2503              MOVS     r5,#3
000014  f88d5005          STRB     r5,[sp,#5]
;;;180    GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
000018  2400              MOVS     r4,#0
;;;181    GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
;;;182    GPIO_InitStructure.GPIO_Pin = USARTx_TX_PIN;
00001a  0200              LSLS     r0,r0,#8
;;;183    GPIO_Init(USARTx_TX_GPIO_PORT, &GPIO_InitStructure);
00001c  4f23              LDR      r7,|L3.172|
00001e  f88d4006          STRB     r4,[sp,#6]            ;180
000022  2601              MOVS     r6,#1                 ;181
000024  9000              STR      r0,[sp,#0]
000026  f88d6007          STRB     r6,[sp,#7]            ;181
00002a  4669              MOV      r1,sp
00002c  4638              MOV      r0,r7
00002e  f7fffffe          BL       GPIO_Init
;;;184    
;;;185    GPIO_InitStructure.GPIO_Pin = USARTx_RX_PIN;
000032  02b0              LSLS     r0,r6,#10
;;;186    //GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
;;;187    GPIO_Init(USARTx_RX_GPIO_PORT, &GPIO_InitStructure);
000034  9000              STR      r0,[sp,#0]
000036  4669              MOV      r1,sp
000038  4638              MOV      r0,r7
00003a  f7fffffe          BL       GPIO_Init
;;;188    
;;;189    
;;;190    /* Enable USART clock */
;;;191    USARTx_APBPERIPHCLOCK(USARTx_CLK, ENABLE);
00003e  2101              MOVS     r1,#1
000040  0388              LSLS     r0,r1,#14
000042  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;192    
;;;193    /* Connect PXx to USARTx_Tx */
;;;194    GPIO_PinAFConfig(USARTx_TX_GPIO_PORT, USARTx_TX_SOURCE, USARTx_TX_AF);
000046  2207              MOVS     r2,#7
000048  2109              MOVS     r1,#9
00004a  4638              MOV      r0,r7
00004c  f7fffffe          BL       GPIO_PinAFConfig
;;;195    
;;;196    /* Connect PXx to USARTx_Rx */
;;;197    GPIO_PinAFConfig(USARTx_RX_GPIO_PORT, USARTx_RX_SOURCE, USARTx_RX_AF);
000050  2207              MOVS     r2,#7
000052  210a              MOVS     r1,#0xa
000054  4638              MOV      r0,r7
000056  f7fffffe          BL       GPIO_PinAFConfig
;;;198    
;;;199    /* USARTx configuration ----------------------------------------------------*/
;;;200    /* USARTx configured as follow:
;;;201    - BaudRate = 230400 baud
;;;202    
;;;203    - Word Length = 8 Bits
;;;204    - One Stop Bit
;;;205    - No parity
;;;206    - Hardware flow control disabled (RTS and CTS signals)
;;;207    - Receive and transmit enabled
;;;208    */
;;;209    USART_InitStructure.USART_BaudRate = 115200;
00005a  f44f30e1          MOV      r0,#0x1c200
;;;210    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
00005e  f8ad400c          STRH     r4,[sp,#0xc]
000062  9002              STR      r0,[sp,#8]
;;;211    USART_InitStructure.USART_StopBits = USART_StopBits_1;
000064  f8ad400e          STRH     r4,[sp,#0xe]
;;;212    USART_InitStructure.USART_Parity = USART_Parity_No;
000068  f8ad4010          STRH     r4,[sp,#0x10]
;;;213    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
00006c  f8ad4014          STRH     r4,[sp,#0x14]
;;;214    #if EN_USART1_RX   //如果使能了接收
;;;215    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
;;;216    #else
;;;217    	USART_InitStructure.USART_Mode = USART_Mode_Tx;
000070  2008              MOVS     r0,#8
;;;218    #endif
;;;219    USART_Init(USARTx, &USART_InitStructure);
000072  4c0f              LDR      r4,|L3.176|
000074  f8ad0012          STRH     r0,[sp,#0x12]         ;217
000078  a902              ADD      r1,sp,#8
00007a  4620              MOV      r0,r4
00007c  f7fffffe          BL       USART_Init
;;;220    
;;;221    /* NVIC configuration */
;;;222    /* Configure the Priority Group to 2 bits */
;;;223    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
000080  f44f60a0          MOV      r0,#0x500
000084  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;224    
;;;225    /* Enable the USARTx Interrupt */
;;;226    NVIC_InitStructure.NVIC_IRQChannel = USARTx_IRQn;
000088  2025              MOVS     r0,#0x25
00008a  f88d0018          STRB     r0,[sp,#0x18]
;;;227    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 3;
00008e  f88d5019          STRB     r5,[sp,#0x19]
;;;228    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;
000092  f88d501a          STRB     r5,[sp,#0x1a]
;;;229    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000096  f88d601b          STRB     r6,[sp,#0x1b]
;;;230    NVIC_Init(&NVIC_InitStructure);
00009a  a806              ADD      r0,sp,#0x18
00009c  f7fffffe          BL       NVIC_Init
;;;231    #if 0//S EN_USART1_RX   //如果使能了接收
;;;232    	USART1->CR1|=1<<8;    //PE中断使能
;;;233    	USART1->CR1|=1<<5;    //接收缓冲区非空中断使能
;;;234    
;;;235    	MY_NVIC_Init(1,3,USART1_IRQn,2);//组2，最低优先级
;;;236    #endif
;;;237    
;;;238    /* Enable USART */
;;;239    USART_Cmd(USARTx, ENABLE);
0000a0  2101              MOVS     r1,#1
0000a2  4620              MOV      r0,r4
0000a4  f7fffffe          BL       USART_Cmd
;;;240    
;;;241    }
0000a8  b007              ADD      sp,sp,#0x1c
0000aa  bdf0              POP      {r4-r7,pc}
;;;242    
                          ENDP

                  |L3.172|
                          DCD      0x40020000
                  |L3.176|
                          DCD      0x40013800

                          AREA ||.data||, DATA, ALIGN=2

                  __stdout
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\src\\SYSTEM\\usart\\usart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_usart_c_9275e5e5____REV16|
#line 114 "..\\..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___7_usart_c_9275e5e5____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_usart_c_9275e5e5____REVSH|
#line 128
|__asm___7_usart_c_9275e5e5____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
