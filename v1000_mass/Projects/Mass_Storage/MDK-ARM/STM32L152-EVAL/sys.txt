; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm32l152-eval\sys.o --asm_dir=.\STM32L152-EVAL\ --list_dir=.\STM32L152-EVAL\ --depend=.\stm32l152-eval\sys.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32L1xx\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32L1xx_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM32L152_EVAL -I..\src\user -I..\src\user\include -I..\src\SYSTEM\delay -I..\src\SYSTEM\sys -I..\src\SYSTEM\usart -I..\src\HARDWARE\ADC -I..\src\HARDWARE\BMP -I..\src\HARDWARE\DMA -I..\src\HARDWARE\FLASH -I..\src\HARDWARE\GPS -I..\src\HARDWARE\KEY -I..\src\HARDWARE\PWM -I..\src\HARDWARE\RTC -I..\src\HARDWARE\SPI -I..\src\HARDWARE\USART2 -I..\src\HARDWARE\TIMER -I..\src\EX -I..\src\USMART -I..\..\..\Libraries\CMSIS\Include -I..\src\ff11a\src -I..\src\ff11a\src\option -I..\src\HARDWARE\LED -I..\src\HARDWARE\OLED -I..\src\ff11a\src -I..\src\ff11a\src\option -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.1.0\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32L1xx -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32L1XX_MD -DUSE_STM32L152_EVAL ..\src\SYSTEM\sys\sys.c]
                          THUMB

                          AREA ||i.Choose_power_mode||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  Choose_power_mode PROC
;;;701    
;;;702    void Choose_power_mode(u8 Mcu_State)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;703    {
000004  4606              MOV      r6,r0
;;;704    //  GPIO_InitTypeDef GPIO_InitStructure;
;;;705    //  u32 i;
;;;706        RCC_TypeDef SavRCC;
;;;707        extern u8 key_press_cnt ;
;;;708        v1000_debug("Mcu_State: %d \r\n ",Mcu_State);
000006  4601              MOV      r1,r0
000008  b08f              SUB      sp,sp,#0x3c           ;703
00000a  a095              ADR      r0,|L1.608|
00000c  f7fffffe          BL       __2printf
;;;709        switch(Mcu_State)
;;;710    	{
;;;711    	    case MCU_RUN_USB:
;;;712    
;;;713        		PWR_EnterLowPowerRunMode(DISABLE);
;;;714        		while(PWR_GetFlagStatus(PWR_FLAG_REGLP) != RESET) ;
;;;715        		PWR_VoltageScalingConfig(PWR_VoltageScaling_Range1);
;;;716        		while (PWR_GetFlagStatus(PWR_FLAG_VOS) != RESET) ;
;;;717    
;;;718        		PWR_EnterLowPowerRunMode(DISABLE);
;;;719    
;;;720        		/* Disable Ultra low power mode */
;;;721        		PWR_UltraLowPowerCmd(DISABLE);
;;;722    
;;;723        		/* Disable FLASH during SLeep LP */
;;;724        		FLASH_SLEEPPowerDownCmd(DISABLE);
;;;725        		/* Clear Wake Up flag */
;;;726        		PWR_ClearFlag(PWR_FLAG_WU);
;;;727        		/* Enable PVD */
;;;728        		PWR_PVDCmd(ENABLE);
;;;729        		SystemInit();
;;;730        //        Leave_LowPowerMode();
;;;731                //PowerOn();
;;;732        		RTC_Config();
;;;733        		SystemCoreClock =32000000 ;
000010  4d98              LDR      r5,|L1.628|
;;;734        		Button_key_perss(0);
;;;735    		break;
;;;736    
;;;737        /* Run mode : Measurement Measurement performed with MSI 4 MHz without RTC*/
;;;738          case MCU_RUN:
;;;739    
;;;740    
;;;741        		PWR_EnterLowPowerRunMode(DISABLE);
;;;742        		while(PWR_GetFlagStatus(PWR_FLAG_REGLP) != RESET) ;
;;;743    
;;;744        		PWR_VoltageScalingConfig(PWR_VoltageScaling_Range1);
;;;745        		while (PWR_GetFlagStatus(PWR_FLAG_VOS) != RESET) ;
;;;746    
;;;747        		SetHSICLK();
;;;748        		PWR_EnterLowPowerRunMode(DISABLE);
;;;749    
;;;750        		/* Disable Ultra low power mode */
;;;751        		PWR_UltraLowPowerCmd(DISABLE);
;;;752    
;;;753        		/* Disable FLASH during SLeep LP */
;;;754        		FLASH_SLEEPPowerDownCmd(DISABLE);
;;;755        		/* Clear Wake Up flag */
;;;756        		PWR_ClearFlag(PWR_FLAG_WU);
;;;757        		/* Enable PVD */
;;;758        		PWR_PVDCmd(ENABLE);
;;;759        //           Enter_LowPowerMode();
;;;760        		delay_init(16);	     //ÑÓÊ±³õÊ¼»//
;;;761        		Timerx_Init(99,1599);//10Khz  ¼ÆÊý4999 --- 500ms
;;;762    #if EN_USART1
;;;763        		uart_init(115200);
;;;764    #endif
;;;765                
;;;766             USART2_Init(16,38400);  //³õÊ¼»¯´®¿Ú2
;;;767                
;;;768        		RTC_Config();
;;;769        		SPI_Flash_Init();   //SPI FLASH ³õÊ¼»¯
;;;770    
;;;771        		//SPIx_SetSpeed(SPI_SPEED_2);
;;;772    #if EN_USART1_RX
;;;773        		usmart_dev.init(16); 	//³õÊ¼»¯USMART
;;;774    #endif
;;;775    
;;;776    
;;;777                if(system_power_flag == 3)
000012  4c99              LDR      r4,|L1.632|
000014  f44f6700          MOV      r7,#0x800             ;715
000018  f240683f          MOV      r8,#0x63f             ;761
00001c  f44f39e1          MOV      r9,#0x1c200           ;763
000020  b37e              CBZ      r6,|L1.130|
000022  2e02              CMP      r6,#2                 ;709
000024  d073              BEQ      |L1.270|
000026  2e06              CMP      r6,#6                 ;709
000028  d070              BEQ      |L1.268|
00002a  2e07              CMP      r6,#7                 ;709
00002c  d126              BNE      |L1.124|
00002e  2000              MOVS     r0,#0                 ;713
000030  f7fffffe          BL       PWR_EnterLowPowerRunMode
                  |L1.52|
000034  2020              MOVS     r0,#0x20              ;714
000036  f7fffffe          BL       PWR_GetFlagStatus
00003a  2800              CMP      r0,#0                 ;714
00003c  d1fa              BNE      |L1.52|
00003e  4638              MOV      r0,r7                 ;715
000040  f7fffffe          BL       PWR_VoltageScalingConfig
                  |L1.68|
000044  2010              MOVS     r0,#0x10              ;716
000046  f7fffffe          BL       PWR_GetFlagStatus
00004a  2800              CMP      r0,#0                 ;716
00004c  d1fa              BNE      |L1.68|
00004e  f7fffffe          BL       PWR_EnterLowPowerRunMode
000052  2000              MOVS     r0,#0                 ;721
000054  f7fffffe          BL       PWR_UltraLowPowerCmd
000058  2000              MOVS     r0,#0                 ;724
00005a  f7fffffe          BL       FLASH_SLEEPPowerDownCmd
00005e  2001              MOVS     r0,#1                 ;726
000060  f7fffffe          BL       PWR_ClearFlag
000064  2001              MOVS     r0,#1                 ;728
000066  f7fffffe          BL       PWR_PVDCmd
00006a  f7fffffe          BL       SystemInit
00006e  f7fffffe          BL       RTC_Config
000072  4882              LDR      r0,|L1.636|
000074  6028              STR      r0,[r5,#0]            ;734  ; SystemCoreClock
000076  2000              MOVS     r0,#0                 ;734
000078  f7fffffe          BL       Button_key_perss
                  |L1.124|
;;;778                {
;;;779                   system_power_flag = 1;
;;;780                   OLED_Display_On();
;;;781                }
;;;782                SystemCoreClock =16000000 ;
;;;783                Button_key_perss(0);
;;;784                ADC_Config();
;;;785        	    break;
;;;786    	case MCU_LP_RUN:
;;;787                /* switch on MSI clock */
;;;788                /* Disable PVD */
;;;789        		Enter_LowPowerMode();
;;;790        		PWR_PVDCmd(DISABLE);
;;;791    
;;;792        		/* Enable The ultra Low Power Mode */
;;;793        		PWR_UltraLowPowerCmd(ENABLE);
;;;794    
;;;795        		SetHSICLKToMSI(RCC_MSIRange_6,0,1) ;
;;;796        		Timerx_Init(99,419);//10Khz  ¼ÆÊý4999 --- 500ms
;;;797        		/* shitch on MSI clock */
;;;798        		//    Config_RCC(&SavRCC);
;;;799        		delay_init(4);
;;;800    #if EN_USART1
;;;801        		uart_init(115200);
;;;802    #endif
;;;803        		SPI_Flash_Init();   //SPI FLASH ³õÊ¼»¯
;;;804        		OLED_Init();
;;;805        		 RTC_Config();
;;;806        		SystemCoreClock =4194000 ;
;;;807        //		PWM_Init();
;;;808        		Button_key_perss(0);
;;;809        		//SPIx_SetSpeed(SPI_SPEED_2);
;;;810    #if EN_USART1_RX
;;;811        		usmart_dev.init(4); 	//³õÊ¼»¯USMART
;;;812    #endif
;;;813                ADC_Config();
;;;814                PWR_EnterLowPowerRunMode(ENABLE);
;;;815                while(PWR_GetFlagStatus(PWR_FLAG_REGLP) == RESET) ;
;;;816             
;;;817            break;
;;;818    
;;;819      case MCU_STBY:
;;;820            key_press_cnt = 0;
;;;821            Button_key_perss(0);
;;;822    
;;;823            if(system_power_flag == SYSTEM_POWER_STANBY)
;;;824            ;
;;;825            else
;;;826            {
;;;827                system_power_flag = SYSTEM_POWER_STANBY;
;;;828                di_and_flash_empet(3);
;;;829            }
;;;830            
;;;831            is_recoreding();/*ÊÇ·ñÔÚ¼ÇÂ¼¹ì¼£*/
;;;832            GPS_power_ctrl(0);
;;;833            OLED_Display_Off();
;;;834            /* Disable PVD */
;;;835    
;;;836            SPI_Flash_PowerDown();
;;;837            GPIO_LowPower_Config();
;;;838            PWR_PVDCmd(DISABLE);
;;;839            /* Enable Ultra low power mode */
;;;840            PWR_UltraLowPowerCmd(ENABLE);
;;;841            Config_RCC(&SavRCC);
;;;842            SysTick->CTRL = 0;
;;;843            /* Swith in MSI 32KHz */
;;;844            SetHSICLKToMSI(RCC_MSIRange_0,1,1) ;
;;;845            KEY_Init();
;;;846            PWR_WakeUpPinCmd(PWR_WakeUpPin_2,ENABLE);/*wake up pin 2--- pin13*/
;;;847            PWR_WakeUpPinCmd(PWR_WakeUpPin_1,ENABLE);/*wake up pin 2--- pina0*/
;;;848            PWR_EnterSTANDBYMode();
;;;849            SetHSICLK();
;;;850    
;;;851            PWR_VoltageScalingConfig(PWR_VoltageScaling_Range1);
;;;852            /* Wait Until the Voltage Regulator is ready */
;;;853            while (PWR_GetFlagStatus(PWR_FLAG_VOS) != RESET) ;
;;;854            Leave_LowPowerMode();
;;;855    
;;;856            RCC->AHBENR = SavRCC.AHBENR;
;;;857            /* To restore RCC registers */
;;;858            RCC->APB1ENR = SavRCC.APB1ENR;
;;;859            RCC->APB2ENR = SavRCC.APB2ENR;
;;;860            RCC->AHBLPENR = SavRCC.AHBLPENR;
;;;861            RCC->APB1LPENR = SavRCC.APB1LPENR;
;;;862            RCC->APB2LPENR = SavRCC.APB2LPENR;
;;;863    
;;;864            /* Need to reinit RCC for LCD*/
;;;865    
;;;866            Stm32_Clock_Init(9);	//ÏµÍ³Ê±ÖÓÉèÖÃ
;;;867            delay_init(16);
;;;868            PWR_EnterLowPowerRunMode(DISABLE);
;;;869            /* Disable Ultra low power mode */
;;;870            PWR_UltraLowPowerCmd(DISABLE);
;;;871            /* Disable FLASH during SLeep LP */
;;;872            FLASH_SLEEPPowerDownCmd(DISABLE);
;;;873    
;;;874            //  Restore_GPIO_Config();
;;;875            /* Clear Wake Up flag */
;;;876            PWR_ClearFlag(PWR_FLAG_WU);
;;;877            /* Enable PVD */
;;;878            PWR_PVDCmd(ENABLE);
;;;879            Restore_GPIO_Config();
;;;880            LED_Init();
;;;881            Timerx_Init(99,1599);//10Khz  ¼ÆÊý4999 --- 500ms
;;;882    
;;;883    #if EN_USART1
;;;884            uart_init(115200);
;;;885    #endif
;;;886            //   system_power_flag = 1;
;;;887            SPI_Flash_WAKEUP();
;;;888            RTC_Config();
;;;889            break;
;;;890    	}
;;;891    }
00007c  b00f              ADD      sp,sp,#0x3c
00007e  e8bd83f0          POP      {r4-r9,pc}
                  |L1.130|
000082  e7ff              B        |L1.132|
                  |L1.132|
000084  2000              MOVS     r0,#0                 ;741
000086  f7fffffe          BL       PWR_EnterLowPowerRunMode
                  |L1.138|
00008a  2020              MOVS     r0,#0x20              ;742
00008c  f7fffffe          BL       PWR_GetFlagStatus
000090  2800              CMP      r0,#0                 ;742
000092  d1fa              BNE      |L1.138|
000094  4638              MOV      r0,r7                 ;744
000096  f7fffffe          BL       PWR_VoltageScalingConfig
                  |L1.154|
00009a  2010              MOVS     r0,#0x10              ;745
00009c  f7fffffe          BL       PWR_GetFlagStatus
0000a0  2800              CMP      r0,#0                 ;745
0000a2  d1fa              BNE      |L1.154|
0000a4  f7fffffe          BL       SetHSICLK
0000a8  2000              MOVS     r0,#0                 ;748
0000aa  f7fffffe          BL       PWR_EnterLowPowerRunMode
0000ae  2000              MOVS     r0,#0                 ;751
0000b0  f7fffffe          BL       PWR_UltraLowPowerCmd
0000b4  2000              MOVS     r0,#0                 ;754
0000b6  f7fffffe          BL       FLASH_SLEEPPowerDownCmd
0000ba  2001              MOVS     r0,#1                 ;756
0000bc  f7fffffe          BL       PWR_ClearFlag
0000c0  2001              MOVS     r0,#1                 ;758
0000c2  f7fffffe          BL       PWR_PVDCmd
0000c6  2010              MOVS     r0,#0x10              ;760
0000c8  f7fffffe          BL       delay_init
0000cc  4641              MOV      r1,r8                 ;761
0000ce  2063              MOVS     r0,#0x63              ;761
0000d0  f7fffffe          BL       Timerx_Init
0000d4  4648              MOV      r0,r9                 ;763
0000d6  f7fffffe          BL       uart_init
0000da  f44f4116          MOV      r1,#0x9600            ;766
0000de  2010              MOVS     r0,#0x10              ;766
0000e0  f7fffffe          BL       USART2_Init
0000e4  f7fffffe          BL       RTC_Config
0000e8  f7fffffe          BL       SPI_Flash_Init
0000ec  7820              LDRB     r0,[r4,#0]            ;777  ; system_power_flag
0000ee  2803              CMP      r0,#3                 ;777
0000f0  d103              BNE      |L1.250|
0000f2  2001              MOVS     r0,#1                 ;779
0000f4  7020              STRB     r0,[r4,#0]            ;779
0000f6  f7fffffe          BL       OLED_Display_On
                  |L1.250|
0000fa  4861              LDR      r0,|L1.640|
0000fc  6028              STR      r0,[r5,#0]            ;783  ; SystemCoreClock
0000fe  2000              MOVS     r0,#0                 ;783
000100  f7fffffe          BL       Button_key_perss
000104  f7fffffe          BL       ADC_Config
000108  e7b8              B        |L1.124|
00010a  e000              B        |L1.270|
                  |L1.268|
00010c  e02e              B        |L1.364|
                  |L1.270|
00010e  f7fffffe          BL       Enter_LowPowerMode
000112  2000              MOVS     r0,#0                 ;790
000114  f7fffffe          BL       PWR_PVDCmd
000118  2001              MOVS     r0,#1                 ;793
00011a  f7fffffe          BL       PWR_UltraLowPowerCmd
00011e  2201              MOVS     r2,#1                 ;795
000120  2100              MOVS     r1,#0                 ;795
000122  f44f4040          MOV      r0,#0xc000            ;795
000126  f7fffffe          BL       SetHSICLKToMSI
00012a  f24011a3          MOV      r1,#0x1a3             ;796
00012e  2063              MOVS     r0,#0x63              ;796
000130  f7fffffe          BL       Timerx_Init
000134  2004              MOVS     r0,#4                 ;799
000136  f7fffffe          BL       delay_init
00013a  4648              MOV      r0,r9                 ;801
00013c  f7fffffe          BL       uart_init
000140  f7fffffe          BL       SPI_Flash_Init
000144  f7fffffe          BL       OLED_Init
000148  f7fffffe          BL       RTC_Config
00014c  484d              LDR      r0,|L1.644|
00014e  6028              STR      r0,[r5,#0]            ;808  ; SystemCoreClock
000150  2000              MOVS     r0,#0                 ;808
000152  f7fffffe          BL       Button_key_perss
000156  f7fffffe          BL       ADC_Config
00015a  2001              MOVS     r0,#1                 ;814
00015c  f7fffffe          BL       PWR_EnterLowPowerRunMode
                  |L1.352|
000160  2020              MOVS     r0,#0x20              ;815
000162  f7fffffe          BL       PWR_GetFlagStatus
000166  2800              CMP      r0,#0                 ;815
000168  d0fa              BEQ      |L1.352|
00016a  e787              B        |L1.124|
                  |L1.364|
00016c  4846              LDR      r0,|L1.648|
00016e  2500              MOVS     r5,#0                 ;820
000170  7005              STRB     r5,[r0,#0]            ;820
000172  4628              MOV      r0,r5                 ;821
000174  f7fffffe          BL       Button_key_perss
000178  7820              LDRB     r0,[r4,#0]            ;823  ; system_power_flag
00017a  b118              CBZ      r0,|L1.388|
00017c  7025              STRB     r5,[r4,#0]            ;827
00017e  2003              MOVS     r0,#3                 ;828
000180  f7fffffe          BL       di_and_flash_empet
                  |L1.388|
000184  f7fffffe          BL       is_recoreding
000188  2000              MOVS     r0,#0                 ;832
00018a  f7fffffe          BL       GPS_power_ctrl
00018e  f7fffffe          BL       OLED_Display_Off
000192  f7fffffe          BL       SPI_Flash_PowerDown
000196  f7fffffe          BL       GPIO_LowPower_Config
00019a  2000              MOVS     r0,#0                 ;838
00019c  f7fffffe          BL       PWR_PVDCmd
0001a0  2001              MOVS     r0,#1                 ;840
0001a2  f7fffffe          BL       PWR_UltraLowPowerCmd
0001a6  4668              MOV      r0,sp                 ;841
0001a8  f7fffffe          BL       Config_RCC
0001ac  f04f20e0          MOV      r0,#0xe000e000        ;842
0001b0  6105              STR      r5,[r0,#0x10]         ;842
0001b2  2201              MOVS     r2,#1                 ;844
0001b4  4611              MOV      r1,r2                 ;844
0001b6  2000              MOVS     r0,#0                 ;844
0001b8  f7fffffe          BL       SetHSICLKToMSI
0001bc  f7fffffe          BL       KEY_Init
0001c0  2101              MOVS     r1,#1                 ;846
0001c2  2004              MOVS     r0,#4                 ;846
0001c4  f7fffffe          BL       PWR_WakeUpPinCmd
0001c8  2101              MOVS     r1,#1                 ;847
0001ca  2000              MOVS     r0,#0                 ;847
0001cc  f7fffffe          BL       PWR_WakeUpPinCmd
0001d0  f7fffffe          BL       PWR_EnterSTANDBYMode
0001d4  f7fffffe          BL       SetHSICLK
0001d8  4638              MOV      r0,r7                 ;851
0001da  f7fffffe          BL       PWR_VoltageScalingConfig
                  |L1.478|
0001de  2010              MOVS     r0,#0x10              ;853
0001e0  f7fffffe          BL       PWR_GetFlagStatus
0001e4  2800              CMP      r0,#0                 ;853
0001e6  d1fa              BNE      |L1.478|
0001e8  f7fffffe          BL       Leave_LowPowerMode
0001ec  9807              LDR      r0,[sp,#0x1c]         ;856
0001ee  4927              LDR      r1,|L1.652|
0001f0  6008              STR      r0,[r1,#0]            ;856
0001f2  9809              LDR      r0,[sp,#0x24]         ;858
0001f4  4925              LDR      r1,|L1.652|
0001f6  3108              ADDS     r1,r1,#8              ;858
0001f8  6008              STR      r0,[r1,#0]            ;858
0001fa  9808              LDR      r0,[sp,#0x20]         ;859
0001fc  1f09              SUBS     r1,r1,#4              ;859
0001fe  6008              STR      r0,[r1,#0]            ;859
000200  990a              LDR      r1,[sp,#0x28]         ;860
000202  4822              LDR      r0,|L1.652|
000204  300c              ADDS     r0,r0,#0xc            ;860
000206  6001              STR      r1,[r0,#0]            ;860
000208  980c              LDR      r0,[sp,#0x30]         ;861
00020a  4920              LDR      r1,|L1.652|
00020c  3114              ADDS     r1,r1,#0x14           ;861
00020e  6008              STR      r0,[r1,#0]            ;861
000210  980b              LDR      r0,[sp,#0x2c]         ;862
000212  1f09              SUBS     r1,r1,#4              ;862
000214  6008              STR      r0,[r1,#0]            ;862
000216  2009              MOVS     r0,#9                 ;866
000218  f7fffffe          BL       Stm32_Clock_Init
00021c  2010              MOVS     r0,#0x10              ;867
00021e  f7fffffe          BL       delay_init
000222  2000              MOVS     r0,#0                 ;868
000224  f7fffffe          BL       PWR_EnterLowPowerRunMode
000228  2000              MOVS     r0,#0                 ;870
00022a  f7fffffe          BL       PWR_UltraLowPowerCmd
00022e  2000              MOVS     r0,#0                 ;872
000230  f7fffffe          BL       FLASH_SLEEPPowerDownCmd
000234  2001              MOVS     r0,#1                 ;876
000236  f7fffffe          BL       PWR_ClearFlag
00023a  2001              MOVS     r0,#1                 ;878
00023c  f7fffffe          BL       PWR_PVDCmd
000240  f7fffffe          BL       Restore_GPIO_Config
000244  f7fffffe          BL       LED_Init
000248  4641              MOV      r1,r8                 ;881
00024a  2063              MOVS     r0,#0x63              ;881
00024c  f7fffffe          BL       Timerx_Init
000250  4648              MOV      r0,r9                 ;884
000252  f7fffffe          BL       uart_init
000256  f7fffffe          BL       SPI_Flash_WAKEUP
00025a  f7fffffe          BL       RTC_Config
00025e  e70d              B        |L1.124|
;;;892    
                          ENDP

                  |L1.608|
000260  4d63755f          DCB      "Mcu_State: %d \r\n ",0
000264  53746174
000268  653a2025
00026c  64200d0a
000270  2000    
000272  00                DCB      0
000273  00                DCB      0
                  |L1.628|
                          DCD      SystemCoreClock
                  |L1.632|
                          DCD      system_power_flag
                  |L1.636|
                          DCD      0x01e84800
                  |L1.640|
                          DCD      0x00f42400
                  |L1.644|
                          DCD      0x003ffed0
                  |L1.648|
                          DCD      key_press_cnt
                  |L1.652|
                          DCD      0x4002381c

                          AREA ||i.Config_RCC||, CODE, READONLY, ALIGN=2

                  Config_RCC PROC
;;;639      */
;;;640    void Config_RCC(RCC_TypeDef *sav_RCC)
000000  b530              PUSH     {r4,r5,lr}
;;;641    {
;;;642      /* Save the RCC configuration registers */
;;;643      sav_RCC->AHBENR   = RCC->AHBENR;
000002  490e              LDR      r1,|L2.60|
000004  680a              LDR      r2,[r1,#0]
000006  61c2              STR      r2,[r0,#0x1c]
;;;644      sav_RCC->APB1ENR  = RCC->APB1ENR;
000008  4b0c              LDR      r3,|L2.60|
00000a  3308              ADDS     r3,r3,#8
00000c  681a              LDR      r2,[r3,#0]
00000e  6242              STR      r2,[r0,#0x24]
;;;645      sav_RCC->APB2ENR  = RCC->APB2ENR;
000010  1d0c              ADDS     r4,r1,#4
000012  6822              LDR      r2,[r4,#0]
000014  6202              STR      r2,[r0,#0x20]
;;;646      sav_RCC->AHBLPENR   = RCC->AHBLPENR;
000016  1d1a              ADDS     r2,r3,#4
000018  6815              LDR      r5,[r2,#0]
00001a  6285              STR      r5,[r0,#0x28]
;;;647      sav_RCC->APB1LPENR  = RCC->APB1LPENR;
00001c  4d07              LDR      r5,|L2.60|
00001e  3514              ADDS     r5,r5,#0x14
000020  682d              LDR      r5,[r5,#0]
000022  6305              STR      r5,[r0,#0x30]
;;;648      sav_RCC->APB2LPENR  = RCC->APB2LPENR;
000024  1d15              ADDS     r5,r2,#4
000026  682d              LDR      r5,[r5,#0]
000028  62c5              STR      r5,[r0,#0x2c]
;;;649    
;;;650      /* Set low power configuration */
;;;651      RCC->AHBENR = 0x04; // Ports A and C enable
00002a  2004              MOVS     r0,#4
00002c  6008              STR      r0,[r1,#0]
;;;652      RCC->AHBLPENR = 0x04;
00002e  6010              STR      r0,[r2,#0]
;;;653      RCC->APB1ENR =  RCC_APB1ENR_PWREN;     // PWR management enable
000030  0680              LSLS     r0,r0,#26
000032  6018              STR      r0,[r3,#0]
;;;654      RCC->APB2ENR = 0;
000034  2000              MOVS     r0,#0
000036  6020              STR      r0,[r4,#0]
;;;655    
;;;656    }
000038  bd30              POP      {r4,r5,pc}
;;;657    
                          ENDP

00003a  0000              DCW      0x0000
                  |L2.60|
                          DCD      0x4002381c

                          AREA ||i.Ex_NVIC_Config||, CODE, READONLY, ALIGN=2

                  Ex_NVIC_Config PROC
;;;100    //´ý²âÊÔ...
;;;101    void Ex_NVIC_Config(u8 GPIOx,u8 BITx,u8 TRIM)
000000  b570              PUSH     {r4-r6,lr}
;;;102    {
;;;103    	u8 EXTADDR;
;;;104    	u8 EXTOFFSET;
;;;105    	EXTADDR=BITx/4;//µÃµ½ÖÐ¶Ï¼Ä´æÆ÷×éµÄ±àºÅ
;;;106    	EXTOFFSET=(BITx%4)*4;
;;;107    
;;;108    	RCC->APB2ENR|=0x01;//Ê¹ÄÜio¸´ÓÃÊ±ÖÓ
000002  4d14              LDR      r5,|L3.84|
000004  088b              LSRS     r3,r1,#2              ;105
000006  078c              LSLS     r4,r1,#30             ;106
000008  682e              LDR      r6,[r5,#0]
00000a  0f24              LSRS     r4,r4,#28             ;106
00000c  f0460601          ORR      r6,r6,#1
000010  602e              STR      r6,[r5,#0]
000012  009d              LSLS     r5,r3,#2
;;;109    
;;;110    	SYSCFG->EXTICR[EXTADDR]&=~(0x000F<<EXTOFFSET);//Çå³ýÔ­À´ÉèÖÃ£¡£¡£¡
000014  4b10              LDR      r3,|L3.88|
000016  442b              ADD      r3,r3,r5
000018  689d              LDR      r5,[r3,#8]
00001a  260f              MOVS     r6,#0xf
00001c  40a6              LSLS     r6,r6,r4
00001e  43b5              BICS     r5,r5,r6
000020  609d              STR      r5,[r3,#8]
;;;111    	SYSCFG->EXTICR[EXTADDR]|=GPIOx<<EXTOFFSET;//EXTI.BITxÓ³Éäµ½GPIOx.BITx
000022  689d              LDR      r5,[r3,#8]
000024  40a0              LSLS     r0,r0,r4
000026  4305              ORRS     r5,r5,r0
000028  609d              STR      r5,[r3,#8]
;;;112    
;;;113    	//×Ô¶¯ÉèÖÃ
;;;114    	EXTI->IMR|=1<<BITx;//  ¿ªÆôline BITxÉÏµÄÖÐ¶Ï
00002a  4b0c              LDR      r3,|L3.92|
00002c  681c              LDR      r4,[r3,#0]
00002e  2001              MOVS     r0,#1
000030  4088              LSLS     r0,r0,r1
000032  4304              ORRS     r4,r4,r0
000034  601c              STR      r4,[r3,#0]
;;;115    	//EXTI->EMR|=1<<BITx;//²»ÆÁ±Îline BITxÉÏµÄÊÂ¼þ (Èç¹û²»ÆÁ±ÎÕâ¾ä,ÔÚÓ²¼þÉÏÊÇ¿ÉÒÔµÄ,µ«ÊÇÔÚÈí¼þ·ÂÕæµÄÊ±ºòÎÞ·¨½øÈëÖÐ¶Ï!)
;;;116     	if(TRIM&0x01)EXTI->FTSR|=1<<BITx;//line BITxÉÏÊÂ¼þÏÂ½µÑØ´¥·¢
000036  07d1              LSLS     r1,r2,#31
000038  d004              BEQ      |L3.68|
00003a  4908              LDR      r1,|L3.92|
00003c  310c              ADDS     r1,r1,#0xc
00003e  680b              LDR      r3,[r1,#0]
000040  4303              ORRS     r3,r3,r0
000042  600b              STR      r3,[r1,#0]
                  |L3.68|
;;;117    	if(TRIM&0x02)EXTI->RTSR|=1<<BITx;//line BITxÉÏÊÂ¼þÉÏÉý½µÑØ´¥·¢
000044  0791              LSLS     r1,r2,#30
000046  d504              BPL      |L3.82|
000048  4904              LDR      r1,|L3.92|
00004a  3108              ADDS     r1,r1,#8
00004c  680a              LDR      r2,[r1,#0]
00004e  4302              ORRS     r2,r2,r0
000050  600a              STR      r2,[r1,#0]
                  |L3.82|
;;;118    }
000052  bd70              POP      {r4-r6,pc}
;;;119    
                          ENDP

                  |L3.84|
                          DCD      0x40023820
                  |L3.88|
                          DCD      0x40010000
                  |L3.92|
                          DCD      0x40010400

                          AREA ||i.GPIO_LowPower_Config||, CODE, READONLY, ALIGN=2

                  GPIO_LowPower_Config PROC
;;;549      */
;;;550    void GPIO_LowPower_Config(void)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;551    {
;;;552      GPIO_InitTypeDef GPIO_InitStructure;
;;;553    
;;;554      /* store GPIO configuration before lowpower switch */
;;;555      GPIOA_MODER = GPIOA->MODER;
000004  4c23              LDR      r4,|L4.148|
000006  6820              LDR      r0,[r4,#0]
000008  4923              LDR      r1,|L4.152|
;;;556      GPIOB_MODER = GPIOB->MODER;
00000a  4d24              LDR      r5,|L4.156|
00000c  6008              STR      r0,[r1,#0]  ; GPIOA_MODER
00000e  6828              LDR      r0,[r5,#0]
;;;557      GPIOC_MODER = GPIOC->MODER;
000010  4e23              LDR      r6,|L4.160|
000012  6048              STR      r0,[r1,#4]  ; GPIOB_MODER
000014  6830              LDR      r0,[r6,#0]
;;;558      GPIOD_MODER = GPIOD->MODER;
000016  4a23              LDR      r2,|L4.164|
000018  6088              STR      r0,[r1,#8]  ; GPIOC_MODER
00001a  6810              LDR      r0,[r2,#0]
;;;559      //GPIOE_MODER = GPIOE->MODER;
;;;560      //GPIOH_MODER = GPIOH->MODER;
;;;561      GPIOA_PUPDR = GPIOA->PUPDR;
00001c  60c8              STR      r0,[r1,#0xc]  ; GPIOD_MODER
00001e  68e0              LDR      r0,[r4,#0xc]
;;;562      GPIOB_PUPDR = GPIOB->PUPDR;
000020  6108              STR      r0,[r1,#0x10]  ; GPIOA_PUPDR
000022  481e              LDR      r0,|L4.156|
000024  300c              ADDS     r0,r0,#0xc
000026  6800              LDR      r0,[r0,#0]
;;;563      GPIOC_PUPDR = GPIOC->PUPDR;
000028  6148              STR      r0,[r1,#0x14]  ; GPIOB_PUPDR
00002a  481d              LDR      r0,|L4.160|
00002c  300c              ADDS     r0,r0,#0xc
00002e  6800              LDR      r0,[r0,#0]
;;;564      GPIOD_PUPDR = GPIOD->PUPDR;
000030  6188              STR      r0,[r1,#0x18]  ; GPIOC_PUPDR
000032  481c              LDR      r0,|L4.164|
000034  300c              ADDS     r0,r0,#0xc
000036  6800              LDR      r0,[r0,#0]
;;;565      //GPIOE_PUPDR = GPIOE->PUPDR;
;;;566      //GPIOH_PUPDR = GPIOH->PUPDR;
;;;567    
;;;568      /* Configure all GPIO port pins in Analog input mode (trigger OFF) */
;;;569      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_All;
;;;570      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_400KHz;
000038  61c8              STR      r0,[r1,#0x1c]  ; GPIOD_PUPDR
00003a  2000              MOVS     r0,#0
00003c  f88d0005          STRB     r0,[sp,#5]
;;;571      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
000040  2103              MOVS     r1,#3
000042  f88d1004          STRB     r1,[sp,#4]
;;;572      GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
000046  f88d0006          STRB     r0,[sp,#6]
;;;573      GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
00004a  f88d0007          STRB     r0,[sp,#7]
;;;574    
;;;575    
;;;576      GPIOD->MODER   = 0xFFFFFFFF;
00004e  1e40              SUBS     r0,r0,#1
000050  f64f77ff          MOV      r7,#0xffff            ;569
000054  6010              STR      r0,[r2,#0]
;;;577     // GPIOE->MODER   = 0xFFFFFFFF;
;;;578      //GPIOH->MODER   = 0xFFFFFFFF;
;;;579    
;;;580      /* all GPIOA */
;;;581      GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_1 | GPIO_Pin_3 | GPIO_Pin_6| GPIO_Pin_7 \
000056  f64f70ea          MOV      r0,#0xffea
;;;582        | GPIO_Pin_13 | GPIO_Pin_14|GPIO_Pin_5 | GPIO_Pin_8  |GPIO_Pin_9 | GPIO_Pin_10 | GPIO_Pin_11 |  GPIO_Pin_12 |GPIO_Pin_15 ;
;;;583    
;;;584       GPIO_Init(GPIOA, &GPIO_InitStructure);
00005a  9000              STR      r0,[sp,#0]
00005c  4669              MOV      r1,sp
00005e  4620              MOV      r0,r4
000060  f7fffffe          BL       GPIO_Init
;;;585       
;;;586       GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
000064  2004              MOVS     r0,#4
;;;587       GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
000066  9000              STR      r0,[sp,#0]
000068  2001              MOVS     r0,#1
00006a  f88d0007          STRB     r0,[sp,#7]
;;;588       GPIO_Init(GPIOA, &GPIO_InitStructure);
00006e  4669              MOV      r1,sp
000070  4620              MOV      r0,r4
000072  f7fffffe          BL       GPIO_Init
;;;589    
;;;590       /* All GPIOC except PC13 which is used for mesurement */
;;;591      GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4|  GPIO_Pin_5 |GPIO_Pin_6| GPIO_Pin_7| GPIO_Pin_8 \
000076  f64d70ff          MOV      r0,#0xdfff
;;;592                                     | GPIO_Pin_9 | GPIO_Pin_10 | GPIO_Pin_11 |  GPIO_Pin_12 | GPIO_Pin_14 | GPIO_Pin_15 ;
;;;593      GPIO_Init(GPIOC, &GPIO_InitStructure);
00007a  9000              STR      r0,[sp,#0]
00007c  4669              MOV      r1,sp
00007e  4630              MOV      r0,r6
000080  f7fffffe          BL       GPIO_Init
;;;594    
;;;595       /* all GPIOB except PB6 and PB7 used for LED*/
;;;596      GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4|  GPIO_Pin_5 |GPIO_Pin_6 |GPIO_Pin_7 | GPIO_Pin_8 \
;;;597                                     | GPIO_Pin_9 | GPIO_Pin_10 | GPIO_Pin_11 |  GPIO_Pin_12 |GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15 ;
;;;598      GPIO_Init(GPIOB, &GPIO_InitStructure);
000084  4669              MOV      r1,sp
000086  4628              MOV      r0,r5
000088  9700              STR      r7,[sp,#0]
00008a  f7fffffe          BL       GPIO_Init
;;;599    
;;;600    
;;;601     // GPIO_LOW(GPIOB,GPIO_Pin_6);
;;;602     // GPIO_LOW(GPIOB,GPIO_Pin_7);
;;;603    }
00008e  e8bd81fc          POP      {r2-r8,pc}
;;;604    
                          ENDP

000092  0000              DCW      0x0000
                  |L4.148|
                          DCD      0x40020000
                  |L4.152|
                          DCD      ||.data||
                  |L4.156|
                          DCD      0x40020400
                  |L4.160|
                          DCD      0x40020800
                  |L4.164|
                          DCD      0x40020c00

                          AREA ||i.GPS_power_ctrl||, CODE, READONLY, ALIGN=2

                  GPS_power_ctrl PROC
;;;920    #if 1
;;;921    void GPS_power_ctrl(u8 ctrl)
000000  b57c              PUSH     {r2-r6,lr}
;;;922    {
000002  4606              MOV      r6,r0
;;;923    	GPIO_InitTypeDef GPIO_InitStructure;
;;;924    
;;;925    	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA,ENABLE);
000004  2101              MOVS     r1,#1
000006  4608              MOV      r0,r1
000008  f7fffffe          BL       RCC_AHBPeriphClockCmd
00000c  2100              MOVS     r1,#0
;;;926    
;;;927    	if(ctrl == 1)  /* new board  for GPS power ctrl */
;;;928    		{
;;;929    		GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_8;
00000e  f44f7480          MOV      r4,#0x100
;;;930    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
;;;931    		GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
;;;932    		GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
;;;933    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_40MHz;
;;;934    		GPIO_Init(GPIOA, &GPIO_InitStructure);
000012  480e              LDR      r0,|L5.76|
000014  2e01              CMP      r6,#1                 ;927
000016  9400              STR      r4,[sp,#0]            ;927
000018  d007              BEQ      |L5.42|
;;;935    		GPIO_HIGH(GPIOA, GPIO_Pin_8);
;;;936    		}
;;;937    	else
;;;938    		{
;;;939    
;;;940    		GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_8;//|GPIO_Pin_15;
;;;941    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
00001a  f88d1004          STRB     r1,[sp,#4]
;;;942    		GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
00001e  f88d1007          STRB     r1,[sp,#7]
;;;943    		GPIO_Init(GPIOA, &GPIO_InitStructure);
000022  4669              MOV      r1,sp
000024  f7fffffe          BL       GPIO_Init
;;;944    		}
;;;945        //v1000_debug("gps power %d \r\n",ctrl);
;;;946    }
000028  bd7c              POP      {r2-r6,pc}
                  |L5.42|
00002a  2201              MOVS     r2,#1                 ;930
00002c  f88d2004          STRB     r2,[sp,#4]            ;930
000030  f88d1006          STRB     r1,[sp,#6]            ;931
000034  f88d1007          STRB     r1,[sp,#7]            ;932
000038  2103              MOVS     r1,#3                 ;933
00003a  f88d1005          STRB     r1,[sp,#5]            ;933
00003e  4669              MOV      r1,sp                 ;934
000040  4605              MOV      r5,r0                 ;934
000042  f7fffffe          BL       GPIO_Init
000046  832c              STRH     r4,[r5,#0x18]         ;935
000048  bd7c              POP      {r2-r6,pc}
;;;947    
                          ENDP

00004a  0000              DCW      0x0000
                  |L5.76|
                          DCD      0x40020000

                          AREA ||i.JTAG_Set||, CODE, READONLY, ALIGN=1

                  JTAG_Set PROC
;;;221    //100818
;;;222    void JTAG_Set(u8 mode)
000000  4770              BX       lr
;;;223    {
;;;224    //	u32 temp;
;;;225    	//temp=mode;
;;;226    //	temp<<=25;
;;;227    	//init GPIOA.13,GPIOA.15  ÉÏÀ­ÊäÈë
;;;228    
;;;229    #if 0
;;;230    	  GPIO_InitTypeDef  GPIO_InitStructure;
;;;231    
;;;232    
;;;233    	RCC->APB2ENR|=1<<0;     //¿ªÆô¸¨ÖúÊ±ÖÓ
;;;234    //	SYSCFG->MAPR&=0XF8FFFFFF; //Çå³ýMAPRµÄ[26:24]
;;;235    	//SYSCFG->MAPR|=temp;       //ÉèÖÃjtagÄ£Ê½
;;;236    
;;;237    	if(mode == 1)
;;;238    		{
;;;239    		RCC_APB2PeriphClockCmd(RCC_AHBPeriph_GPIOA,ENABLE);
;;;240    		GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_13;
;;;241    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
;;;242    		GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
;;;243    	//	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_40MHz;
;;;244    		GPIO_Init(GPIOA, &GPIO_InitStructure);
;;;245    
;;;246    		GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_14;
;;;247    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
;;;248    		GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_DOWN;
;;;249    	//	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_40MHz;
;;;250    		GPIO_Init(GPIOA, &GPIO_InitStructure);
;;;251    		GPIO_PinAFConfig(GPIOA, GPIO_PinSource13, GPIO_AF_SWJ);
;;;252    		GPIO_PinAFConfig(GPIOA, GPIO_PinSource14, GPIO_AF_SWJ);
;;;253    		}
;;;254    	else
;;;255    		{
;;;256    			RCC_APB2PeriphClockCmd(RCC_AHBPeriph_GPIOA,ENABLE);
;;;257    			GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_13|GPIO_Pin_14;
;;;258    			GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
;;;259    			GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
;;;260    			GPIO_Init(GPIOA, &GPIO_InitStructure);
;;;261    		}
;;;262    #endif
;;;263    }
;;;264    
                          ENDP


                          AREA ||i.MYRCC_DeInit||, CODE, READONLY, ALIGN=2

                  MYRCC_DeInit PROC
;;;124    //091209
;;;125    void MYRCC_DeInit(void)
000000  4816              LDR      r0,|L7.92|
;;;126    {
000002  b410              PUSH     {r4}
;;;127    	RCC->APB1RSTR = 0x00000000;//¸´Î»½áÊø
000004  2100              MOVS     r1,#0
000006  6001              STR      r1,[r0,#0]
;;;128    	RCC->APB2RSTR = 0x00000000;
000008  1f00              SUBS     r0,r0,#4
00000a  6001              STR      r1,[r0,#0]
;;;129    
;;;130      	RCC->AHBENR = 0x00000014;  //Ë¯ÃßÄ£Ê½ÉÁ´æºÍSRAMÊ±ÖÓÊ¹ÄÜ.ÆäËû¹Ø±Õ.
00000c  4a13              LDR      r2,|L7.92|
00000e  2014              MOVS     r0,#0x14
000010  1d12              ADDS     r2,r2,#4
000012  6010              STR      r0,[r2,#0]
;;;131      	RCC->APB2ENR = 0x00000000; //ÍâÉèÊ±ÖÓ¹Ø±Õ.
000014  1d10              ADDS     r0,r2,#4
000016  6001              STR      r1,[r0,#0]
;;;132      	RCC->APB1ENR = 0x00000000;
000018  1d00              ADDS     r0,r0,#4
00001a  6001              STR      r1,[r0,#0]
;;;133    	RCC->CR |= 0x00000001;     //Ê¹ÄÜÄÚ²¿¸ßËÙÊ±ÖÓHSION
00001c  480f              LDR      r0,|L7.92|
00001e  3818              SUBS     r0,r0,#0x18
000020  6802              LDR      r2,[r0,#0]
000022  f0420201          ORR      r2,r2,#1
000026  6002              STR      r2,[r0,#0]
;;;134    	RCC->CFGR &= 0xF8FF0000;   //¸´Î»SW[1:0],HPRE[3:0],PPRE1[2:0],PPRE2[2:0],ADCPRE[1:0],MCO[2:0]
000028  4a0c              LDR      r2,|L7.92|
00002a  3a10              SUBS     r2,r2,#0x10
00002c  6813              LDR      r3,[r2,#0]
00002e  4c0c              LDR      r4,|L7.96|
000030  4023              ANDS     r3,r3,r4
000032  6013              STR      r3,[r2,#0]
;;;135    	RCC->CR &= 0xFEF6FFFF;     //¸´Î»HSEON,CSSON,PLLON
000034  6803              LDR      r3,[r0,#0]
000036  4c0b              LDR      r4,|L7.100|
000038  4023              ANDS     r3,r3,r4
00003a  6003              STR      r3,[r0,#0]
;;;136    	RCC->CR &= 0xFFFBFFFF;     //¸´Î»HSEBYP
00003c  6803              LDR      r3,[r0,#0]
00003e  f4232380          BIC      r3,r3,#0x40000
000042  6003              STR      r3,[r0,#0]
;;;137    	RCC->CFGR &= 0xFF80FFFF;   //¸´Î»PLLSRC, PLLXTPRE, PLLMUL[3:0] and USBPRE
000044  6810              LDR      r0,[r2,#0]
000046  f42000fe          BIC      r0,r0,#0x7f0000
00004a  6010              STR      r0,[r2,#0]
;;;138    	RCC->CIR = 0x00000000;     //¹Ø±ÕËùÓÐÖÐ¶Ï
00004c  1d10              ADDS     r0,r2,#4
00004e  6001              STR      r1,[r0,#0]
;;;139    	//ÅäÖÃÏòÁ¿±í
;;;140    #ifdef  VECT_TAB_RAM
;;;141    	MY_NVIC_SetVectorTable(NVIC_VectTab_RAM, 0x0);
;;;142    #else
;;;143    	MY_NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x3000);
000050  bc10              POP      {r4}
000052  f44f5140          MOV      r1,#0x3000
000056  0610              LSLS     r0,r2,#24
000058  f7ffbffe          B.W      MY_NVIC_SetVectorTable
;;;144    #endif
;;;145    }
;;;146    //THUMBÖ¸Áî²»Ö§³Ö»ã±àÄÚÁª
                          ENDP

                  |L7.92|
                          DCD      0x40023818
                  |L7.96|
                          DCD      0xf8ff0000
                  |L7.100|
                          DCD      0xfef6ffff

                          AREA ||i.MY_NVIC_Init||, CODE, READONLY, ALIGN=1

                  MY_NVIC_Init PROC
;;;78     //100329
;;;79     void MY_NVIC_Init(u8 NVIC_PreemptionPriority,u8 NVIC_SubPriority,u8 NVIC_Channel,u8 NVIC_Group)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;80     {
000004  4689              MOV      r9,r1
000006  4680              MOV      r8,r0
;;;81     	u32 temp;
;;;82     	u8 IPRADDR=NVIC_Channel/4;  //Ã¿×éÖ»ÄÜ´æ4¸ö,µÃµ½×éµØÖ·
;;;83     	u8 IPROFFSET=NVIC_Channel%4;//ÔÚ×éÄÚµÄÆ«ÒÆ
000008  f0020003          AND      r0,r2,#3
;;;84     	IPROFFSET=IPROFFSET*8+4;    //µÃµ½Æ«ÒÆµÄÈ·ÇÐÎ»ÖÃ
00000c  2104              MOVS     r1,#4
00000e  eb0106c0          ADD      r6,r1,r0,LSL #3
000012  4614              MOV      r4,r2                 ;80
000014  461d              MOV      r5,r3                 ;80
000016  0897              LSRS     r7,r2,#2              ;82
;;;85     	MY_NVIC_PriorityGroupConfig(NVIC_Group);//ÉèÖÃ·Ö×é
000018  4618              MOV      r0,r3
00001a  f7fffffe          BL       MY_NVIC_PriorityGroupConfig
;;;86     	temp=NVIC_PreemptionPriority<<(4-NVIC_Group);
00001e  f1c50004          RSB      r0,r5,#4
000022  fa08f100          LSL      r1,r8,r0
;;;87     	temp|=NVIC_SubPriority&(0x0f>>NVIC_Group);
000026  200f              MOVS     r0,#0xf
000028  40e8              LSRS     r0,r0,r5
00002a  ea000009          AND      r0,r0,r9
00002e  4308              ORRS     r0,r0,r1
;;;88     	temp&=0xf;//È¡µÍËÄÎ»
000030  f000020f          AND      r2,r0,#0xf
;;;89     
;;;90     	if(NVIC_Channel<32)NVIC->ISER[0]|=1<<NVIC_Channel;//Ê¹ÄÜÖÐ¶ÏÎ»(ÒªÇå³ýµÄ»°,Ïà·´²Ù×÷¾ÍOK)
000034  2001              MOVS     r0,#1
000036  f04f21e0          MOV      r1,#0xe000e000
00003a  2c20              CMP      r4,#0x20
00003c  d206              BCS      |L8.76|
00003e  f8d13100          LDR      r3,[r1,#0x100]
000042  40a0              LSLS     r0,r0,r4
000044  4303              ORRS     r3,r3,r0
000046  f8c13100          STR      r3,[r1,#0x100]
00004a  e006              B        |L8.90|
                  |L8.76|
;;;91     	else NVIC->ISER[1]|=1<<(NVIC_Channel-32);
00004c  f8d13104          LDR      r3,[r1,#0x104]
000050  3c20              SUBS     r4,r4,#0x20
000052  40a0              LSLS     r0,r0,r4
000054  4303              ORRS     r3,r3,r0
000056  f8c13104          STR      r3,[r1,#0x104]
                  |L8.90|
00005a  00b8              LSLS     r0,r7,#2
00005c  f10020e0          ADD      r0,r0,#0xe000e000
;;;92     	NVIC->IPR[IPRADDR]|=temp<<IPROFFSET;//ÉèÖÃÏìÓ¦ÓÅÏÈ¼¶ºÍÇÀ¶ÏÓÅÏÈ¼¶
000060  f8d01f04          LDR      r1,[r0,#0xf04]
000064  40b2              LSLS     r2,r2,r6
000066  4311              ORRS     r1,r1,r2
000068  f8c01f04          STR      r1,[r0,#0xf04]
;;;93     }
00006c  e8bd83f0          POP      {r4-r9,pc}
;;;94     
                          ENDP


                          AREA ||i.MY_NVIC_PriorityGroupConfig||, CODE, READONLY, ALIGN=2

                  MY_NVIC_PriorityGroupConfig PROC
;;;52     //091209
;;;53     void MY_NVIC_PriorityGroupConfig(u8 NVIC_Group)
000000  2107              MOVS     r1,#7
;;;54     {
;;;55     	u32 temp,temp1;
;;;56     	temp1=(~NVIC_Group)&0x07;//È¡ºóÈýÎ»
000002  4381              BICS     r1,r1,r0
;;;57     	temp1<<=8;
000004  020a              LSLS     r2,r1,#8
;;;58     	temp=SCB->AIRCR;  //¶ÁÈ¡ÏÈÇ°µÄÉèÖÃ
000006  4905              LDR      r1,|L9.28|
000008  6808              LDR      r0,[r1,#0]
;;;59     	temp&=0X0000F8FF; //Çå¿ÕÏÈÇ°·Ö×é
00000a  f64f03ff          MOV      r3,#0xf8ff
00000e  4018              ANDS     r0,r0,r3
;;;60     	temp|=0X05FA0000; //Ð´ÈëÔ¿³×
000010  4b03              LDR      r3,|L9.32|
000012  4318              ORRS     r0,r0,r3
;;;61     	temp|=temp1;
000014  4310              ORRS     r0,r0,r2
;;;62     	SCB->AIRCR=temp;  //ÉèÖÃ·Ö×é
000016  6008              STR      r0,[r1,#0]
;;;63     }
000018  4770              BX       lr
;;;64     //ÉèÖÃNVIC
                          ENDP

00001a  0000              DCW      0x0000
                  |L9.28|
                          DCD      0xe000ed0c
                  |L9.32|
                          DCD      0x05fa0000

                          AREA ||i.MY_NVIC_SetVectorTable||, CODE, READONLY, ALIGN=2

                  MY_NVIC_SetVectorTable PROC
;;;40     //091207
;;;41     void MY_NVIC_SetVectorTable(u32 NVIC_VectTab, u32 Offset)
000000  4a02              LDR      r2,|L10.12|
;;;42     {
;;;43       	//¼ì²é²ÎÊýºÏ·¨ÐÔ
;;;44     	assert_param(IS_NVIC_VECTTAB(NVIC_VectTab));
;;;45     	assert_param(IS_NVIC_OFFSET(Offset));
;;;46     	SCB->VTOR = NVIC_VectTab|(Offset & (u32)0x1FFFFF80);//ÉèÖÃNVICµÄÏòÁ¿±íÆ«ÒÆ¼Ä´æÆ÷
000002  4011              ANDS     r1,r1,r2
000004  4301              ORRS     r1,r1,r0
000006  4802              LDR      r0,|L10.16|
000008  6001              STR      r1,[r0,#0]
;;;47     	//ÓÃÓÚ±êÊ¶ÏòÁ¿±íÊÇÔÚCODEÇø»¹ÊÇÔÚRAMÇø
;;;48     }
00000a  4770              BX       lr
;;;49     //ÉèÖÃNVIC·Ö×é
                          ENDP

                  |L10.12|
                          DCD      0x1fffff80
                  |L10.16|
                          DCD      0xe000ed08

                          AREA ||i.MyLinRots_ErrorStateProcess||, CODE, READONLY, ALIGN=1

                  MyLinRots_ErrorStateProcess PROC
;;;503      */
;;;504    void MyLinRots_ErrorStateProcess(void)
000000  4770              BX       lr
;;;505    {
;;;506      // Add here your own processing when a sensor is in Error state
;;;507     // TSL_linrot_SetStateOff();
;;;508    }
;;;509    
                          ENDP


                          AREA ||i.MyLinRots_OffStateProcess||, CODE, READONLY, ALIGN=1

                  MyLinRots_OffStateProcess PROC
;;;515      */
;;;516    void MyLinRots_OffStateProcess(void)
000000  4770              BX       lr
;;;517    {
;;;518      // Add here your own processing when a sensor is in Off state
;;;519    }
;;;520    
                          ENDP


                          AREA ||i.NVIC_Configuration||, CODE, READONLY, ALIGN=1

                  NVIC_Configuration PROC
;;;20     //********************************************************************************
;;;21     void NVIC_Configuration(void)
000000  f44f60a0          MOV      r0,#0x500
;;;22     {
;;;23     
;;;24       /* Set the Vector Table base location at 0x3000 */
;;;25     //      NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x3000);
;;;26     
;;;27     	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);	//ÉèÖÃNVICÖÐ¶Ï·Ö×é2:2Î»ÇÀÕ¼ÓÅÏÈ¼¶£¬2Î»ÏìÓ¦ÓÅÏÈ¼¶
000004  f7ffbffe          B.W      NVIC_PriorityGroupConfig
;;;28     
;;;29     }
;;;30     //********************************************************************************
                          ENDP


                          AREA ||i.Restore_GPIO_Config||, CODE, READONLY, ALIGN=2

                  Restore_GPIO_Config PROC
;;;610      */
;;;611    void Restore_GPIO_Config(void)
000000  480d              LDR      r0,|L14.56|
;;;612    {
;;;613      GPIOA->MODER = GPIOA_MODER;
000002  490e              LDR      r1,|L14.60|
000004  6802              LDR      r2,[r0,#0]  ; GPIOA_MODER
000006  600a              STR      r2,[r1,#0]
;;;614      GPIOB->MODER = GPIOB_MODER;
000008  4b0d              LDR      r3,|L14.64|
00000a  6842              LDR      r2,[r0,#4]  ; GPIOB_MODER
00000c  601a              STR      r2,[r3,#0]
;;;615      GPIOC->MODER = GPIOC_MODER;
00000e  4b0d              LDR      r3,|L14.68|
000010  6882              LDR      r2,[r0,#8]  ; GPIOC_MODER
000012  601a              STR      r2,[r3,#0]
;;;616      GPIOD->MODER = GPIOD_MODER;
000014  4b0c              LDR      r3,|L14.72|
000016  68c2              LDR      r2,[r0,#0xc]  ; GPIOD_MODER
000018  601a              STR      r2,[r3,#0]
;;;617     // GPIOE->MODER = GPIOE_MODER;
;;;618      //GPIOH->MODER = GPIOH_MODER;
;;;619    
;;;620      GPIOA->PUPDR = GPIOA_PUPDR;
00001a  6902              LDR      r2,[r0,#0x10]  ; GPIOA_PUPDR
00001c  60ca              STR      r2,[r1,#0xc]
;;;621      GPIOB->PUPDR = GPIOB_PUPDR;
00001e  4a08              LDR      r2,|L14.64|
000020  6941              LDR      r1,[r0,#0x14]  ; GPIOB_PUPDR
000022  320c              ADDS     r2,r2,#0xc
000024  6011              STR      r1,[r2,#0]
;;;622      GPIOC->PUPDR = GPIOC_PUPDR;
000026  4a07              LDR      r2,|L14.68|
000028  6981              LDR      r1,[r0,#0x18]  ; GPIOC_PUPDR
00002a  320c              ADDS     r2,r2,#0xc
00002c  6011              STR      r1,[r2,#0]
;;;623      GPIOD->PUPDR = GPIOD_PUPDR;
00002e  4906              LDR      r1,|L14.72|
000030  69c0              LDR      r0,[r0,#0x1c]  ; GPIOD_PUPDR
000032  310c              ADDS     r1,r1,#0xc
000034  6008              STR      r0,[r1,#0]
;;;624      //GPIOE->PUPDR = GPIOE_PUPDR;
;;;625      //GPIOH->PUPDR = GPIOH_PUPDR;
;;;626    }
000036  4770              BX       lr
;;;627    
                          ENDP

                  |L14.56|
                          DCD      ||.data||
                  |L14.60|
                          DCD      0x40020000
                  |L14.64|
                          DCD      0x40020400
                  |L14.68|
                          DCD      0x40020800
                  |L14.72|
                          DCD      0x40020c00

                          AREA ||i.SetHSICLK||, CODE, READONLY, ALIGN=2

                  SetHSICLK PROC
;;;335      */
;;;336    void SetHSICLK(void)
000000  b510              PUSH     {r4,lr}
;;;337    {
;;;338      /* Enable HSI Clock */
;;;339      RCC_HSICmd(ENABLE);
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       RCC_HSICmd
                  |L15.8|
;;;340    
;;;341      /*!< Wait till HSI is ready */
;;;342      while (RCC_GetFlagStatus(RCC_FLAG_HSIRDY) == RESET);
000008  2021              MOVS     r0,#0x21
00000a  f7fffffe          BL       RCC_GetFlagStatus
00000e  2800              CMP      r0,#0
000010  d0fa              BEQ      |L15.8|
;;;343    
;;;344      /* Enable 64-bit access */
;;;345      FLASH_ReadAccess64Cmd(ENABLE);
000012  2001              MOVS     r0,#1
000014  f7fffffe          BL       FLASH_ReadAccess64Cmd
;;;346    
;;;347      /* Enable Prefetch Buffer */
;;;348      FLASH_PrefetchBufferCmd(ENABLE);
000018  2001              MOVS     r0,#1
00001a  f7fffffe          BL       FLASH_PrefetchBufferCmd
;;;349    
;;;350      /* Flash 1 wait state */
;;;351      FLASH_SetLatency(FLASH_Latency_1);
00001e  2001              MOVS     r0,#1
000020  f7fffffe          BL       FLASH_SetLatency
;;;352    
;;;353      RCC_SYSCLKConfig(RCC_SYSCLKSource_HSI);
000024  2001              MOVS     r0,#1
000026  f7fffffe          BL       RCC_SYSCLKConfig
;;;354    
;;;355      while (RCC_GetSYSCLKSource() != 0x04);
00002a  bf00              NOP      
                  |L15.44|
00002c  f7fffffe          BL       RCC_GetSYSCLKSource
000030  2804              CMP      r0,#4
000032  d1fb              BNE      |L15.44|
;;;356    
;;;357      RCC_HCLKConfig(RCC_SYSCLK_Div1);
000034  2000              MOVS     r0,#0
000036  f7fffffe          BL       RCC_HCLKConfig
;;;358      /* PCLK2 = HCLK */
;;;359      RCC_PCLK2Config(RCC_HCLK_Div1);
00003a  2000              MOVS     r0,#0
00003c  f7fffffe          BL       RCC_PCLK2Config
;;;360    
;;;361      /* PCLK1 = HCLK */
;;;362      RCC_PCLK1Config(RCC_HCLK_Div1);
000040  e8bd4010          POP      {r4,lr}
000044  2000              MOVS     r0,#0
000046  f7ffbffe          B.W      RCC_PCLK1Config
;;;363    
;;;364    }
;;;365    
                          ENDP


                          AREA ||i.SetHSICLKToMSI||, CODE, READONLY, ALIGN=2

                  SetHSICLKToMSI PROC
;;;274      */
;;;275    void SetHSICLKToMSI(u32 freq,u8 div2,u8 With_RTC)
000000  b570              PUSH     {r4-r6,lr}
;;;276    {
000002  4614              MOV      r4,r2
000004  460d              MOV      r5,r1
000006  4606              MOV      r6,r0
;;;277    
;;;278      /* RCC system reset */
;;;279      RCC_DeInit();
000008  f7fffffe          BL       RCC_DeInit
;;;280    
;;;281      /* Flash no latency*/
;;;282      FLASH_SetLatency(FLASH_Latency_0);
00000c  2000              MOVS     r0,#0
00000e  f7fffffe          BL       FLASH_SetLatency
;;;283    
;;;284      /* Disable Prefetch Buffer */
;;;285      FLASH_PrefetchBufferCmd(DISABLE);
000012  2000              MOVS     r0,#0
000014  f7fffffe          BL       FLASH_PrefetchBufferCmd
;;;286    
;;;287      /* Disable 64-bit access */
;;;288      FLASH_ReadAccess64Cmd(DISABLE);
000018  2000              MOVS     r0,#0
00001a  f7fffffe          BL       FLASH_ReadAccess64Cmd
;;;289    
;;;290      /* Disable FLASH during SLeep  */
;;;291      FLASH_SLEEPPowerDownCmd(ENABLE);
00001e  2001              MOVS     r0,#1
000020  f7fffffe          BL       FLASH_SLEEPPowerDownCmd
;;;292    
;;;293      /* Enable the PWR APB1 Clock */
;;;294      RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);
000024  2101              MOVS     r1,#1
000026  0708              LSLS     r0,r1,#28
000028  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;295    
;;;296      /* Select the Voltage Range 3 (1.2V) */
;;;297      PWR_VoltageScalingConfig(PWR_VoltageScaling_Range3);
00002c  f44f50c0          MOV      r0,#0x1800
000030  f7fffffe          BL       PWR_VoltageScalingConfig
                  |L16.52|
;;;298    
;;;299      /* Wait Until the Voltage Regulator is ready */
;;;300      while (PWR_GetFlagStatus(PWR_FLAG_VOS) != RESET);
000034  2010              MOVS     r0,#0x10
000036  f7fffffe          BL       PWR_GetFlagStatus
00003a  2800              CMP      r0,#0
00003c  d1fa              BNE      |L16.52|
;;;301    
;;;302      /* Configure the MSI frequency */
;;;303      RCC_MSIRangeConfig(freq);
00003e  4630              MOV      r0,r6
000040  f7fffffe          BL       RCC_MSIRangeConfig
;;;304    
;;;305      /* Select MSI as system clock source */
;;;306      RCC_SYSCLKConfig(RCC_SYSCLKSource_MSI);
000044  2000              MOVS     r0,#0
000046  f7fffffe          BL       RCC_SYSCLKConfig
;;;307    
;;;308      /* Wait until MSI is used as system clock source */
;;;309      while (RCC_GetSYSCLKSource() != 0x00);
00004a  bf00              NOP      
                  |L16.76|
00004c  f7fffffe          BL       RCC_GetSYSCLKSource
000050  2800              CMP      r0,#0
000052  d1fb              BNE      |L16.76|
;;;310    
;;;311      if (div2)
000054  b115              CBZ      r5,|L16.92|
;;;312      {
;;;313        RCC_HCLKConfig(RCC_SYSCLK_Div2);
000056  2080              MOVS     r0,#0x80
000058  f7fffffe          BL       RCC_HCLKConfig
                  |L16.92|
;;;314      }
;;;315    
;;;316      RCC_HSICmd(DISABLE);
00005c  2000              MOVS     r0,#0
00005e  f7fffffe          BL       RCC_HSICmd
;;;317    
;;;318      /* Disable HSE clock */
;;;319      RCC_HSEConfig(RCC_HSE_OFF);
000062  2000              MOVS     r0,#0
000064  f7fffffe          BL       RCC_HSEConfig
;;;320    
;;;321      /* Disable LSE clock */
;;;322      if (! With_RTC)
000068  2c00              CMP      r4,#0
00006a  d104              BNE      |L16.118|
;;;323       RCC_LSICmd(DISABLE);
00006c  e8bd4070          POP      {r4-r6,lr}
000070  2000              MOVS     r0,#0
000072  f7ffbffe          B.W      RCC_LSICmd
                  |L16.118|
;;;324    
;;;325      /* Disable LSI clock */
;;;326    //  RCC_LSICmd(DISABLE);
;;;327    
;;;328    }
000076  bd70              POP      {r4-r6,pc}
;;;329    
                          ENDP


                          AREA ||i.SoftReset||, CODE, READONLY, ALIGN=2

                  SoftReset PROC
;;;524    
;;;525    void SoftReset(void)
000000  2001              MOVS     r0,#1
000002  f3808813          MSR      FAULTMASK,r0
000006  f3bf8f4f          DSB      
00000a  4805              LDR      r0,|L17.32|
00000c  6801              LDR      r1,[r0,#0]
00000e  4a05              LDR      r2,|L17.36|
000010  f40161e0          AND      r1,r1,#0x700
000014  4311              ORRS     r1,r1,r2
000016  6001              STR      r1,[r0,#0]
000018  f3bf8f4f          DSB      
                  |L17.28|
00001c  e7fe              B        |L17.28|
;;;526    {
;;;527        __set_FAULTMASK(1);      // ¹Ø±ÕËùÓÐÖÐ¶Ë
;;;528         NVIC_SystemReset();// ¸´Î»
;;;529    
;;;530    }
;;;531    
                          ENDP

00001e  0000              DCW      0x0000
                  |L17.32|
                          DCD      0xe000ed0c
                  |L17.36|
                          DCD      0x05fa0004

                          AREA ||i.Stm32_Clock_Init||, CODE, READONLY, ALIGN=1

                  Stm32_Clock_Init PROC
;;;372    //091209
;;;373    void Stm32_Clock_Init(u8 PLL)
000000  b510              PUSH     {r4,lr}
;;;374    {
;;;375    
;;;376    #if 0
;;;377      /* Enable HSI Clock */
;;;378      RCC_HSICmd(ENABLE);
;;;379    
;;;380      /*!< Wait till HSI is ready */
;;;381      while (RCC_GetFlagStatus(RCC_FLAG_HSIRDY) == RESET);
;;;382    
;;;383      /* Set HSI as sys clock*/
;;;384     //RCC_SYSCLKConfig(RCC_SYSCLKSource_HSI);
;;;385    
;;;386    
;;;387      /* Set MSI clock range to ~4.194MHz*/
;;;388     // RCC_MSIRangeConfig(RCC_MSIRange_6);
;;;389    
;;;390    
;;;391    	RCC_PLLConfig(RCC_PLLSource_HSI, RCC_PLLMul_6,RCC_PLLDiv_4);
;;;392    	RCC_PLLCmd(ENABLE);
;;;393        /* Wait till PLL is ready */
;;;394        while((RCC->CR & RCC_CR_PLLRDY) == 0)
;;;395        {
;;;396        ;
;;;397        }
;;;398      /* Set HSI as sys clock*/
;;;399      RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
;;;400    
;;;401        /* Wait till PLL is used as system clock source */
;;;402        while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)RCC_CFGR_SWS_PLL)
;;;403        {
;;;404        ;
;;;405        }
;;;406    #endif
;;;407      //MYRCC_DeInit();		  //¸´Î»²¢ÅäÖÃÏòÁ¿±
;;;408    
;;;409      /* Enable the GPIOs clocks */
;;;410      RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA | RCC_AHBPeriph_GPIOB | RCC_AHBPeriph_GPIOC| RCC_AHBPeriph_GPIOD, ENABLE);
000002  2101              MOVS     r1,#1
000004  200f              MOVS     r0,#0xf
000006  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;411    
;;;412    
;;;413    #if 1  /* »áÓ°ÏìÕý³£µÄRTC¹¤×÷ £¬±ä³ÉÖØÐÂ¸´Î»ÁË*/
;;;414      /* Enable comparator, LCD and PWR mngt clocks */
;;;415     RCC_APB1PeriphClockCmd( RCC_APB1Periph_PWR,ENABLE);
00000a  2101              MOVS     r1,#1
00000c  0708              LSLS     r0,r1,#28
00000e  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;416    
;;;417      /* Enable ADC & SYSCFG clocks */
;;;418     RCC_APB2PeriphClockCmd( RCC_APB2Periph_SYSCFG , ENABLE);
000012  2101              MOVS     r1,#1
000014  4608              MOV      r0,r1
000016  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;419    
;;;420      /* Allow access to the RTC */
;;;421     // PWR_RTCAccessCmd(ENABLE);
;;;422    
;;;423      /* Reset RTC Backup Domain */
;;;424      //RCC_RTCResetCmd(ENABLE);
;;;425      //RCC_RTCResetCmd(DISABLE);
;;;426    
;;;427      /* LSE Enable */
;;;428      //RCC_LSEConfig(RCC_LSE_ON);
;;;429    
;;;430      /* Wait until LSE is ready */
;;;431     // while (RCC_GetFlagStatus(RCC_FLAG_LSERDY) == RESET);
;;;432    
;;;433       /* RTC Clock Source Selection */
;;;434     // RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);
;;;435    
;;;436      /* Enable the RTC */
;;;437      //RCC_RTCCLKCmd(ENABLE);
;;;438    
;;;439    
;;;440    
;;;441      /*Disable HSE*/
;;;442    // RCC_HSEConfig(RCC_HSE_OFF);
;;;443    //if(RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET )
;;;444      {
;;;445        /* Stay in infinite loop if HSE is not disabled*/
;;;446     //   while(1);
;;;447      }
;;;448      #endif
;;;449    
;;;450    
;;;451    
;;;452      /* Set internal voltage regulator to 1.8V */
;;;453      PWR_VoltageScalingConfig(PWR_VoltageScaling_Range1);
00001a  f44f6000          MOV      r0,#0x800
00001e  f7fffffe          BL       PWR_VoltageScalingConfig
                  |L18.34|
;;;454    
;;;455      /* Wait Until the Voltage Regulator is ready */
;;;456      while (PWR_GetFlagStatus(PWR_FLAG_VOS) != RESET) ;
000022  2010              MOVS     r0,#0x10
000024  f7fffffe          BL       PWR_GetFlagStatus
000028  2800              CMP      r0,#0
00002a  d1fa              BNE      |L18.34|
;;;457    
;;;458    
;;;459    
;;;460      #ifdef  VECT_TAB_RAM
;;;461        // Set the Vector Table base location at 0x20000000
;;;462        NVIC_SetVectorTable(NVIC_VectTab_RAM, 0x0);
;;;463    #else  /* VECT_TAB_FLASH  */
;;;464        // Set the Vector Table base location at 0x08000000
;;;465        NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x3000);
00002c  e8bd4010          POP      {r4,lr}
000030  f44f5140          MOV      r1,#0x3000
000034  f04f6000          MOV      r0,#0x8000000
000038  f7ffbffe          B.W      NVIC_SetVectorTable
;;;466    #endif
;;;467    
;;;468    }
;;;469    
                          ENDP


                          AREA ||i.Sys_Soft_Reset||, CODE, READONLY, ALIGN=2

                  Sys_Soft_Reset PROC
;;;212    //091209
;;;213    void Sys_Soft_Reset(void)
000000  4902              LDR      r1,|L19.12|
;;;214    {
;;;215    	SCB->AIRCR =0X05FA0000|(u32)0x04;
000002  4801              LDR      r0,|L19.8|
000004  6008              STR      r0,[r1,#0]
;;;216    }
000006  4770              BX       lr
;;;217    
                          ENDP

                  |L19.8|
                          DCD      0x05fa0004
                  |L19.12|
                          DCD      0xe000ed0c

                          AREA ||i.Sys_Standby||, CODE, READONLY, ALIGN=2

                  Sys_Standby PROC
;;;156    //091202
;;;157    void Sys_Standby(void)
000000  480c              LDR      r0,|L20.52|
;;;158    {
;;;159    	SCB->SCR|=1<<2;//Ê¹ÄÜSLEEPDEEPÎ» (SYS->CTRL)
000002  6801              LDR      r1,[r0,#0]
000004  f0410104          ORR      r1,r1,#4
000008  6001              STR      r1,[r0,#0]
;;;160      	RCC->APB1ENR|=1<<28;     //Ê¹ÄÜµçÔ´Ê±ÖÓ
00000a  480b              LDR      r0,|L20.56|
00000c  6801              LDR      r1,[r0,#0]
00000e  f0415180          ORR      r1,r1,#0x10000000
000012  6001              STR      r1,[r0,#0]
;;;161     	PWR->CSR|=1<<8;          //ÉèÖÃWKUPÓÃÓÚ»½ÐÑ
000014  4809              LDR      r0,|L20.60|
000016  6841              LDR      r1,[r0,#4]
000018  f4417180          ORR      r1,r1,#0x100
00001c  6041              STR      r1,[r0,#4]
;;;162    	PWR->CR|=1<<2;           //Çå³ýWake-up ±êÖ¾
00001e  6801              LDR      r1,[r0,#0]
000020  f0410104          ORR      r1,r1,#4
000024  6001              STR      r1,[r0,#0]
;;;163    	PWR->CR|=1<<1;           //PDDSÖÃÎ»
000026  6801              LDR      r1,[r0,#0]
000028  f0410102          ORR      r1,r1,#2
00002c  6001              STR      r1,[r0,#0]
;;;164    	WFI_SET();				 //Ö´ÐÐWFIÖ¸Áî
00002e  f7ffbffe          B.W      WFI_SET
;;;165    }
;;;166    //ºó±¸¼Ä´æÆ÷Ð´Èë²Ù×÷
                          ENDP

000032  0000              DCW      0x0000
                  |L20.52|
                          DCD      0xe000ed10
                  |L20.56|
                          DCD      0x40023824
                  |L20.60|
                          DCD      0x40007000

                          AREA ||i.alarm_everytimer||, CODE, READONLY, ALIGN=1

                  alarm_everytimer PROC
;;;659    
;;;660    void alarm_everytimer(void)
000000  b510              PUSH     {r4,lr}
;;;661    {
;;;662    
;;;663       RTC_TimeTypeDef MY_RTC_TimeStructure;
;;;664       RTC_AlarmTypeDef  RTC_AlarmStructure;
;;;665    
;;;666        /* Disable the Alarm A */
;;;667        RTC_AlarmCmd(RTC_Alarm_A, DISABLE);
000002  f44f7480          MOV      r4,#0x100
000006  b086              SUB      sp,sp,#0x18           ;661
000008  2100              MOVS     r1,#0
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       RTC_AlarmCmd
;;;668    
;;;669        RTC_GetTime(RTC_Format_BCD, &MY_RTC_TimeStructure);
000010  a904              ADD      r1,sp,#0x10
000012  2001              MOVS     r0,#1
000014  f7fffffe          BL       RTC_GetTime
;;;670    
;;;671        /* Set the alarm X+5s */
;;;672        RTC_AlarmStructure.RTC_AlarmTime.RTC_H12     = MY_RTC_TimeStructure.RTC_H12;
000018  f89d0013          LDRB     r0,[sp,#0x13]
00001c  f88d0003          STRB     r0,[sp,#3]
;;;673        RTC_AlarmStructure.RTC_AlarmTime.RTC_Hours   = MY_RTC_TimeStructure.RTC_Hours;
000020  f89d0010          LDRB     r0,[sp,#0x10]
000024  f88d0000          STRB     r0,[sp,#0]
;;;674        RTC_AlarmStructure.RTC_AlarmTime.RTC_Minutes = MY_RTC_TimeStructure.RTC_Minutes;
000028  f89d0011          LDRB     r0,[sp,#0x11]
00002c  f88d0001          STRB     r0,[sp,#1]
;;;675        RTC_AlarmStructure.RTC_AlarmTime.RTC_Seconds = (MY_RTC_TimeStructure.RTC_Seconds + 0x5) % 60;
000030  f89d0012          LDRB     r0,[sp,#0x12]
000034  213c              MOVS     r1,#0x3c
000036  1d40              ADDS     r0,r0,#5
000038  fbb0f2f1          UDIV     r2,r0,r1
00003c  fb010012          MLS      r0,r1,r2,r0
000040  f88d0002          STRB     r0,[sp,#2]
;;;676        RTC_AlarmStructure.RTC_AlarmDateWeekDay = 0x31;
000044  2031              MOVS     r0,#0x31
000046  f88d000c          STRB     r0,[sp,#0xc]
;;;677        RTC_AlarmStructure.RTC_AlarmDateWeekDaySel = RTC_AlarmDateWeekDaySel_Date;
00004a  2000              MOVS     r0,#0
;;;678        RTC_AlarmStructure.RTC_AlarmMask = RTC_AlarmMask_DateWeekDay;
00004c  9002              STR      r0,[sp,#8]
00004e  0748              LSLS     r0,r1,#29
;;;679        RTC_SetAlarm(RTC_Format_BCD, RTC_Alarm_A, &RTC_AlarmStructure);
000050  9001              STR      r0,[sp,#4]
000052  466a              MOV      r2,sp
000054  4621              MOV      r1,r4
000056  2001              MOVS     r0,#1
000058  f7fffffe          BL       RTC_SetAlarm
;;;680    
;;;681        /* Enable RTC Alarm A Interrupt */
;;;682        RTC_ITConfig(RTC_IT_ALRA, ENABLE);
00005c  2101              MOVS     r1,#1
00005e  0308              LSLS     r0,r1,#12
000060  f7fffffe          BL       RTC_ITConfig
;;;683    
;;;684        /* Enable the Alarm A */
;;;685        RTC_AlarmCmd(RTC_Alarm_A, ENABLE);
000064  2101              MOVS     r1,#1
000066  4620              MOV      r0,r4
000068  f7fffffe          BL       RTC_AlarmCmd
;;;686    
;;;687        /* Clear RTC Alarm A flag */
;;;688        RTC_ClearFlag(RTC_FLAG_ALRAF);
00006c  4620              MOV      r0,r4
00006e  f7fffffe          BL       RTC_ClearFlag
;;;689    
;;;690        /* Clear WakeUp flag */
;;;691        PWR_ClearFlag(PWR_FLAG_WU);
000072  2001              MOVS     r0,#1
000074  f7fffffe          BL       PWR_ClearFlag
;;;692    }
000078  b006              ADD      sp,sp,#0x18
00007a  bd10              POP      {r4,pc}
;;;693    
                          ENDP


                          AREA ||i.board_io_init||, CODE, READONLY, ALIGN=2

                  board_io_init PROC
;;;893    
;;;894    void board_io_init(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;895    {
;;;896    	GPIO_InitTypeDef GPIO_InitStructure;
;;;897    	//init GPIOA.13,GPIOA.15  ÉÏÀ­ÊäÈë
;;;898     	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA,ENABLE);
000002  2101              MOVS     r1,#1
000004  4608              MOV      r0,r1
000006  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;899    	GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_0;//|GPIO_Pin_15;
00000a  2001              MOVS     r0,#1
;;;900    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
00000c  9000              STR      r0,[sp,#0]
00000e  2000              MOVS     r0,#0
000010  f88d0004          STRB     r0,[sp,#4]
;;;901    	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_DOWN;
000014  2002              MOVS     r0,#2
000016  f88d0007          STRB     r0,[sp,#7]
;;;902    	GPIO_Init(GPIOA, &GPIO_InitStructure);
00001a  4669              MOV      r1,sp
00001c  4803              LDR      r0,|L22.44|
00001e  f7fffffe          BL       GPIO_Init
;;;903    	v1000_debug("\n\r SYSCLK_Frequency222 :1d");
000022  a003              ADR      r0,|L22.48|
000024  f7fffffe          BL       __2printf
;;;904    
;;;905    	#if 0
;;;906    	GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_8;
;;;907    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
;;;908    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
;;;909    	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
;;;910    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_40MHz;
;;;911     	GPIO_Init(GPIOA, &GPIO_InitStructure);
;;;912    	v1000_debug("\n\r SYSCLK_Frequency111 :1d");
;;;913    
;;;914    	v1000_debug("\n\r SYSCLK_Frequency222 :1d");
;;;915    	GPS_power_ctrl(0);
;;;916    	v1000_debug("\n\r SYSCLK_Frequency1 :1d");
;;;917    #endif
;;;918    
;;;919    }
000028  bd1c              POP      {r2-r4,pc}
;;;920    #if 1
                          ENDP

00002a  0000              DCW      0x0000
                  |L22.44|
                          DCD      0x40020000
                  |L22.48|
000030  0a0d2053          DCB      "\n\r SYSCLK_Frequency222 :1d",0
000034  5953434c
000038  4b5f4672
00003c  65717565
000040  6e637932
000044  3232203a
000048  316400  
00004b  00                DCB      0

                          AREA ||i.convert_into_char||, CODE, READONLY, ALIGN=1

                  convert_into_char PROC
;;;476      */
;;;477    void convert_into_char(uint32_t number, uint16_t *p_tab)
000000  b5f0              PUSH     {r4-r7,lr}
;;;478    {
;;;479       uint16_t units=0, tens=0, hundreds=0, thousands=0, misc=0;
;;;480     
;;;481       units = (((number%10000)%1000)%100)%10;
000002  f2427710          MOV      r7,#0x2710
000006  fbb0f2f7          UDIV     r2,r0,r7
00000a  fb070212          MLS      r2,r7,r2,r0
00000e  f44f767a          MOV      r6,#0x3e8
000012  fbb2f3f6          UDIV     r3,r2,r6
000016  fb062213          MLS      r2,r6,r3,r2
00001a  2464              MOVS     r4,#0x64
00001c  fbb2f3f4          UDIV     r3,r2,r4
000020  fb042213          MLS      r2,r4,r3,r2
000024  250a              MOVS     r5,#0xa
000026  fbb2f3f5          UDIV     r3,r2,r5
00002a  fb052213          MLS      r2,r5,r3,r2
;;;482       tens = ((((number-units)/10)%1000)%100)%10;
00002e  1a83              SUBS     r3,r0,r2
000030  fbb3f3f5          UDIV     r3,r3,r5
000034  fbb3fcf6          UDIV     r12,r3,r6
000038  fb06331c          MLS      r3,r6,r12,r3
00003c  fbb3fcf4          UDIV     r12,r3,r4
000040  fb04331c          MLS      r3,r4,r12,r3
000044  fbb3fcf5          UDIV     r12,r3,r5
000048  fb05331c          MLS      r3,r5,r12,r3
;;;483       hundreds = (((number-tens-units)/100))%100%10;
00004c  eba00c03          SUB      r12,r0,r3
000050  ebac0c02          SUB      r12,r12,r2
000054  fbbcfcf4          UDIV     r12,r12,r4
000058  fbbcfef4          UDIV     lr,r12,r4
00005c  fb04c41e          MLS      r4,r4,lr,r12
000060  fbb4fcf5          UDIV     r12,r4,r5
000064  fb05441c          MLS      r4,r5,r12,r4
;;;484       thousands = ((number-hundreds-tens-units)/1000)%10;
000068  eba00c04          SUB      r12,r0,r4
00006c  ebac0c03          SUB      r12,r12,r3
000070  ebac0c02          SUB      r12,r12,r2
000074  fbbcf6f6          UDIV     r6,r12,r6
000078  fbb6fcf5          UDIV     r12,r6,r5
00007c  fb05651c          MLS      r5,r5,r12,r6
;;;485       misc = ((number-thousands-hundreds-tens-units)/10000);
000080  1b40              SUBS     r0,r0,r5
000082  1b00              SUBS     r0,r0,r4
000084  1ac0              SUBS     r0,r0,r3
000086  1a80              SUBS     r0,r0,r2
000088  fbb0f0f7          UDIV     r0,r0,r7
00008c  3230              ADDS     r2,r2,#0x30
;;;486     
;;;487       *(p_tab+4) = units + 0x30;
00008e  3330              ADDS     r3,r3,#0x30
000090  810a              STRH     r2,[r1,#8]
;;;488       *(p_tab+3) = tens + 0x30;
000092  3430              ADDS     r4,r4,#0x30
000094  80cb              STRH     r3,[r1,#6]
;;;489       *(p_tab+2) = hundreds + 0x30;
000096  3530              ADDS     r5,r5,#0x30
000098  808c              STRH     r4,[r1,#4]
;;;490       *(p_tab+1) = thousands + 0x30;
00009a  804d              STRH     r5,[r1,#2]
00009c  3030              ADDS     r0,r0,#0x30
;;;491       *(p_tab) = misc + 0x30;
00009e  8008              STRH     r0,[r1,#0]
;;;492    
;;;493    }
0000a0  bdf0              POP      {r4-r7,pc}
;;;494    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  GPIOA_MODER
                          DCD      0x00000000
                  GPIOB_MODER
                          DCD      0x00000000
                  GPIOC_MODER
                          DCD      0x00000000
                  GPIOD_MODER
                          DCD      0x00000000
                  GPIOA_PUPDR
                          DCD      0x00000000
                  GPIOB_PUPDR
                          DCD      0x00000000
                  GPIOC_PUPDR
                          DCD      0x00000000
                  GPIOD_PUPDR
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\src\\SYSTEM\\sys\\sys.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_sys_c_696cd8ce____REV16|
#line 114 "..\\..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___5_sys_c_696cd8ce____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_sys_c_696cd8ce____REVSH|
#line 128
|__asm___5_sys_c_696cd8ce____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |WFI_SET|
#line 150 "..\\src\\SYSTEM\\sys\\sys.c"
|WFI_SET| PROC
#line 151

 WFI
	ENDP

;*** End   embedded assembler ***
