; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm32l152-eval\hw_config.o --asm_dir=.\STM32L152-EVAL\ --list_dir=.\STM32L152-EVAL\ --depend=.\stm32l152-eval\hw_config.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32L1xx\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32L1xx_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM32L152_EVAL -I..\src\user -I..\src\user\include -I..\src\SYSTEM\delay -I..\src\SYSTEM\sys -I..\src\SYSTEM\usart -I..\src\HARDWARE\ADC -I..\src\HARDWARE\BMP -I..\src\HARDWARE\DMA -I..\src\HARDWARE\FLASH -I..\src\HARDWARE\GPS -I..\src\HARDWARE\KEY -I..\src\HARDWARE\PWM -I..\src\HARDWARE\RTC -I..\src\HARDWARE\SPI -I..\src\HARDWARE\USART2 -I..\src\HARDWARE\TIMER -I..\src\EX -I..\src\USMART -I..\..\..\Libraries\CMSIS\Include -I..\src\ff11a\src -I..\src\ff11a\src\option -I..\src\HARDWARE\LED -I..\src\HARDWARE\OLED -I..\src\ff11a\src -I..\src\ff11a\src\option -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.1.0\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32L1xx -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32L1XX_MD -DUSE_STM32L152_EVAL ..\src\hw_config.c]
                          THUMB

                          AREA ||i.Enter_LowPowerMode||, CODE, READONLY, ALIGN=2

                  Enter_LowPowerMode PROC
;;;175    *******************************************************************************/
;;;176    void Enter_LowPowerMode(void)
000000  4901              LDR      r1,|L1.8|
;;;177    {
;;;178      /* Set the device state to suspend */
;;;179      bDeviceState = SUSPENDED;
000002  2003              MOVS     r0,#3
000004  6008              STR      r0,[r1,#0]  ; bDeviceState
;;;180    }
000006  4770              BX       lr
;;;181    
                          ENDP

                  |L1.8|
                          DCD      bDeviceState

                          AREA ||i.Get_SerialNum||, CODE, READONLY, ALIGN=2

                  Get_SerialNum PROC
;;;350    *******************************************************************************/
;;;351    void Get_SerialNum(void)
000000  4809              LDR      r0,|L2.40|
;;;352    {
000002  b510              PUSH     {r4,lr}
;;;353      uint32_t Device_Serial0, Device_Serial1, Device_Serial2;
;;;354    
;;;355      Device_Serial0 = *(uint32_t*)ID1;
000004  e9d01414          LDRD     r1,r4,[r0,#0x50]
;;;356      Device_Serial1 = *(uint32_t*)ID2;
;;;357      Device_Serial2 = *(uint32_t*)ID3;
000008  6e40              LDR      r0,[r0,#0x64]
;;;358    
;;;359      Device_Serial0 += Device_Serial2;
00000a  1808              ADDS     r0,r1,r0
00000c  d00b              BEQ      |L2.38|
;;;360    
;;;361      if (Device_Serial0 != 0)
;;;362      {
;;;363        IntToUnicode (Device_Serial0, &MASS_StringSerial[2] , 8);
00000e  2208              MOVS     r2,#8
000010  4906              LDR      r1,|L2.44|
000012  f7fffffe          BL       IntToUnicode
;;;364        IntToUnicode (Device_Serial1, &MASS_StringSerial[18], 4);
000016  4905              LDR      r1,|L2.44|
000018  4620              MOV      r0,r4
00001a  2204              MOVS     r2,#4
00001c  e8bd4010          POP      {r4,lr}
000020  3110              ADDS     r1,r1,#0x10
000022  f7ffbffe          B.W      IntToUnicode
                  |L2.38|
;;;365      }
;;;366    
;;;367    }
000026  bd10              POP      {r4,pc}
;;;368    
                          ENDP

                  |L2.40|
                          DCD      0x1ff80000
                  |L2.44|
                          DCD      MASS_StringSerial+0x2

                          AREA ||i.IntToUnicode||, CODE, READONLY, ALIGN=2

                  IntToUnicode PROC
;;;375    *******************************************************************************/
;;;376    static void IntToUnicode (uint32_t value , uint8_t *pbuf , uint8_t len)
000000  b5f0              PUSH     {r4-r7,lr}
;;;377    {
;;;378      uint8_t idx = 0;
000002  2300              MOVS     r3,#0
;;;379      
;;;380      for( idx = 0 ; idx < len ; idx ++)
;;;381      {
;;;382        if( ((value >> 28)) < 0xA )
000004  240a              MOVS     r4,#0xa
;;;383        {
;;;384          pbuf[ 2* idx] = (value >> 28) + '0';
000006  2530              MOVS     r5,#0x30
;;;385        }
;;;386        else
;;;387        {
;;;388          pbuf[2* idx] = (value >> 28) + 'A' - 10; 
000008  2637              MOVS     r6,#0x37
00000a  461f              MOV      r7,r3
00000c  e011              B        |L3.50|
00000e  bf00              NOP                            ;382
                  |L3.16|
000010  ebb47f10          CMP      r4,r0,LSR #28         ;382
000014  d902              BLS      |L3.28|
000016  eb057c10          ADD      r12,r5,r0,LSR #28     ;384
00001a  e001              B        |L3.32|
                  |L3.28|
00001c  eb067c10          ADD      r12,r6,r0,LSR #28
                  |L3.32|
000020  f801c013          STRB     r12,[r1,r3,LSL #1]
;;;389        }
;;;390        
;;;391        value = value << 4;
;;;392        
;;;393        pbuf[ 2* idx + 1] = 0;
000024  eb010c43          ADD      r12,r1,r3,LSL #1
000028  0100              LSLS     r0,r0,#4              ;391
00002a  1c5b              ADDS     r3,r3,#1
00002c  f88c7001          STRB     r7,[r12,#1]
000030  b2db              UXTB     r3,r3                 ;380
                  |L3.50|
000032  4293              CMP      r3,r2                 ;380
000034  d3ec              BCC      |L3.16|
;;;394      }
;;;395    }
000036  bdf0              POP      {r4-r7,pc}
;;;396    
                          ENDP


                          AREA ||i.Leave_LowPowerMode||, CODE, READONLY, ALIGN=2

                  Leave_LowPowerMode PROC
;;;187    *******************************************************************************/
;;;188    void Leave_LowPowerMode(void)
000000  4804              LDR      r0,|L4.20|
;;;189    {
;;;190      DEVICE_INFO *pInfo = &Device_Info;
;;;191    
;;;192      /* Set the device state to the correct state */
;;;193      if (pInfo->Current_Configuration != 0)
000002  7a81              LDRB     r1,[r0,#0xa]
;;;194      {
;;;195        /* Device configured */
;;;196        bDeviceState = CONFIGURED;
000004  4804              LDR      r0,|L4.24|
000006  b109              CBZ      r1,|L4.12|
000008  2105              MOVS     r1,#5
00000a  e000              B        |L4.14|
                  |L4.12|
;;;197      }
;;;198      else
;;;199      {
;;;200        bDeviceState = ATTACHED;
00000c  2101              MOVS     r1,#1
                  |L4.14|
00000e  6001              STR      r1,[r0,#0]  ; bDeviceState
;;;201      }
;;;202      /*Enable SystemCoreClock*/
;;;203      SystemInit(); 
000010  f7ffbffe          B.W      SystemInit
;;;204    }
;;;205    
                          ENDP

                  |L4.20|
                          DCD      Device_Info
                  |L4.24|
                          DCD      bDeviceState

                          AREA ||i.MAL_Config||, CODE, READONLY, ALIGN=1

                  MAL_Config PROC
;;;402    *******************************************************************************/
;;;403    void MAL_Config(void)
000000  2000              MOVS     r0,#0
;;;404    {
;;;405      MAL_Init(0);
000002  f7ffbffe          B.W      MAL_Init
;;;406    
;;;407    #if defined(STM32F10X_HD) || defined(STM32F10X_XL)
;;;408      /* Enable the FSMC Clock */
;;;409      RCC_AHBPeriphClockCmd(RCC_AHBPeriph_FSMC, ENABLE);
;;;410      MAL_Init(1);
;;;411    #endif /* STM32F10X_HD | STM32F10X_XL */
;;;412    }
;;;413    
                          ENDP


                          AREA ||i.Set_System||, CODE, READONLY, ALIGN=2

                  Set_System PROC
;;;59     *******************************************************************************/
;;;60     void Set_System(void)
000000  b510              PUSH     {r4,lr}
;;;61     {
;;;62     #if defined (STM32F37X) || defined (STM32F30X)
;;;63       GPIO_InitTypeDef  GPIO_InitStructure;
;;;64     #endif /*STM32L1XX_XD */
;;;65       
;;;66     #if defined(USB_USE_EXTERNAL_PULLUP)
;;;67       GPIO_InitTypeDef  GPIO_InitStructure;
;;;68     #endif /* USB_USE_EXTERNAL_PULLUP */
;;;69       
;;;70       /*!< At this stage the microcontroller clock setting is already configured, 
;;;71            this is done through SystemInit() function which is called from startup
;;;72            file (startup_stm32xxx.s) before to branch to application main.
;;;73            To reconfigure the default setting of SystemInit() function, refer to
;;;74            system_stm32xxx.c file
;;;75          */ 
;;;76     #if defined(STM32L1XX_MD) || defined(STM32L1XX_HD)|| defined(STM32L1XX_MD_PLUS) || defined(STM32F37X) || defined(STM32F30X)
;;;77       /* Enable the SYSCFG module clock */
;;;78       RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
000002  2101              MOVS     r1,#1
000004  4608              MOV      r0,r1
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;79     #endif /* STM32L1XX_XD */ 
;;;80       
;;;81     #if !defined(STM32L1XX_MD) && !defined(STM32L1XX_HD) && !defined(STM32L1XX_MD_PLUS) && !defined(STM32F37X) && !defined(STM32F30X)
;;;82       /* Enable USB_DISCONNECT GPIO clock */
;;;83       RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIO_DISCONNECT, ENABLE);
;;;84     
;;;85       /* Configure USB pull-up pin */
;;;86       GPIO_InitStructure.GPIO_Pin = USB_DISCONNECT_PIN;
;;;87       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;88       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;
;;;89       GPIO_Init(USB_DISCONNECT, &GPIO_InitStructure);
;;;90     #endif /* STM32L1XX_MD && STM32L1XX_XD */
;;;91     
;;;92     #if !defined (USE_STM32L152_EVAL) 
;;;93       /* Enable and Disconnect Line GPIO clock */
;;;94       //USB_Disconnect_Config();
;;;95     #endif /* USE_STM32L152_EVAL */
;;;96     
;;;97     #if defined (STM32F37X) || defined(STM32F30X)
;;;98     
;;;99     	/* Enable the USB disconnect GPIO clock */
;;;100      RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIO_DISCONNECT, ENABLE);
;;;101    
;;;102     /*Set PA11,12 as IN - USB_DM,DP*/
;;;103      
;;;104      RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);
;;;105      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11 | GPIO_Pin_12;
;;;106      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;107      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
;;;108      GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
;;;109      GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
;;;110      GPIO_Init(GPIOA, &GPIO_InitStructure);
;;;111        
;;;112      /*SET PA11,12 for USB: USB_DM,DP*/
;;;113      GPIO_PinAFConfig(GPIOA, GPIO_PinSource11, GPIO_AF_14);
;;;114      GPIO_PinAFConfig(GPIOA, GPIO_PinSource12, GPIO_AF_14);
;;;115     
;;;116      /* USB_DISCONNECT used as USB pull-up */
;;;117      GPIO_InitStructure.GPIO_Pin = USB_DISCONNECT_PIN;
;;;118      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
;;;119      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
;;;120      GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
;;;121      GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
;;;122      GPIO_Init(USB_DISCONNECT, &GPIO_InitStructure); 
;;;123    #endif /* STM32F37X && STM32F30X */   
;;;124    
;;;125    #if defined(USB_USE_EXTERNAL_PULLUP)
;;;126      /* Enable the USB disconnect GPIO clock */
;;;127      RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIO_DISCONNECT, ENABLE);
;;;128    
;;;129      /* USB_DISCONNECT used as USB pull-up */
;;;130      GPIO_InitStructure.GPIO_Pin = USB_DISCONNECT_PIN;
;;;131      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
;;;132      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
;;;133      GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
;;;134      GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
;;;135      GPIO_Init(USB_DISCONNECT, &GPIO_InitStructure);  
;;;136    #endif /* USB_USE_EXTERNAL_PULLUP */  
;;;137      
;;;138          /* Configure the EXTI line 18 connected internally to the USB IP */
;;;139      EXTI_ClearITPendingBit(EXTI_Line18);
00000a  f44f2480          MOV      r4,#0x40000
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       EXTI_ClearITPendingBit
;;;140      EXTI_InitStructure.EXTI_Line = EXTI_Line18;
000014  4906              LDR      r1,|L6.48|
;;;141      EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
000016  2008              MOVS     r0,#8
000018  600c              STR      r4,[r1,#0]  ; EXTI_InitStructure
00001a  7148              STRB     r0,[r1,#5]
;;;142      EXTI_InitStructure.EXTI_LineCmd = ENABLE;
00001c  2001              MOVS     r0,#1
00001e  7188              STRB     r0,[r1,#6]
;;;143      EXTI_Init(&EXTI_InitStructure);
000020  4608              MOV      r0,r1
000022  f7fffffe          BL       EXTI_Init
000026  e8bd4010          POP      {r4,lr}
00002a  2000              MOVS     r0,#0
00002c  f7ffbffe          B.W      MAL_Init
;;;144      
;;;145      /* MAL configuration */
;;;146      MAL_Config();
;;;147    }
;;;148    
                          ENDP

                  |L6.48|
                          DCD      ||area_number.14||

                          AREA ||i.Set_USBClock||, CODE, READONLY, ALIGN=1

                  Set_USBClock PROC
;;;154    *******************************************************************************/
;;;155    void Set_USBClock(void)
000000  2101              MOVS     r1,#1
;;;156    {
;;;157    #if defined(STM32L1XX_MD) || defined(STM32L1XX_HD)|| defined(STM32L1XX_MD_PLUS)
;;;158      /* Enable USB clock */
;;;159      RCC_APB1PeriphClockCmd(RCC_APB1Periph_USB, ENABLE);
000002  05c8              LSLS     r0,r1,#23
000004  f7ffbffe          B.W      RCC_APB1PeriphClockCmd
;;;160      
;;;161    #else
;;;162      /* Select USBCLK source */
;;;163      RCC_USBCLKConfig(RCC_USBCLKSource_PLLCLK_1Div5);
;;;164      
;;;165      /* Enable the USB clock */
;;;166      RCC_APB1PeriphClockCmd(RCC_APB1Periph_USB, ENABLE);
;;;167    #endif /* STM32L1XX_XD */
;;;168    }
;;;169    
                          ENDP


                          AREA ||i.USB_Cable_Config||, CODE, READONLY, ALIGN=1

                  USB_Cable_Config PROC
;;;315    *******************************************************************************/
;;;316    void USB_Cable_Config (FunctionalState NewState)
000000  b100              CBZ      r0,|L8.4|
;;;317    {
;;;318    
;;;319    #if defined(STM32L1XX_MD)
;;;320    //  v1000_debug("USB_Cable_Config :%d \r\n",NewState);
;;;321      if (NewState != DISABLE)
;;;322      {
;;;323        STM32L15_USB_CONNECT;
000002  2001              MOVS     r0,#1
                  |L8.4|
;;;324      }
;;;325      else
;;;326      {
;;;327         STM32L15_USB_DISCONNECT;
000004  f7ffbffe          B.W      SYSCFG_USBPuCmd
;;;328      }  
;;;329     
;;;330    #elif defined(STM32L1XX_HD) || defined(STM32L1XX_MD_PLUS)
;;;331      if (NewState != DISABLE)
;;;332      {
;;;333        GPIO_ResetBits(USB_DISCONNECT, USB_DISCONNECT_PIN);
;;;334        SYSCFG_USBPuCmd(ENABLE);
;;;335      }
;;;336      else
;;;337      {
;;;338        GPIO_SetBits(USB_DISCONNECT, USB_DISCONNECT_PIN);
;;;339        SYSCFG_USBPuCmd(DISABLE);
;;;340      }
;;;341    #endif /* STM32L1XX_MD */
;;;342    }
;;;343    
                          ENDP


                          AREA ||i.USB_Interrupts_Config||, CODE, READONLY, ALIGN=1

                  USB_Interrupts_Config PROC
;;;247    *******************************************************************************/
;;;248    void USB_Interrupts_Config(void)
000000  b538              PUSH     {r3-r5,lr}
;;;249    {
;;;250      NVIC_InitTypeDef NVIC_InitStructure; 
;;;251      
;;;252      /* 2 bit for pre-emption priority, 2 bits for subpriority */
;;;253      NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);  
000002  f44f60a0          MOV      r0,#0x500
000006  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;254      
;;;255    #if defined(STM32L1XX_MD) || defined(STM32L1XX_HD)|| defined(STM32L1XX_MD_PLUS)
;;;256      NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQn;
00000a  2014              MOVS     r0,#0x14
00000c  f88d0000          STRB     r0,[sp,#0]
;;;257      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
000010  2002              MOVS     r0,#2
000012  f88d0001          STRB     r0,[sp,#1]
;;;258      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000016  2400              MOVS     r4,#0
000018  f88d4002          STRB     r4,[sp,#2]
;;;259      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00001c  2501              MOVS     r5,#1
00001e  f88d5003          STRB     r5,[sp,#3]
;;;260      NVIC_Init(&NVIC_InitStructure);
000022  4668              MOV      r0,sp
000024  f7fffffe          BL       NVIC_Init
;;;261      
;;;262        /* Enable the USB Wake-up interrupt */
;;;263      NVIC_InitStructure.NVIC_IRQChannel = USB_FS_WKUP_IRQn;
000028  202a              MOVS     r0,#0x2a
00002a  f88d0000          STRB     r0,[sp,#0]
;;;264      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
00002e  f88d4001          STRB     r4,[sp,#1]
;;;265      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000032  f88d5003          STRB     r5,[sp,#3]
;;;266      NVIC_Init(&NVIC_InitStructure);
000036  4668              MOV      r0,sp
000038  f7fffffe          BL       NVIC_Init
;;;267      
;;;268    #elif defined(STM32F37X)
;;;269      /* Enable the USB interrupt */
;;;270      NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQn;
;;;271      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
;;;272      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
;;;273      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;274      NVIC_Init(&NVIC_InitStructure);
;;;275      
;;;276      /* Enable the USB Wake-up interrupt */
;;;277      NVIC_InitStructure.NVIC_IRQChannel = USBWakeUp_IRQn;
;;;278      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
;;;279      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;280      NVIC_Init(&NVIC_InitStructure);
;;;281      
;;;282    #else
;;;283      NVIC_InitStructure.NVIC_IRQChannel = USB_LP_CAN1_RX0_IRQn;
;;;284      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
;;;285      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
;;;286      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;287      NVIC_Init(&NVIC_InitStructure);
;;;288      
;;;289        /* Enable the USB Wake-up interrupt */
;;;290      NVIC_InitStructure.NVIC_IRQChannel = USBWakeUp_IRQn;
;;;291      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
;;;292      NVIC_Init(&NVIC_InitStructure);
;;;293    #endif /* STM32L1XX_XD */
;;;294    
;;;295      
;;;296    #if 0//defined(STM32F10X_HD) || defined(STM32F10X_XL) || defined(STM32L1XX_HD)|| defined(STM32L1XX_MD_PLUS) 
;;;297      NVIC_InitStructure.NVIC_IRQChannel = SDIO_IRQn;
;;;298      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
;;;299      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
;;;300      NVIC_Init(&NVIC_InitStructure);
;;;301      NVIC_InitStructure.NVIC_IRQChannel = SD_SDIO_DMA_IRQn;
;;;302      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
;;;303      NVIC_Init(&NVIC_InitStructure);
;;;304    #endif /* STM32L1XX_MD */
;;;305     
;;;306    }
00003c  bd38              POP      {r3-r5,pc}
;;;307    
                          ENDP


                          AREA ||i.USB_Interrupts_Config_disable||, CODE, READONLY, ALIGN=1

                  USB_Interrupts_Config_disable PROC
;;;211    *******************************************************************************/
;;;212    void USB_Interrupts_Config_disable(void)
000000  b538              PUSH     {r3-r5,lr}
;;;213    {
;;;214    
;;;215    
;;;216      NVIC_InitTypeDef NVIC_InitStructure; 
;;;217    
;;;218      /* 2 bit for pre-emption priority, 2 bits for subpriority */
;;;219      NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);  
000002  f44f60a0          MOV      r0,#0x500
000006  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;220      
;;;221      NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQn;
00000a  2014              MOVS     r0,#0x14
00000c  f88d0000          STRB     r0,[sp,#0]
;;;222      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
000010  2002              MOVS     r0,#2
000012  f88d0001          STRB     r0,[sp,#1]
;;;223      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000016  2400              MOVS     r4,#0
000018  f88d4002          STRB     r4,[sp,#2]
;;;224      NVIC_InitStructure.NVIC_IRQChannelCmd = DISABLE;
00001c  f88d4003          STRB     r4,[sp,#3]
;;;225      NVIC_Init(&NVIC_InitStructure);
000020  4668              MOV      r0,sp
000022  f7fffffe          BL       NVIC_Init
;;;226      
;;;227        /* Enable the USB Wake-up interrupt */
;;;228      NVIC_InitStructure.NVIC_IRQChannel = USB_FS_WKUP_IRQn;
000026  202a              MOVS     r0,#0x2a
000028  f88d0000          STRB     r0,[sp,#0]
;;;229      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
00002c  f88d4001          STRB     r4,[sp,#1]
;;;230      NVIC_InitStructure.NVIC_IRQChannelCmd = DISABLE;
000030  f88d4003          STRB     r4,[sp,#3]
;;;231      NVIC_Init(&NVIC_InitStructure);
000034  4668              MOV      r0,sp
000036  f7fffffe          BL       NVIC_Init
;;;232      
;;;233    
;;;234    #if 0
;;;235      /* Enable USART Interrupt */
;;;236      NVIC_InitStructure.NVIC_IRQChannel = EVAL_COM1_IRQn;
;;;237      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
;;;238      NVIC_Init(&NVIC_InitStructure);
;;;239      #endif
;;;240    }
00003a  bd38              POP      {r3-r5,pc}
;;;241    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=0

                  HSEStartUpStatus
000000  00                DCB      0x00

                          AREA ||area_number.14||, DATA, ALIGN=2

                          EXPORTAS ||area_number.14||, ||.data||
                  EXTI_InitStructure
                          %        8

;*** Start embedded assembler ***

#line 1 "..\\src\\hw_config.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_hw_config_c_25f922fc____REV16|
#line 114 "..\\..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___11_hw_config_c_25f922fc____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_hw_config_c_25f922fc____REVSH|
#line 128
|__asm___11_hw_config_c_25f922fc____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
