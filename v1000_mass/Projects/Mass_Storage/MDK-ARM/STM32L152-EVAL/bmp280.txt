; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm32l152-eval\bmp280.o --asm_dir=.\STM32L152-EVAL\ --list_dir=.\STM32L152-EVAL\ --depend=.\stm32l152-eval\bmp280.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32L1xx\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32L1xx_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM32L152_EVAL -I..\src\user -I..\src\user\include -I..\src\SYSTEM\delay -I..\src\SYSTEM\sys -I..\src\SYSTEM\usart -I..\src\HARDWARE\ADC -I..\src\HARDWARE\BMP -I..\src\HARDWARE\DMA -I..\src\HARDWARE\FLASH -I..\src\HARDWARE\GPS -I..\src\HARDWARE\KEY -I..\src\HARDWARE\PWM -I..\src\HARDWARE\RTC -I..\src\HARDWARE\SPI -I..\src\HARDWARE\USART2 -I..\src\HARDWARE\TIMER -I..\src\EX -I..\src\USMART -I..\..\..\Libraries\CMSIS\Include -I..\src\ff11a\src -I..\src\ff11a\src\option -I..\src\HARDWARE\LED -I..\src\HARDWARE\OLED -I..\src\ff11a\src -I..\src\ff11a\src\option -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.1.0\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32L1xx -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32L1XX_MD -DUSE_STM32L152_EVAL ..\src\HARDWARE\BMP\bmp280.c]
                          THUMB

                          AREA ||i.bmp280_compute_meas_time||, CODE, READONLY, ALIGN=1

                  bmp280_compute_meas_time PROC
;;;628     */
;;;629    uint8_t bmp280_compute_meas_time(const struct bmp280_dev *dev)
000000  b570              PUSH     {r4-r6,lr}
;;;630    {
000002  4604              MOV      r4,r0
;;;631        uint32_t period = 0;
000004  2500              MOVS     r5,#0
;;;632        uint32_t t_dur = 0, p_dur = 0, p_startup = 0;
;;;633        const uint32_t startup = 1000, period_per_osrs = 2000; /* Typical timings in us. Maximum is +15% each */
000006  f44f767a          MOV      r6,#0x3e8
;;;634        int8_t rslt;
;;;635    
;;;636        rslt = null_ptr_check(dev);
00000a  f7fffffe          BL       null_ptr_check
;;;637        if (rslt == BMP280_OK)
00000e  b9a0              CBNZ     r0,|L1.58|
;;;638        {
;;;639            t_dur = period_per_osrs * ((UINT32_C(1) << dev->conf.os_temp) >> 1);
000010  f8140f2c          LDRB     r0,[r4,#0x2c]!
000014  2101              MOVS     r1,#1
000016  fa01f000          LSL      r0,r1,r0
00001a  0840              LSRS     r0,r0,#1
00001c  0072              LSLS     r2,r6,#1
00001e  4350              MULS     r0,r2,r0
;;;640            p_dur = period_per_osrs * ((UINT32_C(1) << dev->conf.os_pres) >> 1);
000020  7862              LDRB     r2,[r4,#1]
000022  4091              LSLS     r1,r1,r2
000024  0849              LSRS     r1,r1,#1
000026  0073              LSLS     r3,r6,#1
000028  4359              MULS     r1,r3,r1
;;;641            p_startup = (dev->conf.os_pres) ? 500 : 0;
00002a  b102              CBZ      r2,|L1.46|
00002c  109a              ASRS     r2,r3,#2
                  |L1.46|
;;;642    
;;;643            /* Increment the value to next highest integer if greater than 0.5 */
;;;644            period = startup + t_dur + p_startup + p_dur + 500;
00002e  4410              ADD      r0,r0,r2
000030  4408              ADD      r0,r0,r1
000032  f20050dc          ADD      r0,r0,#0x5dc
;;;645            period /= 1000; /* Convert to milliseconds */
000036  fbb0f5f6          UDIV     r5,r0,r6
                  |L1.58|
;;;646        }
;;;647    
;;;648        return (uint8_t)period;
00003a  b2e8              UXTB     r0,r5
;;;649    }
00003c  bd70              POP      {r4-r6,pc}
;;;650    
                          ENDP


                          AREA ||i.bmp280_get_comp_pres_32bit||, CODE, READONLY, ALIGN=2

                  bmp280_get_comp_pres_32bit PROC
;;;463     */
;;;464    int8_t bmp280_get_comp_pres_32bit(uint32_t *comp_pres, uint32_t uncomp_pres, const struct bmp280_dev *dev)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;465    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;466        int32_t var1, var2;
;;;467        int8_t rslt;
;;;468    
;;;469        rslt = null_ptr_check(dev);
00000a  4610              MOV      r0,r2
00000c  f7fffffe          BL       null_ptr_check
000010  0003              MOVS     r3,r0
;;;470        if (rslt == BMP280_OK)
000012  d176              BNE      |L2.258|
;;;471        {
;;;472            var1 = (((int32_t) dev->calib_param.t_fine) / 2) - (int32_t) 64000;
000014  6aa0              LDR      r0,[r4,#0x28]
000016  493c              LDR      r1,|L2.264|
000018  eb0070d0          ADD      r0,r0,r0,LSR #31
00001c  eb010160          ADD      r1,r1,r0,ASR #1
;;;473            var2 = (((var1 / 4) * (var1 / 4)) / 2048) * ((int32_t) dev->calib_param.dig_p6);
000020  17c8              ASRS     r0,r1,#31
000022  eb017090          ADD      r0,r1,r0,LSR #30
000026  1080              ASRS     r0,r0,#2
000028  4340              MULS     r0,r0,r0
00002a  ea4f7ce0          ASR      r12,r0,#31
00002e  eb00525c          ADD      r2,r0,r12,LSR #21
000032  f9b47020          LDRSH    r7,[r4,#0x20]
000036  12d2              ASRS     r2,r2,#11
000038  437a              MULS     r2,r7,r2
;;;474            var2 = var2 + ((var1 * ((int32_t) dev->calib_param.dig_p5)) * 2);
00003a  f9b4701e          LDRSH    r7,[r4,#0x1e]
;;;475            var2 = (var2 / 4) + (((int32_t) dev->calib_param.dig_p4) * 65536);
;;;476            var1 =
00003e  eb0040dc          ADD      r0,r0,r12,LSR #19
000042  434f              MULS     r7,r1,r7              ;474
000044  eb020247          ADD      r2,r2,r7,LSL #1       ;474
000048  17d7              ASRS     r7,r2,#31             ;475
00004a  eb027297          ADD      r2,r2,r7,LSR #30      ;475
00004e  8ba7              LDRH     r7,[r4,#0x1c]         ;475
000050  1092              ASRS     r2,r2,#2              ;475
000052  eb024207          ADD      r2,r2,r7,LSL #16      ;475
000056  f9b47018          LDRSH    r7,[r4,#0x18]
00005a  1340              ASRS     r0,r0,#13
00005c  434f              MULS     r7,r1,r7
00005e  f9b4101a          LDRSH    r1,[r4,#0x1a]
000062  4341              MULS     r1,r0,r1
000064  17c8              ASRS     r0,r1,#31
000066  eb017050          ADD      r0,r1,r0,LSR #29
00006a  10c0              ASRS     r0,r0,#3
00006c  eb0771d7          ADD      r1,r7,r7,LSR #31
000070  eb000061          ADD      r0,r0,r1,ASR #1
000074  f44f2180          MOV      r1,#0x40000
000078  fb90f1f1          SDIV     r1,r0,r1
;;;477                (((dev->calib_param.dig_p3 * (((var1 / 4) * (var1 / 4)) / 8192)) / 8) +
;;;478                 ((((int32_t) dev->calib_param.dig_p2) * var1) / 2)) / 262144;
;;;479            var1 = ((((32768 + var1)) * ((int32_t) dev->calib_param.dig_p1)) / 32768);
00007c  8ae0              LDRH     r0,[r4,#0x16]
00007e  f5014100          ADD      r1,r1,#0x8000
000082  4348              MULS     r0,r1,r0
000084  17c1              ASRS     r1,r0,#31
000086  eb004051          ADD      r0,r0,r1,LSR #17
00008a  13c1              ASRS     r1,r0,#15
;;;480            *comp_pres = (uint32_t)(((int32_t)(1048576 - uncomp_pres) - (var2 / 4096)) * 3125);
00008c  f5c61080          RSB      r0,r6,#0x100000
000090  ea4f76e2          ASR      r6,r2,#31
000094  eb025216          ADD      r2,r2,r6,LSR #20
000098  eba03022          SUB      r0,r0,r2,ASR #12
00009c  f6404235          MOV      r2,#0xc35
0000a0  fb00f002          MUL      r0,r0,r2
;;;481    
;;;482            /* Avoid exception caused by division with zero */
;;;483            if (var1 != 0)
0000a4  6028              STR      r0,[r5,#0]
0000a6  d028              BEQ      |L2.250|
;;;484            {
;;;485                /* Check for overflows against UINT32_MAX/2; if pres is left-shifted by 1 */
;;;486                if (*comp_pres < 0x80000000)
0000a8  f1b04f00          CMP      r0,#0x80000000
0000ac  d203              BCS      |L2.182|
;;;487                {
;;;488                    *comp_pres = (*comp_pres << 1) / ((uint32_t) var1);
0000ae  0040              LSLS     r0,r0,#1
0000b0  fbb0f0f1          UDIV     r0,r0,r1
0000b4  e002              B        |L2.188|
                  |L2.182|
;;;489                }
;;;490                else
;;;491                {
;;;492                    *comp_pres = (*comp_pres / (uint32_t) var1) * 2;
0000b6  fbb0f0f1          UDIV     r0,r0,r1
0000ba  0040              LSLS     r0,r0,#1
                  |L2.188|
;;;493                }
;;;494                var1 = (((int32_t) dev->calib_param.dig_p9) * ((int32_t) (((*comp_pres / 8) * (*comp_pres / 8)) / 8192))) /
0000bc  6028              STR      r0,[r5,#0]
0000be  4601              MOV      r1,r0
0000c0  08c0              LSRS     r0,r0,#3
0000c2  4340              MULS     r0,r0,r0
0000c4  f9b42026          LDRSH    r2,[r4,#0x26]
0000c8  0b40              LSRS     r0,r0,#13
0000ca  4350              MULS     r0,r2,r0
0000cc  17c2              ASRS     r2,r0,#31
0000ce  eb005012          ADD      r0,r0,r2,LSR #20
0000d2  1302              ASRS     r2,r0,#12
;;;495                       4096;
;;;496                var2 = (((int32_t) (*comp_pres / 4)) * ((int32_t) dev->calib_param.dig_p8)) / 8192;
0000d4  f9b46024          LDRSH    r6,[r4,#0x24]
0000d8  0888              LSRS     r0,r1,#2
0000da  4370              MULS     r0,r6,r0
0000dc  17c6              ASRS     r6,r0,#31
0000de  eb0040d6          ADD      r0,r0,r6,LSR #19
;;;497                *comp_pres = (uint32_t) ((int32_t) *comp_pres + ((var1 + var2 + dev->calib_param.dig_p7) / 16));
0000e2  f9b44022          LDRSH    r4,[r4,#0x22]
0000e6  eb023060          ADD      r0,r2,r0,ASR #13
0000ea  4420              ADD      r0,r0,r4
0000ec  17c2              ASRS     r2,r0,#31
0000ee  eb007012          ADD      r0,r0,r2,LSR #28
0000f2  eb011020          ADD      r0,r1,r0,ASR #4
0000f6  6028              STR      r0,[r5,#0]
0000f8  e003              B        |L2.258|
                  |L2.250|
;;;498                rslt = BMP280_OK;
;;;499            }
;;;500            else
;;;501            {
;;;502                *comp_pres = 0;
0000fa  2000              MOVS     r0,#0
;;;503                rslt = BMP280_E_32BIT_COMP_PRESS;
0000fc  f06f030e          MVN      r3,#0xe
000100  6028              STR      r0,[r5,#0]
                  |L2.258|
;;;504            }
;;;505        }
;;;506    
;;;507        return rslt;
000102  4618              MOV      r0,r3
;;;508    }
000104  e8bd81f0          POP      {r4-r8,pc}
;;;509    
                          ENDP

                  |L2.264|
                          DCD      0xffff0600

                          AREA ||i.bmp280_get_comp_pres_64bit||, CODE, READONLY, ALIGN=2

                  bmp280_get_comp_pres_64bit PROC
;;;515     */
;;;516    int8_t bmp280_get_comp_pres_64bit(uint32_t *pressure, uint32_t uncomp_pres, const struct bmp280_dev *dev)
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;517    {
000004  4683              MOV      r11,r0
000006  4614              MOV      r4,r2
;;;518        int64_t var1, var2, p;
;;;519        int8_t rslt;
;;;520    
;;;521        rslt = null_ptr_check(dev);
000008  4610              MOV      r0,r2
00000a  f7fffffe          BL       null_ptr_check
00000e  0007              MOVS     r7,r0
;;;522        if (rslt == BMP280_OK)
000010  d17e              BNE      |L3.272|
;;;523        {
;;;524            var1 = ((int64_t) (dev->calib_param.t_fine)) - 128000;
000012  6aa0              LDR      r0,[r4,#0x28]
000014  4a61              LDR      r2,|L3.412|
000016  17c1              ASRS     r1,r0,#31
000018  1885              ADDS     r5,r0,r2
00001a  f14136ff          ADC      r6,r1,#0xffffffff
00001e  fba50105          UMULL    r0,r1,r5,r5
;;;525            var2 = var1 * var1 * (int64_t) dev->calib_param.dig_p6;
000022  f9b42020          LDRSH    r2,[r4,#0x20]
000026  fb061105          MLA      r1,r6,r5,r1           ;524
00002a  fba09c02          UMULL    r9,r12,r0,r2
00002e  fb051806          MLA      r8,r5,r6,r1           ;524
000032  17d3              ASRS     r3,r2,#31
000034  fb08c202          MLA      r2,r8,r2,r12
000038  fb002a03          MLA      r10,r0,r3,r2
;;;526            var2 = var2 + ((var1 * (int64_t) dev->calib_param.dig_p5) * 131072);
00003c  f9b4101e          LDRSH    r1,[r4,#0x1e]
000040  fba13c05          UMULL    r3,r12,r1,r5
000044  17ca              ASRS     r2,r1,#31
000046  fb02c205          MLA      r2,r2,r5,r12
00004a  fb012106          MLA      r1,r1,r6,r2
00004e  044a              LSLS     r2,r1,#17
000050  ea4f4c43          LSL      r12,r3,#17
000054  ea4232d3          ORR      r2,r2,r3,LSR #15
000058  eb1c0109          ADDS     r1,r12,r9
00005c  eb42020a          ADC      r2,r2,r10
;;;527            var2 = var2 + (((int64_t) dev->calib_param.dig_p4) * 34359738368);
000060  46bc              MOV      r12,r7
000062  f9b4301c          LDRSH    r3,[r4,#0x1c]
000066  eb1c0a01          ADDS     r10,r12,r1
;;;528            var1 = ((var1 * var1 * (int64_t) dev->calib_param.dig_p3) / 256) +
00006a  f9b4101a          LDRSH    r1,[r4,#0x1a]
00006e  eb4209c3          ADC      r9,r2,r3,LSL #3       ;527
000072  fba0c301          UMULL    r12,r3,r0,r1
000076  ea4f72e1          ASR      r2,r1,#31
00007a  fb083101          MLA      r1,r8,r1,r3
00007e  fb001102          MLA      r1,r0,r2,r1
000082  4660              MOV      r0,r12
000084  f44f7280          MOV      r2,#0x100
000088  f04f0300          MOV      r3,#0
00008c  f7fffffe          BL       __aeabi_ldivmod
000090  f9b42018          LDRSH    r2,[r4,#0x18]
000094  fba2c805          UMULL    r12,r8,r2,r5
000098  17d3              ASRS     r3,r2,#31
00009a  fb038305          MLA      r3,r3,r5,r8
00009e  fb023206          MLA      r2,r2,r6,r3
0000a2  0312              LSLS     r2,r2,#12
0000a4  ea4f330c          LSL      r3,r12,#12
0000a8  ea42521c          ORR      r2,r2,r12,LSR #20
0000ac  18c0              ADDS     r0,r0,r3
0000ae  4151              ADCS     r1,r1,r2
0000b0  1c00              ADDS     r0,r0,#0
0000b2  f5414300          ADC      r3,r1,#0x8000
;;;529                   ((var1 * (int64_t) dev->calib_param.dig_p2) * 4096);
;;;530            var1 = ((INT64_C(0x800000000000) + var1) * ((int64_t)dev->calib_param.dig_p1)) / 8589934592;
0000b6  8ae1              LDRH     r1,[r4,#0x16]
0000b8  2200              MOVS     r2,#0
0000ba  fba05601          UMULL    r5,r6,r0,r1
0000be  fb036101          MLA      r1,r3,r1,r6
0000c2  fb001102          MLA      r1,r0,r2,r1
0000c6  2302              MOVS     r3,#2
0000c8  4628              MOV      r0,r5
0000ca  f7fffffe          BL       __aeabi_ldivmod
;;;531            if (var1 != 0)
0000ce  ea500201          ORRS     r2,r0,r1
0000d2  d05b              BEQ      |L3.396|
;;;532            {
;;;533                p = 1048576 - uncomp_pres;
0000d4  9a01              LDR      r2,[sp,#4]
;;;534                p = (((((p * 2147483648U)) - var2) * 3125) / var1);
0000d6  2500              MOVS     r5,#0
0000d8  f5c21380          RSB      r3,r2,#0x100000       ;533
0000dc  085a              LSRS     r2,r3,#1
0000de  07de              LSLS     r6,r3,#31
0000e0  ebb60c0a          SUBS     r12,r6,r10
0000e4  f6404335          MOV      r3,#0xc35
0000e8  fbac6803          UMULL    r6,r8,r12,r3
0000ec  eb620209          SBC      r2,r2,r9
0000f0  fb028203          MLA      r2,r2,r3,r8
0000f4  fb0c2505          MLA      r5,r12,r5,r2
0000f8  4602              MOV      r2,r0
0000fa  460b              MOV      r3,r1
0000fc  4630              MOV      r0,r6
0000fe  4629              MOV      r1,r5
000100  f7fffffe          BL       __aeabi_ldivmod
000104  4605              MOV      r5,r0
000106  460e              MOV      r6,r1
;;;535                var1 = (((int64_t) dev->calib_param.dig_p9) * (p / 8192) * (p / 8192)) / 33554432;
000108  f44f5200          MOV      r2,#0x2000
00010c  2300              MOVS     r3,#0
00010e  e000              B        |L3.274|
                  |L3.272|
000110  e041              B        |L3.406|
                  |L3.274|
000112  f7fffffe          BL       __aeabi_ldivmod
000116  f9b42026          LDRSH    r2,[r4,#0x26]
00011a  468a              MOV      r10,r1
00011c  fba03802          UMULL    r3,r8,r0,r2
000120  fb018102          MLA      r1,r1,r2,r8
000124  ea4f7ce2          ASR      r12,r2,#31
000128  fb00120c          MLA      r2,r0,r12,r1
00012c  4684              MOV      r12,r0
00012e  fba3080c          UMULL    r0,r8,r3,r12
000132  fb02820c          MLA      r2,r2,r12,r8
000136  fb03210a          MLA      r1,r3,r10,r2
00013a  f04f7200          MOV      r2,#0x2000000
00013e  2300              MOVS     r3,#0
000140  f7fffffe          BL       __aeabi_ldivmod
;;;536                var2 = (((int64_t) dev->calib_param.dig_p8) * p) / 524288;
000144  f9b42024          LDRSH    r2,[r4,#0x24]
000148  4681              MOV      r9,r0                 ;535
00014a  fba2c805          UMULL    r12,r8,r2,r5
00014e  17d3              ASRS     r3,r2,#31
000150  fb038005          MLA      r0,r3,r5,r8
000154  468a              MOV      r10,r1                ;535
000156  fb020106          MLA      r1,r2,r6,r0
00015a  f44f2200          MOV      r2,#0x80000
00015e  2300              MOVS     r3,#0
000160  4660              MOV      r0,r12
000162  f7fffffe          BL       __aeabi_ldivmod
000166  460b              MOV      r3,r1
000168  eb150209          ADDS     r2,r5,r9
00016c  eb46010a          ADC      r1,r6,r10
000170  1810              ADDS     r0,r2,r0
000172  4159              ADCS     r1,r1,r3
;;;537                p = ((p + var1 + var2) / 256) + (((int64_t)dev->calib_param.dig_p7) * 16);
000174  f44f7280          MOV      r2,#0x100
000178  2300              MOVS     r3,#0
00017a  f7fffffe          BL       __aeabi_ldivmod
00017e  f9b41022          LDRSH    r1,[r4,#0x22]
000182  0109              LSLS     r1,r1,#4
000184  1840              ADDS     r0,r0,r1
;;;538                *pressure = (uint32_t)p;
;;;539                rslt = BMP280_OK;
000186  f8cb0000          STR      r0,[r11,#0]
00018a  e004              B        |L3.406|
                  |L3.396|
;;;540            }
;;;541            else
;;;542            {
;;;543                *pressure = 0;
00018c  2000              MOVS     r0,#0
;;;544                rslt = BMP280_E_64BIT_COMP_PRESS;
00018e  f06f070f          MVN      r7,#0xf
000192  f8cb0000          STR      r0,[r11,#0]
                  |L3.406|
;;;545            }
;;;546        }
;;;547    
;;;548        return rslt;
000196  4638              MOV      r0,r7
;;;549    }
000198  e8bd8ffe          POP      {r1-r11,pc}
;;;550    
                          ENDP

                  |L3.412|
                          DCD      0xfffe0c00

                          AREA ||i.bmp280_get_comp_pres_double||, CODE, READONLY, ALIGN=2

                  bmp280_get_comp_pres_double PROC
;;;588     */
;;;589    int8_t bmp280_get_comp_pres_double(double *pressure, uint32_t uncomp_pres, const struct bmp280_dev *dev)
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;590    {
000004  4606              MOV      r6,r0
000006  b082              SUB      sp,sp,#8
000008  4614              MOV      r4,r2
;;;591        double var1, var2;
;;;592        int8_t rslt;
;;;593    
;;;594        rslt = null_ptr_check(dev);
00000a  4610              MOV      r0,r2
00000c  f7fffffe          BL       null_ptr_check
000010  ea5f0800          MOVS     r8,r0
;;;595        if (rslt == BMP280_OK)
000014  d17e              BNE      |L4.276|
;;;596        {
;;;597            var1 = ((double) dev->calib_param.t_fine / 2.0) - 64000.0;
000016  6aa0              LDR      r0,[r4,#0x28]
000018  f7fffffe          BL       __aeabi_i2d
00001c  f04f32ff          MOV      r2,#0xffffffff
000020  f7fffffe          BL       __ARM_scalbn
000024  2200              MOVS     r2,#0
000026  4b76              LDR      r3,|L4.512|
000028  f7fffffe          BL       __aeabi_dsub
00002c  4605              MOV      r5,r0
00002e  460f              MOV      r7,r1
;;;598            var2 = var1 * var1 * ((double) dev->calib_param.dig_p6) / 32768.0;
000030  f9b40020          LDRSH    r0,[r4,#0x20]
000034  f7fffffe          BL       __aeabi_i2d
000038  4682              MOV      r10,r0
00003a  4689              MOV      r9,r1
00003c  462a              MOV      r2,r5
00003e  463b              MOV      r3,r7
000040  4610              MOV      r0,r2
000042  4619              MOV      r1,r3
000044  f7fffffe          BL       __aeabi_dmul
000048  4652              MOV      r2,r10
00004a  464b              MOV      r3,r9
00004c  f7fffffe          BL       __aeabi_dmul
000050  f06f020e          MVN      r2,#0xe
000054  f7fffffe          BL       __ARM_scalbn
000058  4681              MOV      r9,r0
00005a  468a              MOV      r10,r1
;;;599            var2 = var2 + var1 * ((double) dev->calib_param.dig_p5) * 2.0;
00005c  f9b4001e          LDRSH    r0,[r4,#0x1e]
000060  f7fffffe          BL       __aeabi_i2d
000064  462a              MOV      r2,r5
000066  463b              MOV      r3,r7
000068  f7fffffe          BL       __aeabi_dmul
00006c  2201              MOVS     r2,#1
00006e  f7fffffe          BL       __ARM_scalbn
000072  464a              MOV      r2,r9
000074  4653              MOV      r3,r10
000076  f7fffffe          BL       __aeabi_dadd
00007a  4683              MOV      r11,r0
;;;600            var2 = (var2 / 4.0) + (((double) dev->calib_param.dig_p4) * 65536.0);
00007c  9100              STR      r1,[sp,#0]
00007e  f9b4001c          LDRSH    r0,[r4,#0x1c]
000082  f7fffffe          BL       __aeabi_i2d
000086  2210              MOVS     r2,#0x10
000088  f7fffffe          BL       __ARM_scalbn
00008c  4681              MOV      r9,r0
00008e  468a              MOV      r10,r1
000090  f06f0201          MVN      r2,#1
000094  4658              MOV      r0,r11
000096  9900              LDR      r1,[sp,#0]
000098  f7fffffe          BL       __ARM_scalbn
00009c  464a              MOV      r2,r9
00009e  4653              MOV      r3,r10
0000a0  f7fffffe          BL       __aeabi_dadd
0000a4  4683              MOV      r11,r0
;;;601            var1 = (((double)dev->calib_param.dig_p3) * var1 * var1 / 524288.0 + ((double)dev->calib_param.dig_p2) * var1) /
0000a6  9100              STR      r1,[sp,#0]
0000a8  f9b40018          LDRSH    r0,[r4,#0x18]
0000ac  f7fffffe          BL       __aeabi_i2d
0000b0  462a              MOV      r2,r5
0000b2  463b              MOV      r3,r7
0000b4  f7fffffe          BL       __aeabi_dmul
0000b8  4681              MOV      r9,r0
0000ba  468a              MOV      r10,r1
0000bc  f9b4001a          LDRSH    r0,[r4,#0x1a]
0000c0  f7fffffe          BL       __aeabi_i2d
0000c4  462a              MOV      r2,r5
0000c6  463b              MOV      r3,r7
0000c8  f7fffffe          BL       __aeabi_dmul
0000cc  462a              MOV      r2,r5
0000ce  463b              MOV      r3,r7
0000d0  f7fffffe          BL       __aeabi_dmul
0000d4  f06f0512          MVN      r5,#0x12
0000d8  462a              MOV      r2,r5
0000da  f7fffffe          BL       __ARM_scalbn
0000de  464a              MOV      r2,r9
0000e0  4653              MOV      r3,r10
0000e2  f7fffffe          BL       __aeabi_dadd
0000e6  462a              MOV      r2,r5
0000e8  f7fffffe          BL       __ARM_scalbn
0000ec  4607              MOV      r7,r0
0000ee  468a              MOV      r10,r1
;;;602                   524288.0;
;;;603            var1 = (1.0 + var1 / 32768.0) * ((double) dev->calib_param.dig_p1);
0000f0  8ae0              LDRH     r0,[r4,#0x16]
0000f2  f7fffffe          BL       __aeabi_ui2d
0000f6  4605              MOV      r5,r0
0000f8  4689              MOV      r9,r1
0000fa  f06f020e          MVN      r2,#0xe
0000fe  4638              MOV      r0,r7
000100  4651              MOV      r1,r10
000102  f7fffffe          BL       __ARM_scalbn
000106  2200              MOVS     r2,#0
000108  4b3e              LDR      r3,|L4.516|
00010a  f7fffffe          BL       __aeabi_dadd
00010e  462a              MOV      r2,r5
000110  464b              MOV      r3,r9
000112  e000              B        |L4.278|
                  |L4.276|
000114  e070              B        |L4.504|
                  |L4.278|
000116  f7fffffe          BL       __aeabi_dmul
00011a  4605              MOV      r5,r0
00011c  460f              MOV      r7,r1
;;;604    
;;;605            *pressure = 1048576.0 - (double)uncomp_pres;
00011e  9803              LDR      r0,[sp,#0xc]
000120  f7fffffe          BL       __aeabi_ui2d
000124  2200              MOVS     r2,#0
000126  4b38              LDR      r3,|L4.520|
000128  f7fffffe          BL       __aeabi_drsub
;;;606            if (var1 < 0 || var1 > 0)
00012c  e9c60100          STRD     r0,r1,[r6,#0]
000130  2200              MOVS     r2,#0
000132  4613              MOV      r3,r2
000134  4628              MOV      r0,r5
000136  4639              MOV      r1,r7
000138  f7fffffe          BL       __aeabi_cdcmple
00013c  d306              BCC      |L4.332|
00013e  2200              MOVS     r2,#0
000140  4613              MOV      r3,r2
000142  4628              MOV      r0,r5
000144  4639              MOV      r1,r7
000146  f7fffffe          BL       __aeabi_cdrcmple
00014a  d250              BCS      |L4.494|
                  |L4.332|
;;;607            {
;;;608                *pressure = (*pressure - (var2 / 4096.0)) * 6250.0 / var1;
00014c  f06f020b          MVN      r2,#0xb
000150  4658              MOV      r0,r11
000152  9900              LDR      r1,[sp,#0]
000154  f7fffffe          BL       __ARM_scalbn
000158  e9d62300          LDRD     r2,r3,[r6,#0]
00015c  f7fffffe          BL       __aeabi_drsub
000160  2200              MOVS     r2,#0
000162  4b2a              LDR      r3,|L4.524|
000164  f7fffffe          BL       __aeabi_dmul
000168  462a              MOV      r2,r5
00016a  463b              MOV      r3,r7
00016c  f7fffffe          BL       __aeabi_ddiv
000170  e9c60100          STRD     r0,r1,[r6,#0]
000174  4607              MOV      r7,r0
000176  460d              MOV      r5,r1
;;;609                var1 = ((double)dev->calib_param.dig_p9) * (*pressure) * (*pressure) / 2147483648.0;
000178  f9b40026          LDRSH    r0,[r4,#0x26]
00017c  f7fffffe          BL       __aeabi_i2d
000180  463a              MOV      r2,r7
000182  462b              MOV      r3,r5
000184  f7fffffe          BL       __aeabi_dmul
000188  463a              MOV      r2,r7
00018a  462b              MOV      r3,r5
00018c  f7fffffe          BL       __aeabi_dmul
000190  f06f021e          MVN      r2,#0x1e
000194  f7fffffe          BL       __ARM_scalbn
000198  4683              MOV      r11,r0
;;;610                var2 = (*pressure) * ((double)dev->calib_param.dig_p8) / 32768.0;
00019a  9100              STR      r1,[sp,#0]
00019c  f9b40024          LDRSH    r0,[r4,#0x24]
0001a0  f7fffffe          BL       __aeabi_i2d
0001a4  463a              MOV      r2,r7
0001a6  462b              MOV      r3,r5
0001a8  f7fffffe          BL       __aeabi_dmul
0001ac  f06f020e          MVN      r2,#0xe
0001b0  f7fffffe          BL       __ARM_scalbn
0001b4  4682              MOV      r10,r0
;;;611                *pressure = *pressure + (var1 + var2 + ((double)dev->calib_param.dig_p7)) / 16.0;
0001b6  9101              STR      r1,[sp,#4]
0001b8  f9b40022          LDRSH    r0,[r4,#0x22]
0001bc  f7fffffe          BL       __aeabi_i2d
0001c0  4689              MOV      r9,r1
0001c2  e9dd1300          LDRD     r1,r3,[sp,#0]
0001c6  4604              MOV      r4,r0
0001c8  4652              MOV      r2,r10
0001ca  4658              MOV      r0,r11
0001cc  f7fffffe          BL       __aeabi_dadd
0001d0  4622              MOV      r2,r4
0001d2  464b              MOV      r3,r9
0001d4  f7fffffe          BL       __aeabi_dadd
0001d8  f06f0203          MVN      r2,#3
0001dc  f7fffffe          BL       __ARM_scalbn
0001e0  463a              MOV      r2,r7
0001e2  462b              MOV      r3,r5
0001e4  f7fffffe          BL       __aeabi_dadd
0001e8  e9c60100          STRD     r0,r1,[r6,#0]
0001ec  e004              B        |L4.504|
                  |L4.494|
0001ee  2000              MOVS     r0,#0
0001f0  e9c60000          STRD     r0,r0,[r6,#0]
;;;612            }
;;;613            else
;;;614            {
;;;615                *pressure = 0;
;;;616                rslt = BMP280_E_DOUBLE_COMP_PRESS;
0001f4  f06f0811          MVN      r8,#0x11
                  |L4.504|
;;;617            }
;;;618        }
;;;619    
;;;620        return rslt;
;;;621    }
0001f8  b005              ADD      sp,sp,#0x14
0001fa  4640              MOV      r0,r8                 ;620
0001fc  e8bd8ff0          POP      {r4-r11,pc}
;;;622    
                          ENDP

                  |L4.512|
                          DCD      0x40ef4000
                  |L4.516|
                          DCD      0x3ff00000
                  |L4.520|
                          DCD      0x41300000
                  |L4.524|
                          DCD      0x40b86a00

                          AREA ||i.bmp280_get_comp_temp_32bit||, CODE, READONLY, ALIGN=1

                  bmp280_get_comp_temp_32bit PROC
;;;430     */
;;;431    int8_t bmp280_get_comp_temp_32bit(int32_t *comp_temp, int32_t uncomp_temp, struct bmp280_dev *dev)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;432    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;433        int32_t var1, var2;
;;;434        int8_t rslt;
;;;435    
;;;436        rslt = null_ptr_check(dev);
00000a  4610              MOV      r0,r2
00000c  f7fffffe          BL       null_ptr_check
000010  0001              MOVS     r1,r0
;;;437        if (rslt == BMP280_OK)
000012  d006              BEQ      |L5.34|
;;;438        {
;;;439            var1 =
;;;440                ((((uncomp_temp / 8) - ((int32_t) dev->calib_param.dig_t1 << 1))) * ((int32_t) dev->calib_param.dig_t2)) /
;;;441                2048;
;;;442            var2 =
;;;443                (((((uncomp_temp / 16) - ((int32_t) dev->calib_param.dig_t1)) *
;;;444                   ((uncomp_temp / 16) - ((int32_t) dev->calib_param.dig_t1))) / 4096) *
;;;445                 ((int32_t) dev->calib_param.dig_t3)) /
;;;446                16384;
;;;447            dev->calib_param.t_fine = var1 + var2;
;;;448            *comp_temp = (dev->calib_param.t_fine * 5 + 128) / 256;
;;;449            rslt = BMP280_OK;
;;;450        }
;;;451        else
;;;452        {
;;;453            *comp_temp = 0;
000014  2000              MOVS     r0,#0
;;;454            rslt = BMP280_E_32BIT_COMP_TEMP;
000016  f06f010d          MVN      r1,#0xd
00001a  6030              STR      r0,[r6,#0]
                  |L5.28|
;;;455        }
;;;456    
;;;457        return rslt;
00001c  4608              MOV      r0,r1
;;;458    }
00001e  e8bd81f0          POP      {r4-r8,pc}
                  |L5.34|
000022  17e2              ASRS     r2,r4,#31             ;439
000024  eb047052          ADD      r0,r4,r2,LSR #29      ;439
000028  8a2f              LDRH     r7,[r5,#0x10]         ;439
00002a  10c0              ASRS     r0,r0,#3              ;439
00002c  f9b53012          LDRSH    r3,[r5,#0x12]         ;439
000030  eba00047          SUB      r0,r0,r7,LSL #1       ;439
000034  4358              MULS     r0,r3,r0              ;439
000036  17c3              ASRS     r3,r0,#31             ;439
000038  eb005053          ADD      r0,r0,r3,LSR #21      ;439
00003c  12c3              ASRS     r3,r0,#11             ;439
00003e  eb047012          ADD      r0,r4,r2,LSR #28      ;442
000042  ebc71020          RSB      r0,r7,r0,ASR #4       ;442
000046  4340              MULS     r0,r0,r0              ;442
000048  17c2              ASRS     r2,r0,#31             ;442
00004a  eb005012          ADD      r0,r0,r2,LSR #20      ;442
00004e  f9b52014          LDRSH    r2,[r5,#0x14]         ;442
000052  1300              ASRS     r0,r0,#12             ;442
000054  4350              MULS     r0,r2,r0              ;442
000056  17c2              ASRS     r2,r0,#31             ;442
000058  eb004092          ADD      r0,r0,r2,LSR #18      ;442
00005c  eb0330a0          ADD      r0,r3,r0,ASR #14      ;447
000060  62a8              STR      r0,[r5,#0x28]         ;448
000062  eb000080          ADD      r0,r0,r0,LSL #2       ;448
000066  3080              ADDS     r0,r0,#0x80           ;448
000068  17c2              ASRS     r2,r0,#31             ;448
00006a  eb006012          ADD      r0,r0,r2,LSR #24      ;448
00006e  1200              ASRS     r0,r0,#8              ;448
000070  6030              STR      r0,[r6,#0]            ;449
000072  e7d3              B        |L5.28|
;;;459    
                          ENDP


                          AREA ||i.bmp280_get_comp_temp_double||, CODE, READONLY, ALIGN=2

                  bmp280_get_comp_temp_double PROC
;;;558     */
;;;559    int8_t bmp280_get_comp_temp_double(double *temperature, int32_t uncomp_temp, struct bmp280_dev *dev)
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;560    {
000004  b084              SUB      sp,sp,#0x10
000006  4614              MOV      r4,r2
000008  460e              MOV      r6,r1
;;;561        double var1, var2;
;;;562        int8_t rslt;
;;;563    
;;;564        rslt = null_ptr_check(dev);
00000a  4610              MOV      r0,r2
00000c  f7fffffe          BL       null_ptr_check
000010  0005              MOVS     r5,r0
;;;565        if (rslt == BMP280_OK)
000012  d009              BEQ      |L6.40|
;;;566        {
;;;567            var1 = (((double) uncomp_temp) / 16384.0 - ((double) dev->calib_param.dig_t1) / 1024.0) *
;;;568                   ((double) dev->calib_param.dig_t2);
;;;569            var2 =
;;;570                ((((double) uncomp_temp) / 131072.0 - ((double) dev->calib_param.dig_t1) / 8192.0) *
;;;571                 (((double) uncomp_temp) / 131072.0 - ((double) dev->calib_param.dig_t1) / 8192.0)) *
;;;572                ((double) dev->calib_param.dig_t3);
;;;573            dev->calib_param.t_fine = (int32_t) (var1 + var2);
;;;574            *temperature = ((var1 + var2) / 5120.0);
;;;575        }
;;;576        else
;;;577        {
;;;578            *temperature = 0;
000014  9804              LDR      r0,[sp,#0x10]
000016  2100              MOVS     r1,#0                 ;565
;;;579            rslt = BMP280_E_DOUBLE_COMP_TEMP;
000018  f06f0510          MVN      r5,#0x10
00001c  e9c01100          STRD     r1,r1,[r0,#0]         ;578
                  |L6.32|
;;;580        }
;;;581    
;;;582        return rslt;
;;;583    }
000020  b007              ADD      sp,sp,#0x1c
000022  4628              MOV      r0,r5                 ;582
000024  e8bd8ff0          POP      {r4-r11,pc}
                  |L6.40|
000028  f9b40012          LDRSH    r0,[r4,#0x12]         ;567
00002c  f7fffffe          BL       __aeabi_i2d
000030  4683              MOV      r11,r0                ;567
000032  4689              MOV      r9,r1                 ;567
000034  8a20              LDRH     r0,[r4,#0x10]         ;567
000036  f7fffffe          BL       __aeabi_ui2d
00003a  4607              MOV      r7,r0                 ;567
00003c  f06f0209          MVN      r2,#9                 ;567
000040  9102              STR      r1,[sp,#8]            ;567
000042  f7fffffe          BL       __ARM_scalbn
000046  4680              MOV      r8,r0                 ;567
000048  468a              MOV      r10,r1                ;567
00004a  4630              MOV      r0,r6                 ;567
00004c  f7fffffe          BL       __aeabi_i2d
000050  4606              MOV      r6,r0                 ;567
000052  f06f020d          MVN      r2,#0xd               ;567
000056  9101              STR      r1,[sp,#4]            ;567
000058  f7fffffe          BL       __ARM_scalbn
00005c  4642              MOV      r2,r8                 ;567
00005e  4653              MOV      r3,r10                ;567
000060  f7fffffe          BL       __aeabi_dsub
000064  465a              MOV      r2,r11                ;567
000066  464b              MOV      r3,r9                 ;567
000068  f7fffffe          BL       __aeabi_dmul
00006c  4683              MOV      r11,r0                ;567
00006e  9100              STR      r1,[sp,#0]            ;569
000070  f9b40014          LDRSH    r0,[r4,#0x14]         ;569
000074  f7fffffe          BL       __aeabi_i2d
000078  4682              MOV      r10,r0                ;569
00007a  4689              MOV      r9,r1                 ;569
00007c  4638              MOV      r0,r7                 ;569
00007e  f06f020c          MVN      r2,#0xc               ;569
000082  9902              LDR      r1,[sp,#8]            ;569
000084  f7fffffe          BL       __ARM_scalbn
000088  4607              MOV      r7,r0                 ;569
00008a  4688              MOV      r8,r1                 ;569
00008c  4630              MOV      r0,r6                 ;569
00008e  f06f0210          MVN      r2,#0x10              ;569
000092  9901              LDR      r1,[sp,#4]            ;569
000094  f7fffffe          BL       __ARM_scalbn
000098  463a              MOV      r2,r7                 ;569
00009a  4643              MOV      r3,r8                 ;569
00009c  f7fffffe          BL       __aeabi_dsub
0000a0  4602              MOV      r2,r0                 ;569
0000a2  460b              MOV      r3,r1                 ;569
0000a4  f7fffffe          BL       __aeabi_dmul
0000a8  4652              MOV      r2,r10                ;569
0000aa  464b              MOV      r3,r9                 ;569
0000ac  f7fffffe          BL       __aeabi_dmul
0000b0  4602              MOV      r2,r0                 ;573
0000b2  460b              MOV      r3,r1                 ;573
0000b4  4658              MOV      r0,r11                ;573
0000b6  9900              LDR      r1,[sp,#0]            ;573
0000b8  f7fffffe          BL       __aeabi_dadd
0000bc  460f              MOV      r7,r1                 ;573
0000be  4606              MOV      r6,r0                 ;573
0000c0  f7fffffe          BL       __aeabi_d2iz
0000c4  62a0              STR      r0,[r4,#0x28]         ;573
0000c6  4630              MOV      r0,r6                 ;573
0000c8  4639              MOV      r1,r7                 ;573
0000ca  2200              MOVS     r2,#0                 ;574
0000cc  4b03              LDR      r3,|L6.220|
0000ce  f7fffffe          BL       __aeabi_ddiv
0000d2  9a04              LDR      r2,[sp,#0x10]         ;574
0000d4  e9c20100          STRD     r0,r1,[r2,#0]         ;574
0000d8  e7a2              B        |L6.32|
;;;584    
                          ENDP

0000da  0000              DCW      0x0000
                  |L6.220|
                          DCD      0x40b40000

                          AREA ||i.bmp280_get_config||, CODE, READONLY, ALIGN=1

                  bmp280_get_config PROC
;;;288     */
;;;289    int8_t bmp280_get_config(struct bmp280_config *conf, struct bmp280_dev *dev)
000000  b538              PUSH     {r3-r5,lr}
;;;290    {
000002  4604              MOV      r4,r0
;;;291        int8_t rslt;
;;;292        uint8_t temp[2] = { 0, 0 };
000004  2000              MOVS     r0,#0
;;;293    
;;;294        rslt = null_ptr_check(dev);
000006  9000              STR      r0,[sp,#0]
000008  460d              MOV      r5,r1                 ;290
00000a  4608              MOV      r0,r1
00000c  f7fffffe          BL       null_ptr_check
;;;295        if ((rslt == BMP280_OK) && (conf != NULL))
000010  bb28              CBNZ     r0,|L7.94|
000012  b324              CBZ      r4,|L7.94|
;;;296        {
;;;297            rslt = bmp280_get_regs(BMP280_CTRL_MEAS_ADDR, temp, 2, dev);
000014  462b              MOV      r3,r5
000016  2202              MOVS     r2,#2
000018  4669              MOV      r1,sp
00001a  20f4              MOVS     r0,#0xf4
00001c  f7fffffe          BL       bmp280_get_regs
;;;298            if (rslt == BMP280_OK)
000020  2800              CMP      r0,#0
000022  d11b              BNE      |L7.92|
;;;299            {
;;;300                conf->os_temp = BMP280_GET_BITS(BMP280_OS_TEMP, temp[0]);
000024  f89d1000          LDRB     r1,[sp,#0]
000028  0949              LSRS     r1,r1,#5
00002a  7021              STRB     r1,[r4,#0]
;;;301                conf->os_pres = BMP280_GET_BITS(BMP280_OS_PRES, temp[0]);
00002c  f89d1000          LDRB     r1,[sp,#0]
000030  f3c10182          UBFX     r1,r1,#2,#3
000034  7061              STRB     r1,[r4,#1]
;;;302                conf->odr = BMP280_GET_BITS(BMP280_STANDBY_DURN, temp[1]);
000036  f89d1001          LDRB     r1,[sp,#1]
00003a  0949              LSRS     r1,r1,#5
00003c  70a1              STRB     r1,[r4,#2]
;;;303                conf->filter = BMP280_GET_BITS(BMP280_FILTER, temp[1]);
00003e  f89d1001          LDRB     r1,[sp,#1]
000042  f3c10182          UBFX     r1,r1,#2,#3
000046  70e1              STRB     r1,[r4,#3]
;;;304                conf->spi3w_en = BMP280_GET_BITS_POS_0(BMP280_SPI3_ENABLE, temp[1]);
000048  f89d1001          LDRB     r1,[sp,#1]
00004c  f0010101          AND      r1,r1,#1
000050  7121              STRB     r1,[r4,#4]
;;;305                dev->conf = *conf;
000052  6821              LDR      r1,[r4,#0]
000054  62e9              STR      r1,[r5,#0x2c]
000056  7921              LDRB     r1,[r4,#4]
000058  f8851030          STRB     r1,[r5,#0x30]
                  |L7.92|
;;;306            }
;;;307        }
;;;308        else
;;;309        {
;;;310            rslt = BMP280_E_NULL_PTR;
;;;311        }
;;;312    
;;;313        return rslt;
;;;314    }
00005c  bd38              POP      {r3-r5,pc}
                  |L7.94|
00005e  f04f30ff          MOV      r0,#0xffffffff        ;310
000062  bd38              POP      {r3-r5,pc}
;;;315    
                          ENDP


                          AREA ||i.bmp280_get_power_mode||, CODE, READONLY, ALIGN=1

                  bmp280_get_power_mode PROC
;;;351     */
;;;352    int8_t bmp280_get_power_mode(uint8_t *mode, const struct bmp280_dev *dev)
000000  b538              PUSH     {r3-r5,lr}
;;;353    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;354        int8_t rslt;
;;;355        uint8_t temp;
;;;356    
;;;357        rslt = null_ptr_check(dev);
000006  4608              MOV      r0,r1
000008  f7fffffe          BL       null_ptr_check
;;;358        if ((rslt == BMP280_OK) && (mode != NULL))
00000c  b960              CBNZ     r0,|L8.40|
00000e  b15c              CBZ      r4,|L8.40|
;;;359        {
;;;360            rslt = bmp280_get_regs(BMP280_CTRL_MEAS_ADDR, &temp, 1, dev);
000010  462b              MOV      r3,r5
000012  2201              MOVS     r2,#1
000014  4669              MOV      r1,sp
000016  20f4              MOVS     r0,#0xf4
000018  f7fffffe          BL       bmp280_get_regs
;;;361            *mode = BMP280_GET_BITS_POS_0(BMP280_POWER_MODE, temp);
00001c  f89d1000          LDRB     r1,[sp,#0]
000020  f0010103          AND      r1,r1,#3
000024  7021              STRB     r1,[r4,#0]
;;;362        }
;;;363        else
;;;364        {
;;;365            rslt = BMP280_E_NULL_PTR;
;;;366        }
;;;367    
;;;368        return rslt;
;;;369    }
000026  bd38              POP      {r3-r5,pc}
                  |L8.40|
000028  f04f30ff          MOV      r0,#0xffffffff        ;365
00002c  bd38              POP      {r3-r5,pc}
;;;370    
                          ENDP


                          AREA ||i.bmp280_get_regs||, CODE, READONLY, ALIGN=1

                  bmp280_get_regs PROC
;;;113     */
;;;114    int8_t bmp280_get_regs(uint8_t reg_addr, uint8_t *reg_data, uint8_t len, const struct bmp280_dev *dev)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;115    {
000004  4605              MOV      r5,r0
000006  4617              MOV      r7,r2
000008  460e              MOV      r6,r1
00000a  461c              MOV      r4,r3
;;;116        int8_t rslt;
;;;117    
;;;118        rslt = null_ptr_check(dev);
00000c  4618              MOV      r0,r3
00000e  f7fffffe          BL       null_ptr_check
;;;119        if ((rslt == BMP280_OK) && (reg_data != NULL))
000012  b980              CBNZ     r0,|L9.54|
000014  b17e              CBZ      r6,|L9.54|
;;;120        {
;;;121            /* Mask the register address' MSB if interface selected is SPI */
;;;122            if (dev->intf == BMP280_SPI_INTF)
000016  78a0              LDRB     r0,[r4,#2]
000018  b908              CBNZ     r0,|L9.30|
;;;123            {
;;;124                reg_addr = reg_addr | 0x80;
00001a  f0450580          ORR      r5,r5,#0x80
                  |L9.30|
;;;125            }
;;;126            rslt = dev->read(dev->dev_id, reg_addr, reg_data, len);
00001e  7860              LDRB     r0,[r4,#1]
000020  6864              LDR      r4,[r4,#4]
000022  463b              MOV      r3,r7
000024  4632              MOV      r2,r6
000026  4629              MOV      r1,r5
000028  47a0              BLX      r4
;;;127    
;;;128            /* Check for communication error and mask with an internal error code */
;;;129            if (rslt != BMP280_OK)
00002a  2800              CMP      r0,#0
00002c  d001              BEQ      |L9.50|
;;;130            {
;;;131                rslt = BMP280_E_COMM_FAIL;
00002e  f06f0003          MVN      r0,#3
                  |L9.50|
;;;132            }
;;;133        }
;;;134        else
;;;135        {
;;;136            rslt = BMP280_E_NULL_PTR;
;;;137        }
;;;138    
;;;139        return rslt;
;;;140    }
000032  e8bd81f0          POP      {r4-r8,pc}
                  |L9.54|
000036  f04f30ff          MOV      r0,#0xffffffff        ;136
00003a  e7fa              B        |L9.50|
;;;141    
                          ENDP


                          AREA ||i.bmp280_get_status||, CODE, READONLY, ALIGN=1

                  bmp280_get_status PROC
;;;328     */
;;;329    int8_t bmp280_get_status(struct bmp280_status *status, const struct bmp280_dev *dev)
000000  b538              PUSH     {r3-r5,lr}
;;;330    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;331        int8_t rslt;
;;;332        uint8_t temp;
;;;333    
;;;334        rslt = null_ptr_check(dev);
000006  4608              MOV      r0,r1
000008  f7fffffe          BL       null_ptr_check
;;;335        if ((rslt == BMP280_OK) && (status != NULL))
00000c  b988              CBNZ     r0,|L10.50|
00000e  b184              CBZ      r4,|L10.50|
;;;336        {
;;;337            rslt = bmp280_get_regs(BMP280_STATUS_ADDR, &temp, 1, dev);
000010  462b              MOV      r3,r5
000012  2201              MOVS     r2,#1
000014  4669              MOV      r1,sp
000016  20f3              MOVS     r0,#0xf3
000018  f7fffffe          BL       bmp280_get_regs
;;;338            status->measuring = BMP280_GET_BITS(BMP280_STATUS_MEAS, temp);
00001c  f89d1000          LDRB     r1,[sp,#0]
000020  f3c101c0          UBFX     r1,r1,#3,#1
000024  7021              STRB     r1,[r4,#0]
;;;339            status->im_update = BMP280_GET_BITS_POS_0(BMP280_STATUS_IM_UPDATE, temp);
000026  f89d1000          LDRB     r1,[sp,#0]
00002a  f0010101          AND      r1,r1,#1
00002e  7061              STRB     r1,[r4,#1]
;;;340        }
;;;341        else
;;;342        {
;;;343            rslt = BMP280_E_NULL_PTR;
;;;344        }
;;;345    
;;;346        return rslt;
;;;347    }
000030  bd38              POP      {r3-r5,pc}
                  |L10.50|
000032  f04f30ff          MOV      r0,#0xffffffff        ;343
000036  bd38              POP      {r3-r5,pc}
;;;348    
                          ENDP


                          AREA ||i.bmp280_get_uncomp_data||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  bmp280_get_uncomp_data PROC
;;;390     */
;;;391    int8_t bmp280_get_uncomp_data(struct bmp280_uncomp_data *uncomp_data, const struct bmp280_dev *dev)
000000  b57c              PUSH     {r2-r6,lr}
;;;392    {
000002  4604              MOV      r4,r0
;;;393        int8_t rslt;
;;;394        uint8_t temp[6] = { 0 };
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;395    
;;;396        rslt = null_ptr_check(dev);
000008  9001              STR      r0,[sp,#4]
00000a  460d              MOV      r5,r1                 ;392
00000c  4608              MOV      r0,r1
00000e  f7fffffe          BL       null_ptr_check
;;;397        if ((rslt == BMP280_OK) && (uncomp_data != NULL))
000012  2800              CMP      r0,#0
000014  d15c              BNE      |L11.208|
000016  2c00              CMP      r4,#0
000018  d05a              BEQ      |L11.208|
;;;398        {
;;;399            rslt = bmp280_get_regs(BMP280_PRES_MSB_ADDR, temp, 6, dev);
00001a  462b              MOV      r3,r5
00001c  2206              MOVS     r2,#6
00001e  4669              MOV      r1,sp
000020  20f7              MOVS     r0,#0xf7
000022  f7fffffe          BL       bmp280_get_regs
;;;400            if (rslt == BMP280_OK)
000026  b110              CBZ      r0,|L11.46|
;;;401            {
;;;402                printf("temp[0] :%x \r\n",temp[0]);
;;;403                printf("temp[1] :%x \r\n",temp[1]);
;;;404                printf("temp[2] :%x \r\n",temp[2]);
;;;405                printf("temp[3] :%x \r\n",temp[3]);
;;;406                printf("temp[4] :%x \r\n",temp[4]);
;;;407                printf("temp[5] :%x \r\n",temp[5]);
;;;408                uncomp_data->uncomp_press =
;;;409                    (int32_t) ((((uint32_t) (temp[0])) << 12) | (((uint32_t) (temp[1])) << 4) | ((uint32_t) temp[2] >> 4));
;;;410                uncomp_data->uncomp_temp =
;;;411                    (int32_t) ((((int32_t) (temp[3])) << 12) | (((int32_t) (temp[4])) << 4) | (((int32_t) (temp[5])) >> 4));
;;;412                rslt = st_check_boundaries((int32_t)uncomp_data->uncomp_temp, (int32_t)uncomp_data->uncomp_press);
;;;413            }
;;;414            else
;;;415            {
;;;416                rslt = BMP280_E_UNCOMP_DATA_CALC;
000028  f06f000c          MVN      r0,#0xc
;;;417            }
;;;418        }
;;;419        else
;;;420        {
;;;421            rslt = BMP280_E_NULL_PTR;
;;;422        }
;;;423    
;;;424        return rslt;
;;;425    }
00002c  bd7c              POP      {r2-r6,pc}
                  |L11.46|
00002e  f89d1000          LDRB     r1,[sp,#0]            ;402
000032  a029              ADR      r0,|L11.216|
000034  f7fffffe          BL       __2printf
000038  f89d1001          LDRB     r1,[sp,#1]            ;403
00003c  a02a              ADR      r0,|L11.232|
00003e  f7fffffe          BL       __2printf
000042  f89d1002          LDRB     r1,[sp,#2]            ;404
000046  a02c              ADR      r0,|L11.248|
000048  f7fffffe          BL       __2printf
00004c  f89d1003          LDRB     r1,[sp,#3]            ;405
000050  a02d              ADR      r0,|L11.264|
000052  f7fffffe          BL       __2printf
000056  f89d1004          LDRB     r1,[sp,#4]            ;406
00005a  a02f              ADR      r0,|L11.280|
00005c  f7fffffe          BL       __2printf
000060  f89d1005          LDRB     r1,[sp,#5]            ;407
000064  a030              ADR      r0,|L11.296|
000066  f7fffffe          BL       __2printf
00006a  f89d0000          LDRB     r0,[sp,#0]            ;408
00006e  f89d1001          LDRB     r1,[sp,#1]            ;408
000072  0300              LSLS     r0,r0,#12             ;408
000074  ea401001          ORR      r0,r0,r1,LSL #4       ;408
000078  f89d1002          LDRB     r1,[sp,#2]            ;408
00007c  4b2e              LDR      r3,|L11.312|
00007e  ea401111          ORR      r1,r0,r1,LSR #4       ;408
000082  6061              STR      r1,[r4,#4]            ;410
000084  f89d0003          LDRB     r0,[sp,#3]            ;410
000088  f89d2004          LDRB     r2,[sp,#4]            ;410
00008c  0300              LSLS     r0,r0,#12             ;410
00008e  ea401002          ORR      r0,r0,r2,LSL #4       ;410
000092  f89d2005          LDRB     r2,[sp,#5]            ;410
000096  ea401212          ORR      r2,r0,r2,LSR #4       ;410
00009a  2000              MOVS     r0,#0                 ;410
00009c  6022              STR      r2,[r4,#0]            ;410
00009e  2a00              CMP      r2,#0                 ;410
0000a0  dd01              BLE      |L11.166|
0000a2  429a              CMP      r2,r3                 ;412
0000a4  db08              BLT      |L11.184|
                  |L11.166|
0000a6  2900              CMP      r1,#0                 ;412
0000a8  dd01              BLE      |L11.174|
0000aa  4299              CMP      r1,r3                 ;412
0000ac  db02              BLT      |L11.180|
                  |L11.174|
0000ae  f06f000b          MVN      r0,#0xb               ;412
0000b2  bd7c              POP      {r2-r6,pc}
                  |L11.180|
0000b4  2a00              CMP      r2,#0
0000b6  dd01              BLE      |L11.188|
                  |L11.184|
0000b8  429a              CMP      r2,r3
0000ba  db02              BLT      |L11.194|
                  |L11.188|
0000bc  f06f0009          MVN      r0,#9
                  |L11.192|
0000c0  bd7c              POP      {r2-r6,pc}
                  |L11.194|
0000c2  2900              CMP      r1,#0
0000c4  dd01              BLE      |L11.202|
0000c6  4299              CMP      r1,r3
0000c8  dbfa              BLT      |L11.192|
                  |L11.202|
0000ca  f06f000a          MVN      r0,#0xa
0000ce  bd7c              POP      {r2-r6,pc}
                  |L11.208|
0000d0  f04f30ff          MOV      r0,#0xffffffff        ;421
0000d4  bd7c              POP      {r2-r6,pc}
;;;426    
                          ENDP

0000d6  0000              DCW      0x0000
                  |L11.216|
0000d8  74656d70          DCB      "temp[0] :%x \r\n",0
0000dc  5b305d20
0000e0  3a257820
0000e4  0d0a00  
0000e7  00                DCB      0
                  |L11.232|
0000e8  74656d70          DCB      "temp[1] :%x \r\n",0
0000ec  5b315d20
0000f0  3a257820
0000f4  0d0a00  
0000f7  00                DCB      0
                  |L11.248|
0000f8  74656d70          DCB      "temp[2] :%x \r\n",0
0000fc  5b325d20
000100  3a257820
000104  0d0a00  
000107  00                DCB      0
                  |L11.264|
000108  74656d70          DCB      "temp[3] :%x \r\n",0
00010c  5b335d20
000110  3a257820
000114  0d0a00  
000117  00                DCB      0
                  |L11.280|
000118  74656d70          DCB      "temp[4] :%x \r\n",0
00011c  5b345d20
000120  3a257820
000124  0d0a00  
000127  00                DCB      0
                  |L11.296|
000128  74656d70          DCB      "temp[5] :%x \r\n",0
00012c  5b355d20
000130  3a257820
000134  0d0a00  
000137  00                DCB      0
                  |L11.312|
                          DCD      0x000ffff0

                          AREA ||i.bmp280_init||, CODE, READONLY, ALIGN=1

                  bmp280_init PROC
;;;232     */
;;;233    int8_t bmp280_init(struct bmp280_dev *dev)
000000  b5f0              PUSH     {r4-r7,lr}
;;;234    {
000002  b087              SUB      sp,sp,#0x1c
000004  4604              MOV      r4,r0
;;;235        int8_t rslt;
;;;236    
;;;237        /* Maximum number of tries before timeout */
;;;238        uint8_t try_count = 5;
000006  2605              MOVS     r6,#5
;;;239    
;;;240        rslt = null_ptr_check(dev);
000008  f7fffffe          BL       null_ptr_check
00000c  0005              MOVS     r5,r0
;;;241        if (rslt == BMP280_OK)
00000e  d05f              BEQ      |L12.208|
000010  e05a              B        |L12.200|
                  |L12.18|
;;;242        {
;;;243            while (try_count)
;;;244            {
;;;245                rslt = bmp280_get_regs(BMP280_CHIP_ID_ADDR, &dev->chip_id, 1, dev);
000012  4623              MOV      r3,r4
000014  2201              MOVS     r2,#1
000016  4619              MOV      r1,r3
000018  20d0              MOVS     r0,#0xd0
00001a  f7fffffe          BL       bmp280_get_regs
;;;246    
;;;247                /* Check for chip id validity */
;;;248                if ((rslt == BMP280_OK) &&
00001e  b930              CBNZ     r0,|L12.46|
;;;249                    (dev->chip_id == BMP280_CHIP_ID1 || dev->chip_id == BMP280_CHIP_ID2 || dev->chip_id == BMP280_CHIP_ID3))
000020  7820              LDRB     r0,[r4,#0]
000022  2856              CMP      r0,#0x56
000024  d00b              BEQ      |L12.62|
000026  2857              CMP      r0,#0x57
000028  d009              BEQ      |L12.62|
00002a  2858              CMP      r0,#0x58
00002c  d007              BEQ      |L12.62|
                  |L12.46|
;;;250                {
;;;251                    rslt = bmp280_soft_reset(dev);
;;;252                    if (rslt == BMP280_OK)
;;;253                    {
;;;254                        rslt = get_calib_param(dev);
;;;255                    }
;;;256                    break;
;;;257                }
;;;258    
;;;259                /* Wait for 10 ms */
;;;260                dev->delay_ms(10);
00002e  68e1              LDR      r1,[r4,#0xc]
000030  200a              MOVS     r0,#0xa
000032  4788              BLX      r1
000034  1e76              SUBS     r6,r6,#1
;;;261                --try_count;
000036  f01606ff          ANDS     r6,r6,#0xff
00003a  d1ea              BNE      |L12.18|
00003c  e04b              B        |L12.214|
                  |L12.62|
00003e  4620              MOV      r0,r4                 ;251
000040  f7fffffe          BL       bmp280_soft_reset
000044  0005              MOVS     r5,r0                 ;251
000046  d10f              BNE      |L12.104|
000048  2118              MOVS     r1,#0x18              ;252
00004a  4668              MOV      r0,sp                 ;252
00004c  f7fffffe          BL       __aeabi_memclr4
000050  4620              MOV      r0,r4                 ;252
000052  f7fffffe          BL       null_ptr_check
000056  b930              CBNZ     r0,|L12.102|
000058  4623              MOV      r3,r4                 ;252
00005a  2218              MOVS     r2,#0x18              ;252
00005c  4669              MOV      r1,sp                 ;252
00005e  2088              MOVS     r0,#0x88              ;252
000060  f7fffffe          BL       bmp280_get_regs
000064  b110              CBZ      r0,|L12.108|
                  |L12.102|
000066  4605              MOV      r5,r0                 ;254
                  |L12.104|
;;;262            }
;;;263    
;;;264            /* Chip id check failed, and timed out */
;;;265            if (!try_count)
000068  b38e              CBZ      r6,|L12.206|
00006a  e02d              B        |L12.200|
                  |L12.108|
00006c  f8bd1000          LDRH     r1,[sp,#0]
000070  8221              STRH     r1,[r4,#0x10]
000072  f8bd1002          LDRH     r1,[sp,#2]
000076  8261              STRH     r1,[r4,#0x12]
000078  f8bd1004          LDRH     r1,[sp,#4]
00007c  82a1              STRH     r1,[r4,#0x14]
00007e  f8bd1006          LDRH     r1,[sp,#6]
000082  82e1              STRH     r1,[r4,#0x16]
000084  f8bd1008          LDRH     r1,[sp,#8]
000088  8321              STRH     r1,[r4,#0x18]
00008a  f8bd100a          LDRH     r1,[sp,#0xa]
00008e  8361              STRH     r1,[r4,#0x1a]
000090  f8bd100c          LDRH     r1,[sp,#0xc]
000094  83a1              STRH     r1,[r4,#0x1c]
000096  f8bd100e          LDRH     r1,[sp,#0xe]
00009a  83e1              STRH     r1,[r4,#0x1e]
00009c  f8bd1010          LDRH     r1,[sp,#0x10]
0000a0  8421              STRH     r1,[r4,#0x20]
0000a2  f8bd1012          LDRH     r1,[sp,#0x12]
0000a6  8461              STRH     r1,[r4,#0x22]
0000a8  f8bd1014          LDRH     r1,[sp,#0x14]
0000ac  84a1              STRH     r1,[r4,#0x24]
0000ae  f8bd1016          LDRH     r1,[sp,#0x16]
0000b2  84e1              STRH     r1,[r4,#0x26]
0000b4  b15e              CBZ      r6,|L12.206|
;;;266            {
;;;267                rslt = BMP280_E_DEV_NOT_FOUND;
;;;268            }
;;;269            if (rslt == BMP280_OK)
;;;270            {
;;;271                /* Set values to default */
;;;272                dev->conf.filter = BMP280_FILTER_OFF;
0000b6  2000              MOVS     r0,#0
0000b8  f884002f          STRB     r0,[r4,#0x2f]
;;;273                dev->conf.os_pres = BMP280_OS_NONE;
0000bc  f884002d          STRB     r0,[r4,#0x2d]
;;;274                dev->conf.os_temp = BMP280_OS_NONE;
0000c0  f8040f2c          STRB     r0,[r4,#0x2c]!
;;;275                dev->conf.odr = BMP280_ODR_0_5_MS;
0000c4  70a0              STRB     r0,[r4,#2]
;;;276                dev->conf.spi3w_en = BMP280_SPI3_WIRE_DISABLE;
0000c6  7120              STRB     r0,[r4,#4]
                  |L12.200|
;;;277            }
;;;278        }
;;;279    
;;;280        return rslt;
;;;281    }
0000c8  b007              ADD      sp,sp,#0x1c
0000ca  4628              MOV      r0,r5                 ;280
0000cc  bdf0              POP      {r4-r7,pc}
                  |L12.206|
0000ce  e002              B        |L12.214|
                  |L12.208|
0000d0  f06f0701          MVN      r7,#1                 ;267
0000d4  e79d              B        |L12.18|
                  |L12.214|
0000d6  463d              MOV      r5,r7                 ;267
0000d8  e7f6              B        |L12.200|
;;;282    
                          ENDP


                          AREA ||i.bmp280_set_config||, CODE, READONLY, ALIGN=1

                  bmp280_set_config PROC
;;;320     */
;;;321    int8_t bmp280_set_config(const struct bmp280_config *conf, struct bmp280_dev *dev)
000000  460a              MOV      r2,r1
;;;322    {
;;;323        return conf_sensor(BMP280_SLEEP_MODE, conf, dev);
000002  4601              MOV      r1,r0
000004  2000              MOVS     r0,#0
000006  f7ffbffe          B.W      conf_sensor
;;;324    }
;;;325    
                          ENDP


                          AREA ||i.bmp280_set_power_mode||, CODE, READONLY, ALIGN=1

                  bmp280_set_power_mode PROC
;;;373     */
;;;374    int8_t bmp280_set_power_mode(uint8_t mode, struct bmp280_dev *dev)
000000  b570              PUSH     {r4-r6,lr}
;;;375    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;376        int8_t rslt;
;;;377    
;;;378        rslt = null_ptr_check(dev);
000006  4608              MOV      r0,r1
000008  f7fffffe          BL       null_ptr_check
;;;379        if (rslt == BMP280_OK)
00000c  2800              CMP      r0,#0
00000e  d107              BNE      |L14.32|
;;;380        {
;;;381            rslt = conf_sensor(mode, &dev->conf, dev);
000010  4622              MOV      r2,r4
000012  f104012c          ADD      r1,r4,#0x2c
000016  4628              MOV      r0,r5
000018  e8bd4070          POP      {r4-r6,lr}
00001c  f7ffbffe          B.W      conf_sensor
                  |L14.32|
;;;382        }
;;;383    
;;;384        return rslt;
;;;385    }
000020  bd70              POP      {r4-r6,pc}
;;;386    
                          ENDP


                          AREA ||i.bmp280_set_regs||, CODE, READONLY, ALIGN=1

                  bmp280_set_regs PROC
;;;145     */
;;;146    int8_t bmp280_set_regs(uint8_t *reg_addr, const uint8_t *reg_data, uint8_t len, const struct bmp280_dev *dev)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;147    {
000004  4614              MOV      r4,r2
000006  460e              MOV      r6,r1
000008  4605              MOV      r5,r0
00000a  461f              MOV      r7,r3
;;;148        int8_t rslt;
;;;149        uint8_t temp_buff[8]; /* Typically not to write more than 4 registers */
;;;150        uint16_t temp_len;
;;;151        uint8_t reg_addr_cnt;
;;;152    
;;;153        if (len > 4)
00000c  2a04              CMP      r2,#4
00000e  d900              BLS      |L15.18|
;;;154        {
;;;155            len = 4;
000010  2404              MOVS     r4,#4
                  |L15.18|
;;;156        }
;;;157        rslt = null_ptr_check(dev);
000012  4618              MOV      r0,r3
000014  f7fffffe          BL       null_ptr_check
;;;158        if ((rslt == BMP280_OK) && (reg_addr != NULL) && (reg_data != NULL))
;;;159        {
;;;160            if (len != 0)
;;;161            {
;;;162                temp_buff[0] = reg_data[0];
;;;163    
;;;164                /* Mask the register address' MSB if interface selected is SPI */
;;;165                if (dev->intf == BMP280_SPI_INTF)
;;;166                {
;;;167                    /* Converting all the reg address into proper SPI write address
;;;168                     * i.e making MSB(R/`W) bit 0
;;;169                     */
;;;170                    for (reg_addr_cnt = 0; reg_addr_cnt < len; reg_addr_cnt++)
;;;171                    {
;;;172                        reg_addr[reg_addr_cnt] = reg_addr[reg_addr_cnt] & 0x7F;
;;;173                    }
;;;174                }
;;;175    
;;;176                /* Burst write mode */
;;;177                if (len > 1)
;;;178                {
;;;179                    /* Interleave register address w.r.t data for burst write*/
;;;180                    interleave_data(reg_addr, temp_buff, reg_data, len);
;;;181                    temp_len = ((len * 2) - 1);
000018  f04f3cff          MOV      r12,#0xffffffff
00001c  bb90              CBNZ     r0,|L15.132|
00001e  b38d              CBZ      r5,|L15.132|
000020  b386              CBZ      r6,|L15.132|
000022  b384              CBZ      r4,|L15.134|
000024  7830              LDRB     r0,[r6,#0]            ;162
000026  f88d0000          STRB     r0,[sp,#0]            ;162
00002a  78b8              LDRB     r0,[r7,#2]            ;165
00002c  b130              CBZ      r0,|L15.60|
00002e  e007              B        |L15.64|
                  |L15.48|
000030  5c29              LDRB     r1,[r5,r0]            ;172
000032  f001017f          AND      r1,r1,#0x7f           ;172
000036  5429              STRB     r1,[r5,r0]            ;172
000038  1c40              ADDS     r0,r0,#1              ;172
00003a  b2c0              UXTB     r0,r0                 ;170
                  |L15.60|
00003c  42a0              CMP      r0,r4                 ;170
00003e  d3f7              BCC      |L15.48|
                  |L15.64|
000040  2c01              CMP      r4,#1                 ;177
000042  d913              BLS      |L15.108|
000044  4669              MOV      r1,sp                 ;180
000046  2001              MOVS     r0,#1                 ;180
000048  e009              B        |L15.94|
                  |L15.74|
00004a  eb010340          ADD      r3,r1,r0,LSL #1       ;180
00004e  5c2a              LDRB     r2,[r5,r0]            ;180
000050  f8032c01          STRB     r2,[r3,#-1]           ;180
000054  5c32              LDRB     r2,[r6,r0]            ;180
000056  f8012010          STRB     r2,[r1,r0,LSL #1]     ;180
00005a  1c40              ADDS     r0,r0,#1              ;180
00005c  b2c0              UXTB     r0,r0                 ;180
                  |L15.94|
00005e  4622              MOV      r2,r4                 ;180
000060  42a0              CMP      r0,r4                 ;180
000062  d3f2              BCC      |L15.74|
000064  eb0c0042          ADD      r0,r12,r2,LSL #1
000068  b283              UXTH     r3,r0
00006a  e000              B        |L15.110|
                  |L15.108|
;;;182                }
;;;183                else
;;;184                {
;;;185                    temp_len = len;
00006c  4623              MOV      r3,r4
                  |L15.110|
;;;186                }
;;;187                rslt = dev->write(dev->dev_id, reg_addr[0], temp_buff, temp_len);
00006e  68bc              LDR      r4,[r7,#8]
000070  7829              LDRB     r1,[r5,#0]
000072  7878              LDRB     r0,[r7,#1]
000074  466a              MOV      r2,sp
000076  47a0              BLX      r4
;;;188    
;;;189                /* Check for communication error and mask with an internal error code */
;;;190                if (rslt != BMP280_OK)
000078  2800              CMP      r0,#0
00007a  d001              BEQ      |L15.128|
;;;191                {
;;;192                    rslt = BMP280_E_COMM_FAIL;
00007c  f06f0003          MVN      r0,#3
                  |L15.128|
;;;193                }
;;;194            }
;;;195            else
;;;196            {
;;;197                rslt = BMP280_E_INVALID_LEN;
;;;198            }
;;;199        }
;;;200        else
;;;201        {
;;;202            rslt = BMP280_E_NULL_PTR;
;;;203        }
;;;204    
;;;205        return rslt;
;;;206    }
000080  e8bd81fc          POP      {r2-r8,pc}
                  |L15.132|
000084  e003              B        |L15.142|
                  |L15.134|
000086  e7ff              B        |L15.136|
                  |L15.136|
000088  f06f0002          MVN      r0,#2                 ;197
00008c  e7f8              B        |L15.128|
                  |L15.142|
00008e  4660              MOV      r0,r12                ;202
000090  e7f6              B        |L15.128|
;;;207    
                          ENDP


                          AREA ||i.bmp280_soft_reset||, CODE, READONLY, ALIGN=1

                  bmp280_soft_reset PROC
;;;210     */
;;;211    int8_t bmp280_soft_reset(const struct bmp280_dev *dev)
000000  b57c              PUSH     {r2-r6,lr}
;;;212    {
000002  4605              MOV      r5,r0
;;;213        int8_t rslt;
;;;214        uint8_t reg_addr = BMP280_SOFT_RESET_ADDR;
000004  20e0              MOVS     r0,#0xe0
000006  f88d0000          STRB     r0,[sp,#0]
;;;215        uint8_t soft_rst_cmd = BMP280_SOFT_RESET_CMD;
00000a  20b6              MOVS     r0,#0xb6
00000c  f88d0004          STRB     r0,[sp,#4]
;;;216    
;;;217        rslt = null_ptr_check(dev);
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       null_ptr_check
000016  0004              MOVS     r4,r0
;;;218        if (rslt == BMP280_OK)
000018  d109              BNE      |L16.46|
;;;219        {
;;;220            rslt = bmp280_set_regs(&reg_addr, &soft_rst_cmd, 1, dev);
00001a  462b              MOV      r3,r5
00001c  2201              MOVS     r2,#1
00001e  a901              ADD      r1,sp,#4
000020  4668              MOV      r0,sp
000022  f7fffffe          BL       bmp280_set_regs
000026  4604              MOV      r4,r0
;;;221    
;;;222            /* As per the datasheet, startup time is 2 ms. */
;;;223            dev->delay_ms(2);
000028  68e9              LDR      r1,[r5,#0xc]
00002a  2002              MOVS     r0,#2
00002c  4788              BLX      r1
                  |L16.46|
;;;224        }
;;;225    
;;;226        return rslt;
00002e  4620              MOV      r0,r4
;;;227    }
000030  bd7c              POP      {r2-r6,pc}
;;;228    
                          ENDP


                          AREA ||i.conf_sensor||, CODE, READONLY, ALIGN=2

                  conf_sensor PROC
;;;736     */
;;;737    static int8_t conf_sensor(uint8_t mode, const struct bmp280_config *conf, struct bmp280_dev *dev)
000000  b57c              PUSH     {r2-r6,lr}
;;;738    {
000002  4606              MOV      r6,r0
;;;739        int8_t rslt;
;;;740        uint8_t temp[2] = { 0, 0 };
000004  2000              MOVS     r0,#0
;;;741        uint8_t reg_addr[2] = { BMP280_CTRL_MEAS_ADDR, BMP280_CONFIG_ADDR };
000006  9000              STR      r0,[sp,#0]
000008  a02a              ADR      r0,|L17.180|
00000a  460c              MOV      r4,r1                 ;738
00000c  6800              LDR      r0,[r0,#0]
;;;742    
;;;743        rslt = null_ptr_check(dev);
00000e  9001              STR      r0,[sp,#4]
000010  4615              MOV      r5,r2                 ;738
000012  4610              MOV      r0,r2
000014  f7fffffe          BL       null_ptr_check
;;;744        if ((rslt == BMP280_OK) && (conf != NULL))
000018  bbf0              CBNZ     r0,|L17.152|
00001a  b3ec              CBZ      r4,|L17.152|
;;;745        {
;;;746            rslt = bmp280_get_regs(BMP280_CTRL_MEAS_ADDR, temp, 2, dev);
00001c  462b              MOV      r3,r5
00001e  2202              MOVS     r2,#2
000020  4669              MOV      r1,sp
000022  20f4              MOVS     r0,#0xf4
000024  f7fffffe          BL       bmp280_get_regs
;;;747            if (rslt == BMP280_OK)
000028  2800              CMP      r0,#0
00002a  d13e              BNE      |L17.170|
;;;748            {
;;;749                /* Here the intention is to put the device to sleep
;;;750                 * within the shortest period of time
;;;751                 */
;;;752                rslt = bmp280_soft_reset(dev);
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       bmp280_soft_reset
;;;753                if (rslt == BMP280_OK)
000032  2800              CMP      r0,#0
000034  d139              BNE      |L17.170|
;;;754                {
;;;755                    temp[0] = BMP280_SET_BITS(temp[0], BMP280_OS_TEMP, conf->os_temp);
000036  7821              LDRB     r1,[r4,#0]
000038  f89d0000          LDRB     r0,[sp,#0]
;;;756                    temp[0] = BMP280_SET_BITS(temp[0], BMP280_OS_PRES, conf->os_pres);
;;;757                    temp[1] = BMP280_SET_BITS(temp[1], BMP280_STANDBY_DURN, conf->odr);
;;;758                    temp[1] = BMP280_SET_BITS(temp[1], BMP280_FILTER, conf->filter);
;;;759                    temp[1] = BMP280_SET_BITS_POS_0(temp[1], BMP280_SPI3_ENABLE, conf->spi3w_en);
;;;760                    rslt = bmp280_set_regs(reg_addr, temp, 2, dev);
00003c  462b              MOV      r3,r5
00003e  f3611047          BFI      r0,r1,#5,#3           ;755
000042  f88d0000          STRB     r0,[sp,#0]            ;755
000046  7861              LDRB     r1,[r4,#1]            ;756
000048  2202              MOVS     r2,#2
00004a  f3610084          BFI      r0,r1,#2,#3           ;756
00004e  f88d0000          STRB     r0,[sp,#0]            ;756
000052  78a1              LDRB     r1,[r4,#2]            ;757
000054  f89d0001          LDRB     r0,[sp,#1]            ;757
000058  f3611047          BFI      r0,r1,#5,#3           ;757
00005c  f88d0001          STRB     r0,[sp,#1]            ;757
000060  78e1              LDRB     r1,[r4,#3]            ;758
000062  f3610084          BFI      r0,r1,#2,#3           ;758
000066  f88d0001          STRB     r0,[sp,#1]            ;758
00006a  7921              LDRB     r1,[r4,#4]            ;759
00006c  f3610000          BFI      r0,r1,#0,#1           ;759
000070  f88d0001          STRB     r0,[sp,#1]            ;759
000074  4669              MOV      r1,sp
000076  a801              ADD      r0,sp,#4
000078  f7fffffe          BL       bmp280_set_regs
;;;761                    if (rslt == BMP280_OK)
00007c  2800              CMP      r0,#0
00007e  d114              BNE      |L17.170|
;;;762                    {
;;;763                        dev->conf = *conf;
000080  6821              LDR      r1,[r4,#0]
000082  62e9              STR      r1,[r5,#0x2c]
000084  7921              LDRB     r1,[r4,#4]
000086  f8851030          STRB     r1,[r5,#0x30]
;;;764                        if (mode != BMP280_SLEEP_MODE)
00008a  2e00              CMP      r6,#0
00008c  d00d              BEQ      |L17.170|
;;;765                        {
;;;766                            /* Write only the power mode register in a separate write */
;;;767                            temp[0] = BMP280_SET_BITS_POS_0(temp[0], BMP280_POWER_MODE, mode);
00008e  f89d0000          LDRB     r0,[sp,#0]
000092  f3660001          BFI      r0,r6,#0,#2
000096  e000              B        |L17.154|
                  |L17.152|
000098  e008              B        |L17.172|
                  |L17.154|
00009a  f88d0000          STRB     r0,[sp,#0]
;;;768                            rslt = bmp280_set_regs(reg_addr, temp, 1, dev);
00009e  462b              MOV      r3,r5
0000a0  2201              MOVS     r2,#1
0000a2  4669              MOV      r1,sp
0000a4  a801              ADD      r0,sp,#4
0000a6  f7fffffe          BL       bmp280_set_regs
                  |L17.170|
;;;769                        }
;;;770                    }
;;;771                }
;;;772            }
;;;773        }
;;;774        else
;;;775        {
;;;776            rslt = BMP280_E_NULL_PTR;
;;;777        }
;;;778    
;;;779        return rslt;
;;;780    }
0000aa  bd7c              POP      {r2-r6,pc}
                  |L17.172|
0000ac  f04f30ff          MOV      r0,#0xffffffff        ;776
0000b0  bd7c              POP      {r2-r6,pc}
;;;781    
                          ENDP

0000b2  0000              DCW      0x0000
                  |L17.180|
0000b4  f4f500            DCB      244,245,0
0000b7  00                DCB      0

                          AREA ||i.null_ptr_check||, CODE, READONLY, ALIGN=1

                  null_ptr_check PROC
;;;656     */
;;;657    static int8_t null_ptr_check(const struct bmp280_dev *dev)
000000  b138              CBZ      r0,|L18.18|
;;;658    {
;;;659        int8_t rslt;
;;;660    
;;;661        if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_ms == NULL))
000002  6841              LDR      r1,[r0,#4]
000004  b129              CBZ      r1,|L18.18|
000006  6881              LDR      r1,[r0,#8]
000008  b119              CBZ      r1,|L18.18|
00000a  68c0              LDR      r0,[r0,#0xc]
00000c  b108              CBZ      r0,|L18.18|
;;;662        {
;;;663            /* Null-pointer found */
;;;664            rslt = BMP280_E_NULL_PTR;
;;;665        }
;;;666        else
;;;667        {
;;;668            rslt = BMP280_OK;
00000e  2000              MOVS     r0,#0
;;;669        }
;;;670    
;;;671        return rslt;
;;;672    }
000010  4770              BX       lr
                  |L18.18|
000012  f04f30ff          MOV      r0,#0xffffffff        ;664
000016  4770              BX       lr
;;;673    
                          ENDP

