; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm32l152-eval\ff.o --asm_dir=.\STM32L152-EVAL\ --list_dir=.\STM32L152-EVAL\ --depend=.\stm32l152-eval\ff.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32L1xx\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32L1xx_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM32L152_EVAL -I..\src\user -I..\src\user\include -I..\src\SYSTEM\delay -I..\src\SYSTEM\sys -I..\src\SYSTEM\usart -I..\src\HARDWARE\ADC -I..\src\HARDWARE\BMP -I..\src\HARDWARE\DMA -I..\src\HARDWARE\FLASH -I..\src\HARDWARE\GPS -I..\src\HARDWARE\KEY -I..\src\HARDWARE\PWM -I..\src\HARDWARE\RTC -I..\src\HARDWARE\SPI -I..\src\HARDWARE\USART2 -I..\src\HARDWARE\TIMER -I..\src\EX -I..\src\USMART -I..\..\..\Libraries\CMSIS\Include -I..\src\ff11a\src -I..\src\ff11a\src\option -I..\src\HARDWARE\LED -I..\src\HARDWARE\OLED -I..\src\ff11a\src -I..\src\ff11a\src\option -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.1.0\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32L1xx -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32L1XX_MD -DUSE_STM32L152_EVAL ..\src\ff11a\src\ff.c]
                          THUMB

                          AREA ||i.check_fs||, CODE, READONLY, ALIGN=2

                  check_fs PROC
;;;2175   static
;;;2176   BYTE check_fs (	/* 0:Valid FAT-BS, 1:Valid BS but not FAT, 2:Not a BS, 3:Disk error */
000000  b510              PUSH     {r4,lr}
;;;2177   	FATFS* fs,	/* File system object */
;;;2178   	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
;;;2179   )
;;;2180   {
000002  4604              MOV      r4,r0
;;;2181   	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;	/* Invaidate window */
000004  2000              MOVS     r0,#0
000006  7120              STRB     r0,[r4,#4]
000008  1e40              SUBS     r0,r0,#1
;;;2182   	if (move_window(fs, sect) != FR_OK)			/* Load boot record */
00000a  62e0              STR      r0,[r4,#0x2c]
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       move_window
000012  b108              CBZ      r0,|L1.24|
;;;2183   		return 3;
000014  2003              MOVS     r0,#3
;;;2184   
;;;2185   	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)	/* Check boot record signature (always placed at offset 510 even if the sector size is >512) */
;;;2186   		return 2;
;;;2187   
;;;2188   	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)		/* Check "FAT" string */
;;;2189   		return 0;
;;;2190   	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
;;;2191   		return 0;
;;;2192   
;;;2193   	return 1;
;;;2194   }
000016  bd10              POP      {r4,pc}
                  |L1.24|
000018  f8b4022e          LDRH     r0,[r4,#0x22e]        ;2185
00001c  f5a0412a          SUB      r1,r0,#0xaa00         ;2185
000020  3955              SUBS     r1,r1,#0x55           ;2185
000022  d001              BEQ      |L1.40|
000024  2002              MOVS     r0,#2                 ;2186
000026  bd10              POP      {r4,pc}
                  |L1.40|
000028  f8940066          LDRB     r0,[r4,#0x66]         ;2188
00002c  f8b41067          LDRH     r1,[r4,#0x67]         ;2188
000030  ea402101          ORR      r1,r0,r1,LSL #8       ;2188
000034  4808              LDR      r0,|L1.88|
000036  ebb02f01          CMP      r0,r1,LSL #8          ;2188
00003a  d008              BEQ      |L1.78|
00003c  f8941082          LDRB     r1,[r4,#0x82]         ;2190
000040  f8b42083          LDRH     r2,[r4,#0x83]         ;2190
000044  ea412102          ORR      r1,r1,r2,LSL #8       ;2190
000048  ebb02f01          CMP      r0,r1,LSL #8          ;2190
00004c  d101              BNE      |L1.82|
                  |L1.78|
00004e  2000              MOVS     r0,#0                 ;2191
000050  bd10              POP      {r4,pc}
                  |L1.82|
000052  2001              MOVS     r0,#1                 ;2193
000054  bd10              POP      {r4,pc}
;;;2195   
                          ENDP

000056  0000              DCW      0x0000
                  |L1.88|
                          DCD      0x54414600

                          AREA ||i.clust2sect||, CODE, READONLY, ALIGN=1

                  clust2sect PROC
;;;800    
;;;801    DWORD clust2sect (	/* !=0:Sector number, 0:Failed (invalid cluster#) */
000000  6942              LDR      r2,[r0,#0x14]
;;;802    	FATFS* fs,		/* File system object */
;;;803    	DWORD clst		/* Cluster# to be converted */
;;;804    )
;;;805    {
;;;806    	clst -= 2;
;;;807    	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
000002  1e89              SUBS     r1,r1,#2
000004  1e92              SUBS     r2,r2,#2
000006  428a              CMP      r2,r1
000008  d801              BHI      |L2.14|
00000a  2000              MOVS     r0,#0
;;;808    	return clst * fs->csize + fs->database;
;;;809    }
00000c  4770              BX       lr
                  |L2.14|
00000e  6a82              LDR      r2,[r0,#0x28]         ;808
000010  7880              LDRB     r0,[r0,#2]            ;808
000012  fb012000          MLA      r0,r1,r0,r2           ;808
000016  4770              BX       lr
;;;810    
                          ENDP


                          AREA ||i.create_chain||, CODE, READONLY, ALIGN=1

                  create_chain PROC
;;;990    static
;;;991    DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;992    	FATFS* fs,			/* File system object */
;;;993    	DWORD clst			/* Cluster# to stretch, 0:Create a new chain */
;;;994    )
;;;995    {
000004  000f              MOVS     r7,r1
000006  4605              MOV      r5,r0
000008  d006              BEQ      |L3.24|
;;;996    	DWORD cs, ncl, scl;
;;;997    	FRESULT res;
;;;998    
;;;999    
;;;1000   	if (clst == 0) {		/* Create a new chain */
;;;1001   		scl = fs->last_clust;			/* Get suggested start point */
;;;1002   		if (!scl || scl >= fs->n_fatent) scl = 1;
;;;1003   	}
;;;1004   	else {					/* Stretch the current chain */
;;;1005   		cs = get_fat(fs, clst);			/* Check the cluster status */
00000a  f7fffffe          BL       get_fat
;;;1006   		if (cs < 2) return 1;			/* Invalid value */
00000e  2802              CMP      r0,#2
000010  d209              BCS      |L3.38|
000012  2001              MOVS     r0,#1
                  |L3.20|
;;;1007   		if (cs == 0xFFFFFFFF) return cs;	/* A disk error occurred */
;;;1008   		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
;;;1009   		scl = clst;
;;;1010   	}
;;;1011   
;;;1012   	ncl = scl;				/* Start cluster */
;;;1013   	for (;;) {
;;;1014   		ncl++;							/* Next cluster */
;;;1015   		if (ncl >= fs->n_fatent) {		/* Check wrap around */
;;;1016   			ncl = 2;
;;;1017   			if (ncl > scl) return 0;	/* No free cluster */
;;;1018   		}
;;;1019   		cs = get_fat(fs, ncl);			/* Get the cluster status */
;;;1020   		if (cs == 0) break;				/* Found a free cluster */
;;;1021   		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
;;;1022   			return cs;
;;;1023   		if (ncl == scl) return 0;		/* No free cluster */
;;;1024   	}
;;;1025   
;;;1026   	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
;;;1027   	if (res == FR_OK && clst != 0) {
;;;1028   		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
;;;1029   	}
;;;1030   	if (res == FR_OK) {
;;;1031   		fs->last_clust = ncl;			/* Update FSINFO */
;;;1032   		if (fs->free_clust != 0xFFFFFFFF) {
;;;1033   			fs->free_clust--;
;;;1034   			fs->fsi_flag |= 1;
;;;1035   		}
;;;1036   	} else {
;;;1037   		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
;;;1038   	}
;;;1039   
;;;1040   	return ncl;		/* Return new cluster number or error code */
;;;1041   }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L3.24|
000018  68ee              LDR      r6,[r5,#0xc]          ;1002
00001a  b116              CBZ      r6,|L3.34|
00001c  6968              LDR      r0,[r5,#0x14]         ;1002
00001e  42b0              CMP      r0,r6                 ;1002
000020  d807              BHI      |L3.50|
                  |L3.34|
000022  2601              MOVS     r6,#1                 ;1002
000024  e005              B        |L3.50|
                  |L3.38|
000026  1c41              ADDS     r1,r0,#1              ;1007
000028  d0f4              BEQ      |L3.20|
00002a  6969              LDR      r1,[r5,#0x14]         ;1008
00002c  4281              CMP      r1,r0                 ;1008
00002e  d8f1              BHI      |L3.20|
000030  463e              MOV      r6,r7                 ;1009
                  |L3.50|
000032  4634              MOV      r4,r6                 ;1012
                  |L3.52|
000034  6968              LDR      r0,[r5,#0x14]         ;1015
000036  1c64              ADDS     r4,r4,#1              ;1015
000038  42a0              CMP      r0,r4                 ;1015
00003a  d802              BHI      |L3.66|
00003c  2402              MOVS     r4,#2                 ;1016
00003e  2e02              CMP      r6,#2                 ;1017
000040  d30a              BCC      |L3.88|
                  |L3.66|
000042  4621              MOV      r1,r4                 ;1019
000044  4628              MOV      r0,r5                 ;1019
000046  f7fffffe          BL       get_fat
00004a  b138              CBZ      r0,|L3.92|
00004c  1c41              ADDS     r1,r0,#1              ;1021
00004e  d0e1              BEQ      |L3.20|
000050  2801              CMP      r0,#1                 ;1021
000052  d0df              BEQ      |L3.20|
000054  42b4              CMP      r4,r6                 ;1023
000056  d1ed              BNE      |L3.52|
                  |L3.88|
000058  2000              MOVS     r0,#0                 ;1023
00005a  e7db              B        |L3.20|
                  |L3.92|
00005c  f06f4270          MVN      r2,#0xf0000000        ;1026
000060  4621              MOV      r1,r4                 ;1026
000062  4628              MOV      r0,r5                 ;1026
000064  f7fffffe          BL       put_fat
000068  b930              CBNZ     r0,|L3.120|
00006a  b157              CBZ      r7,|L3.130|
00006c  4622              MOV      r2,r4                 ;1028
00006e  4639              MOV      r1,r7                 ;1028
000070  4628              MOV      r0,r5                 ;1028
000072  f7fffffe          BL       put_fat
000076  b120              CBZ      r0,|L3.130|
                  |L3.120|
000078  2801              CMP      r0,#1                 ;1037
00007a  d00d              BEQ      |L3.152|
00007c  2401              MOVS     r4,#1                 ;1037
                  |L3.126|
00007e  4620              MOV      r0,r4                 ;1040
000080  e7c8              B        |L3.20|
                  |L3.130|
000082  60ec              STR      r4,[r5,#0xc]          ;1032
000084  6928              LDR      r0,[r5,#0x10]         ;1032
000086  1c41              ADDS     r1,r0,#1              ;1032
000088  d0f9              BEQ      |L3.126|
00008a  1e40              SUBS     r0,r0,#1              ;1032
00008c  6128              STR      r0,[r5,#0x10]         ;1034
00008e  7968              LDRB     r0,[r5,#5]            ;1034
000090  f0400001          ORR      r0,r0,#1              ;1034
000094  7168              STRB     r0,[r5,#5]            ;1034
000096  e7f2              B        |L3.126|
                  |L3.152|
000098  f04f34ff          MOV      r4,#0xffffffff        ;1037
00009c  e7ef              B        |L3.126|
;;;1042   #endif /* !_FS_READONLY */
                          ENDP


                          AREA ||i.create_name||, CODE, READONLY, ALIGN=2

                  create_name PROC
;;;1843   static
;;;1844   FRESULT create_name (	/* FR_OK: successful, FR_INVALID_NAME: could not create */
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1845   	DIR* dp,			/* Pointer to the directory object */
;;;1846   	const TCHAR** path	/* Pointer to pointer to the segment in the path string */
;;;1847   )
;;;1848   {
000004  4689              MOV      r9,r1
000006  680c              LDR      r4,[r1,#0]
000008  e000              B        |L4.12|
                  |L4.10|
00000a  1c64              ADDS     r4,r4,#1
                  |L4.12|
;;;1849   #if _USE_LFN	/* LFN configuration */
;;;1850   	BYTE b, cf;
;;;1851   	WCHAR w, *lfn;
;;;1852   	UINT i, ni, si, di;
;;;1853   	const TCHAR *p;
;;;1854   
;;;1855   	/* Create LFN in Unicode */
;;;1856   	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
;;;1857   	lfn = dp->lfn;
;;;1858   	si = di = 0;
;;;1859   	for (;;) {
;;;1860   		w = p[si++];					/* Get a character */
;;;1861   		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
;;;1862   		if (di >= _MAX_LFN)				/* Reject too long name */
;;;1863   			return FR_INVALID_NAME;
;;;1864   #if !_LFN_UNICODE
;;;1865   		w &= 0xFF;
;;;1866   		if (IsDBCS1(w)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
;;;1867   			b = (BYTE)p[si++];			/* Get 2nd byte */
;;;1868   			w = (w << 8) + b;			/* Create a DBC */
;;;1869   			if (!IsDBCS2(b))
;;;1870   				return FR_INVALID_NAME;	/* Reject invalid sequence */
;;;1871   		}
;;;1872   		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
;;;1873   		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
;;;1874   #endif
;;;1875   		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal characters for LFN */
;;;1876   			return FR_INVALID_NAME;
;;;1877   		lfn[di++] = w;					/* Store the Unicode character */
;;;1878   	}
;;;1879   	*path = &p[si];						/* Return pointer to the next segment */
;;;1880   	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
;;;1881   #if _FS_RPATH
;;;1882   	if ((di == 1 && lfn[di - 1] == '.') ||
;;;1883   		(di == 2 && lfn[di - 1] == '.' && lfn[di - 2] == '.')) {	/* Is this segment a dot entry? */
;;;1884   		lfn[di] = 0;
;;;1885   		for (i = 0; i < 11; i++)		/* Create dot name for SFN entry */
;;;1886   			dp->fn[i] = (i < di) ? '.' : ' ';
;;;1887   		dp->fn[i] = cf | NS_DOT;		/* This is a dot entry */
;;;1888   		return FR_OK;
;;;1889   	}
;;;1890   #endif
;;;1891   	while (di) {						/* Snip off trailing spaces and dots if exist */
;;;1892   		w = lfn[di - 1];
;;;1893   		if (w != ' ' && w != '.') break;
;;;1894   		di--;
;;;1895   	}
;;;1896   	if (!di) return FR_INVALID_NAME;	/* Reject nul string */
;;;1897   	lfn[di] = 0;						/* LFN is created */
;;;1898   
;;;1899   	/* Create SFN in directory form */
;;;1900   	mem_set(dp->fn, ' ', 11);
;;;1901   	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
;;;1902   	if (si) cf |= NS_LOSS | NS_LFN;
;;;1903   	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
;;;1904   
;;;1905   	b = i = 0; ni = 8;
;;;1906   	for (;;) {
;;;1907   		w = lfn[si++];					/* Get an LFN character */
;;;1908   		if (!w) break;					/* Break on end of the LFN */
;;;1909   		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
;;;1910   			cf |= NS_LOSS | NS_LFN; continue;
;;;1911   		}
;;;1912   
;;;1913   		if (i >= ni || si == di) {		/* Extension or end of SFN */
;;;1914   			if (ni == 11) {				/* Long extension */
;;;1915   				cf |= NS_LOSS | NS_LFN; break;
;;;1916   			}
;;;1917   			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
;;;1918   			if (si > di) break;			/* No extension */
;;;1919   			si = di; i = 8; ni = 11;	/* Enter extension section */
;;;1920   			b <<= 2; continue;
;;;1921   		}
;;;1922   
;;;1923   		if (w >= 0x80) {				/* Non ASCII character */
;;;1924   #ifdef _EXCVT
;;;1925   			w = ff_convert(w, 0);		/* Unicode -> OEM code */
;;;1926   			if (w) w = ExCvt[w - 0x80];	/* Convert extended character to upper (SBCS) */
;;;1927   #else
;;;1928   			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
;;;1929   #endif
;;;1930   			cf |= NS_LFN;				/* Force create LFN entry */
;;;1931   		}
;;;1932   
;;;1933   		if (_DF1S && w >= 0x100) {		/* Is this DBC? (always false at SBCS cfg) */
;;;1934   			if (i >= ni - 1) {
;;;1935   				cf |= NS_LOSS | NS_LFN; i = ni; continue;
;;;1936   			}
;;;1937   			dp->fn[i++] = (BYTE)(w >> 8);
;;;1938   		} else {						/* SBC */
;;;1939   			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal characters for SFN */
;;;1940   				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
;;;1941   			} else {
;;;1942   				if (IsUpper(w)) {		/* ASCII large capital */
;;;1943   					b |= 2;
;;;1944   				} else {
;;;1945   					if (IsLower(w)) {	/* ASCII small capital */
;;;1946   						b |= 1; w -= 0x20;
;;;1947   					}
;;;1948   				}
;;;1949   			}
;;;1950   		}
;;;1951   		dp->fn[i++] = (BYTE)w;
;;;1952   	}
;;;1953   
;;;1954   	if (dp->fn[0] == DDEM) dp->fn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
;;;1955   
;;;1956   	if (ni == 8) b <<= 2;
;;;1957   	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
;;;1958   		cf |= NS_LFN;
;;;1959   	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended character, NT flags are created */
;;;1960   		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
;;;1961   		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
;;;1962   	}
;;;1963   
;;;1964   	dp->fn[NSFLAG] = cf;	/* SFN is created */
;;;1965   
;;;1966   	return FR_OK;
;;;1967   
;;;1968   
;;;1969   #else	/* Non-LFN configuration */
;;;1970   	BYTE b, c, d, *sfn;
;;;1971   	UINT ni, si, i;
;;;1972   	const char *p;
;;;1973   
;;;1974   	/* Create file name in directory form */
;;;1975   	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Skip duplicated separator */
00000c  7821              LDRB     r1,[r4,#0]
00000e  292f              CMP      r1,#0x2f
000010  d0fb              BEQ      |L4.10|
000012  295c              CMP      r1,#0x5c
000014  d0f9              BEQ      |L4.10|
;;;1976   	sfn = dp->fn;
;;;1977   	mem_set(sfn, ' ', 11);
000016  6985              LDR      r5,[r0,#0x18]
000018  220b              MOVS     r2,#0xb
00001a  2120              MOVS     r1,#0x20
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       mem_set
;;;1978   	si = i = b = 0; ni = 8;
000022  2000              MOVS     r0,#0
000024  4601              MOV      r1,r0
000026  460b              MOV      r3,r1
000028  2608              MOVS     r6,#8
                  |L4.42|
;;;1979   #if _FS_RPATH
;;;1980   	if (p[si] == '.') { /* Is this a dot entry? */
;;;1981   		for (;;) {
;;;1982   			c = (BYTE)p[si++];
;;;1983   			if (c != '.' || si >= 3) break;
;;;1984   			sfn[i++] = c;
;;;1985   		}
;;;1986   		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
;;;1987   		*path = &p[si];									/* Return pointer to the next segment */
;;;1988   		sfn[NSFLAG] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
;;;1989   		return FR_OK;
;;;1990   	}
;;;1991   #endif
;;;1992   	for (;;) {
;;;1993   		c = (BYTE)p[si++];
00002a  5ce2              LDRB     r2,[r4,r3]
00002c  1c5b              ADDS     r3,r3,#1
;;;1994   		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
00002e  2a20              CMP      r2,#0x20
000030  d935              BLS      |L4.158|
000032  2a2f              CMP      r2,#0x2f
000034  d033              BEQ      |L4.158|
000036  2a5c              CMP      r2,#0x5c
000038  d031              BEQ      |L4.158|
;;;1995   		if (c == '.' || i >= ni) {
00003a  2a2e              CMP      r2,#0x2e
00003c  d001              BEQ      |L4.66|
00003e  42b0              CMP      r0,r6
000040  d308              BCC      |L4.84|
                  |L4.66|
;;;1996   			if (ni != 8 || c != '.') return FR_INVALID_NAME;
000042  2e08              CMP      r6,#8
000044  d138              BNE      |L4.184|
000046  2a2e              CMP      r2,#0x2e
000048  d136              BNE      |L4.184|
;;;1997   			i = 8; ni = 11;
00004a  2008              MOVS     r0,#8
00004c  260b              MOVS     r6,#0xb
;;;1998   			b <<= 2; continue;
00004e  0689              LSLS     r1,r1,#26
000050  0e09              LSRS     r1,r1,#24
000052  e7ea              B        |L4.42|
                  |L4.84|
;;;1999   		}
;;;2000   		if (c >= 0x80) {				/* Extended character? */
000054  2a80              CMP      r2,#0x80
000056  d305              BCC      |L4.100|
;;;2001   			b |= 3;						/* Eliminate NT flag */
;;;2002   #ifdef _EXCVT
;;;2003   			c = ExCvt[c - 0x80];		/* To upper extended characters (SBCS cfg) */
000058  4f23              LDR      r7,|L4.232|
00005a  f0410103          ORR      r1,r1,#3              ;2001
00005e  443a              ADD      r2,r2,r7
000060  f8122c80          LDRB     r2,[r2,#-0x80]
                  |L4.100|
;;;2004   #else
;;;2005   #if !_DF1S
;;;2006   			return FR_INVALID_NAME;		/* Reject extended characters (ASCII cfg) */
;;;2007   #endif
;;;2008   #endif
;;;2009   		}
;;;2010   		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false at SBCS cfg.) */
;;;2011   			d = (BYTE)p[si++];			/* Get 2nd byte */
;;;2012   			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
;;;2013   				return FR_INVALID_NAME;
;;;2014   			sfn[i++] = c;
;;;2015   			sfn[i++] = d;
;;;2016   		} else {						/* SBC */
;;;2017   			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
000064  a721              ADR      r7,|L4.236|
000066  e000              B        |L4.106|
                  |L4.104|
000068  1c7f              ADDS     r7,r7,#1
                  |L4.106|
00006a  f897c000          LDRB     r12,[r7,#0]
00006e  f1bc0f00          CMP      r12,#0
000072  d002              BEQ      |L4.122|
000074  4594              CMP      r12,r2
000076  d1f7              BNE      |L4.104|
000078  e01e              B        |L4.184|
                  |L4.122|
;;;2018   				return FR_INVALID_NAME;
;;;2019   			if (IsUpper(c)) {			/* ASCII large capital? */
00007a  f1a20741          SUB      r7,r2,#0x41
00007e  2f19              CMP      r7,#0x19
000080  d802              BHI      |L4.136|
;;;2020   				b |= 2;
000082  f0410102          ORR      r1,r1,#2
000086  e007              B        |L4.152|
                  |L4.136|
;;;2021   			} else {
;;;2022   				if (IsLower(c)) {		/* ASCII small capital? */
000088  f1a20761          SUB      r7,r2,#0x61
00008c  2f19              CMP      r7,#0x19
00008e  d803              BHI      |L4.152|
;;;2023   					b |= 1; c -= 0x20;
000090  3a20              SUBS     r2,r2,#0x20
000092  f0410101          ORR      r1,r1,#1
000096  b2d2              UXTB     r2,r2
                  |L4.152|
;;;2024   				}
;;;2025   			}
;;;2026   			sfn[i++] = c;
000098  542a              STRB     r2,[r5,r0]
00009a  1c40              ADDS     r0,r0,#1
00009c  e7c5              B        |L4.42|
                  |L4.158|
;;;2027   		}
;;;2028   	}
;;;2029   	*path = &p[si];						/* Return pointer to the next segment */
00009e  441c              ADD      r4,r4,r3
;;;2030   	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
0000a0  f8c94000          STR      r4,[r9,#0]
0000a4  2a20              CMP      r2,#0x20
0000a6  d801              BHI      |L4.172|
0000a8  2204              MOVS     r2,#4
0000aa  e000              B        |L4.174|
                  |L4.172|
0000ac  2200              MOVS     r2,#0
                  |L4.174|
;;;2031   
;;;2032   	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
0000ae  b118              CBZ      r0,|L4.184|
;;;2033   	if (sfn[0] == DDEM) sfn[0] = RDDEM;	/* When first character collides with DDEM, replace it with RDDEM */
0000b0  7828              LDRB     r0,[r5,#0]
0000b2  28e5              CMP      r0,#0xe5
0000b4  d003              BEQ      |L4.190|
0000b6  e004              B        |L4.194|
                  |L4.184|
0000b8  2006              MOVS     r0,#6                 ;2032
                  |L4.186|
;;;2034   
;;;2035   	if (ni == 8) b <<= 2;
;;;2036   	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
;;;2037   	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
;;;2038   
;;;2039   	sfn[NSFLAG] = c;		/* Store NT flag, File name is created */
;;;2040   
;;;2041   	return FR_OK;
;;;2042   #endif
;;;2043   }
0000ba  e8bd87f0          POP      {r4-r10,pc}
                  |L4.190|
0000be  2005              MOVS     r0,#5                 ;2033
0000c0  7028              STRB     r0,[r5,#0]            ;2033
                  |L4.194|
0000c2  2e08              CMP      r6,#8                 ;2035
0000c4  d101              BNE      |L4.202|
0000c6  0688              LSLS     r0,r1,#26             ;2035
0000c8  0e01              LSRS     r1,r0,#24             ;2035
                  |L4.202|
0000ca  f0010003          AND      r0,r1,#3              ;2036
0000ce  2801              CMP      r0,#1                 ;2036
0000d0  d101              BNE      |L4.214|
0000d2  f0420210          ORR      r2,r2,#0x10           ;2036
                  |L4.214|
0000d6  f3c10081          UBFX     r0,r1,#2,#2           ;2037
0000da  2801              CMP      r0,#1                 ;2037
0000dc  d101              BNE      |L4.226|
0000de  f0420208          ORR      r2,r2,#8              ;2037
                  |L4.226|
0000e2  72ea              STRB     r2,[r5,#0xb]          ;2039
0000e4  2000              MOVS     r0,#0                 ;2041
0000e6  e7e8              B        |L4.186|
;;;2044   
                          ENDP

                  |L4.232|
                          DCD      ||.constdata||
                  |L4.236|
0000ec  222a2b2c          DCB      """*+,:;<=>?[]|",127,0
0000f0  3a3b3c3d
0000f4  3e3f5b5d
0000f8  7c7f00  
0000fb  00                DCB      0

                          AREA ||i.dir_next||, CODE, READONLY, ALIGN=1

                  dir_next PROC
;;;1128   static
;;;1129   FRESULT dir_next (	/* FR_OK(0):succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch */
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1130   	DIR* dp,		/* Pointer to the directory object */
;;;1131   	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
;;;1132   )
;;;1133   {
;;;1134   	DWORD clst;
;;;1135   	UINT i;
;;;1136   #if !_FS_READONLY
;;;1137   	UINT c;
;;;1138   #endif
;;;1139   
;;;1140   
;;;1141   	i = dp->index + 1;
000004  88c6              LDRH     r6,[r0,#6]
000006  4604              MOV      r4,r0                 ;1133
000008  1c76              ADDS     r6,r6,#1
;;;1142   	if (!(i & 0xFFFF) || !dp->sect)	/* Report EOT when index has reached 65535 */
00000a  0430              LSLS     r0,r6,#16
00000c  460f              MOV      r7,r1                 ;1133
00000e  0c00              LSRS     r0,r0,#16
000010  d02c              BEQ      |L5.108|
000012  6920              LDR      r0,[r4,#0x10]
000014  b350              CBZ      r0,|L5.108|
;;;1143   		return FR_NO_FILE;
;;;1144   
;;;1145   	if (!(i % (SS(dp->fs) / SZ_DIRE))) {	/* Sector changed? */
000016  0731              LSLS     r1,r6,#28
000018  d15a              BNE      |L5.208|
00001a  1c40              ADDS     r0,r0,#1
;;;1146   		dp->sect++;					/* Next sector */
;;;1147   
;;;1148   		if (!dp->clust) {		/* Static table */
00001c  6120              STR      r0,[r4,#0x10]
00001e  68e1              LDR      r1,[r4,#0xc]
000020  6820              LDR      r0,[r4,#0]
000022  b129              CBZ      r1,|L5.48|
;;;1149   			if (i >= dp->fs->n_rootdir)	/* Report EOT if it reached end of static table */
;;;1150   				return FR_NO_FILE;
;;;1151   		}
;;;1152   		else {					/* Dynamic table */
;;;1153   			if (((i / (SS(dp->fs) / SZ_DIRE)) & (dp->fs->csize - 1)) == 0) {	/* Cluster changed? */
000024  7882              LDRB     r2,[r0,#2]
000026  1e52              SUBS     r2,r2,#1
000028  ea121f16          TST      r2,r6,LSR #4
00002c  d004              BEQ      |L5.56|
00002e  e04f              B        |L5.208|
                  |L5.48|
000030  8900              LDRH     r0,[r0,#8]            ;1149
000032  42b0              CMP      r0,r6                 ;1149
000034  d91a              BLS      |L5.108|
000036  e04b              B        |L5.208|
                  |L5.56|
;;;1154   				clst = get_fat(dp->fs, dp->clust);				/* Get next cluster */
000038  f7fffffe          BL       get_fat
00003c  4605              MOV      r5,r0
;;;1155   				if (clst <= 1) return FR_INT_ERR;
00003e  2801              CMP      r0,#1
000040  d919              BLS      |L5.118|
;;;1156   				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
000042  1c68              ADDS     r0,r5,#1
000044  d030              BEQ      |L5.168|
;;;1157   				if (clst >= dp->fs->n_fatent) {					/* If it reached end of dynamic table, */
000046  6820              LDR      r0,[r4,#0]
000048  6941              LDR      r1,[r0,#0x14]
00004a  42a9              CMP      r1,r5
00004c  d83a              BHI      |L5.196|
;;;1158   #if !_FS_READONLY
;;;1159   					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT */
00004e  b16f              CBZ      r7,|L5.108|
;;;1160   					clst = create_chain(dp->fs, dp->clust);		/* Stretch cluster chain */
000050  68e1              LDR      r1,[r4,#0xc]
000052  f7fffffe          BL       create_chain
000056  0005              MOVS     r5,r0
;;;1161   					if (clst == 0) return FR_DENIED;			/* No free cluster */
000058  d00b              BEQ      |L5.114|
;;;1162   					if (clst == 1) return FR_INT_ERR;
00005a  2d01              CMP      r5,#1
00005c  d00b              BEQ      |L5.118|
;;;1163   					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
00005e  1c68              ADDS     r0,r5,#1
000060  d022              BEQ      |L5.168|
;;;1164   					/* Clean-up stretched table */
;;;1165   					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
000062  6820              LDR      r0,[r4,#0]
000064  f7fffffe          BL       sync_window
000068  b9f0              CBNZ     r0,|L5.168|
00006a  e006              B        |L5.122|
                  |L5.108|
00006c  2004              MOVS     r0,#4                 ;1159
                  |L5.110|
;;;1166   					mem_set(dp->fs->win, 0, SS(dp->fs));		/* Clear window buffer */
;;;1167   					dp->fs->winsect = clust2sect(dp->fs, clst);	/* Cluster start sector */
;;;1168   					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
;;;1169   						dp->fs->wflag = 1;
;;;1170   						if (sync_window(dp->fs)) return FR_DISK_ERR;
;;;1171   						dp->fs->winsect++;
;;;1172   					}
;;;1173   					dp->fs->winsect -= c;						/* Rewind window offset */
;;;1174   #else
;;;1175   					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT (this is to suppress warning) */
;;;1176   					return FR_NO_FILE;							/* Report EOT */
;;;1177   #endif
;;;1178   				}
;;;1179   				dp->clust = clst;				/* Initialize data for new cluster */
;;;1180   				dp->sect = clust2sect(dp->fs, clst);
;;;1181   			}
;;;1182   		}
;;;1183   	}
;;;1184   
;;;1185   	dp->index = (WORD)i;	/* Current index */
;;;1186   	dp->dir = dp->fs->win + (i % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE;	/* Current entry in the window */
;;;1187   
;;;1188   	return FR_OK;
;;;1189   }
00006e  e8bd81f0          POP      {r4-r8,pc}
                  |L5.114|
000072  2007              MOVS     r0,#7                 ;1161
000074  e7fb              B        |L5.110|
                  |L5.118|
000076  2002              MOVS     r0,#2                 ;1162
000078  e7f9              B        |L5.110|
                  |L5.122|
00007a  6820              LDR      r0,[r4,#0]            ;1166
00007c  f44f7200          MOV      r2,#0x200             ;1166
000080  2100              MOVS     r1,#0                 ;1166
000082  3030              ADDS     r0,r0,#0x30           ;1166
000084  f7fffffe          BL       mem_set
000088  4629              MOV      r1,r5                 ;1167
00008a  6820              LDR      r0,[r4,#0]            ;1167
00008c  f7fffffe          BL       clust2sect
000090  6821              LDR      r1,[r4,#0]            ;1167
000092  2700              MOVS     r7,#0                 ;1168
000094  f04f0801          MOV      r8,#1                 ;1156
000098  62c8              STR      r0,[r1,#0x2c]         ;1168
00009a  e00c              B        |L5.182|
                  |L5.156|
00009c  f8808004          STRB     r8,[r0,#4]            ;1169
0000a0  6820              LDR      r0,[r4,#0]            ;1170
0000a2  f7fffffe          BL       sync_window
0000a6  b108              CBZ      r0,|L5.172|
                  |L5.168|
0000a8  2001              MOVS     r0,#1                 ;1170
0000aa  e7e0              B        |L5.110|
                  |L5.172|
0000ac  6820              LDR      r0,[r4,#0]            ;1171
0000ae  6ac1              LDR      r1,[r0,#0x2c]         ;1171
0000b0  1c49              ADDS     r1,r1,#1              ;1171
0000b2  1c7f              ADDS     r7,r7,#1              ;1171
0000b4  62c1              STR      r1,[r0,#0x2c]         ;1171
                  |L5.182|
0000b6  6820              LDR      r0,[r4,#0]            ;1168
0000b8  7881              LDRB     r1,[r0,#2]            ;1168
0000ba  42b9              CMP      r1,r7                 ;1168
0000bc  d8ee              BHI      |L5.156|
0000be  6ac1              LDR      r1,[r0,#0x2c]         ;1173
0000c0  1bc9              SUBS     r1,r1,r7              ;1173
0000c2  62c1              STR      r1,[r0,#0x2c]         ;1173
                  |L5.196|
0000c4  60e5              STR      r5,[r4,#0xc]          ;1180
0000c6  4629              MOV      r1,r5                 ;1180
0000c8  6820              LDR      r0,[r4,#0]            ;1180
0000ca  f7fffffe          BL       clust2sect
0000ce  6120              STR      r0,[r4,#0x10]         ;1180
                  |L5.208|
0000d0  80e6              STRH     r6,[r4,#6]            ;1185
0000d2  f006010f          AND      r1,r6,#0xf            ;1186
0000d6  2230              MOVS     r2,#0x30              ;1186
0000d8  6820              LDR      r0,[r4,#0]            ;1186
0000da  eb021141          ADD      r1,r2,r1,LSL #5       ;1186
0000de  4408              ADD      r0,r0,r1              ;1186
0000e0  6160              STR      r0,[r4,#0x14]         ;1188
0000e2  2000              MOVS     r0,#0                 ;1188
0000e4  e7c3              B        |L5.110|
;;;1190   
                          ENDP


                          AREA ||i.dir_read||, CODE, READONLY, ALIGN=1

                  dir_read PROC
;;;1519   static
;;;1520   FRESULT dir_read (
000000  b570              PUSH     {r4-r6,lr}
;;;1521   	DIR* dp,		/* Pointer to the directory object */
;;;1522   	int vol			/* Filtered by 0:file/directory or 1:volume label */
;;;1523   )
;;;1524   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1525   	FRESULT res;
;;;1526   	BYTE a, c, *dir;
;;;1527   #if _USE_LFN
;;;1528   	BYTE ord = 0xFF, sum = 0xFF;
;;;1529   #endif
;;;1530   
;;;1531   	res = FR_NO_FILE;
000006  2004              MOVS     r0,#4
000008  e020              B        |L6.76|
                  |L6.10|
;;;1532   	while (dp->sect) {
;;;1533   		res = move_window(dp->fs, dp->sect);
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       move_window
;;;1534   		if (res != FR_OK) break;
000010  bb08              CBNZ     r0,|L6.86|
;;;1535   		dir = dp->dir;					/* Ptr to the directory entry of current index */
;;;1536   		c = dir[DIR_Name];
000012  6961              LDR      r1,[r4,#0x14]
000014  780a              LDRB     r2,[r1,#0]
;;;1537   		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
000016  b1aa              CBZ      r2,|L6.68|
;;;1538   		a = dir[DIR_Attr] & AM_MASK;
000018  7ac9              LDRB     r1,[r1,#0xb]
;;;1539   #if _USE_LFN	/* LFN configuration */
;;;1540   		if (c == DDEM || (!_FS_RPATH && c == '.') || (int)((a & ~AM_ARC) == AM_VOL) != vol) {	/* An entry without valid data */
;;;1541   			ord = 0xFF;
;;;1542   		} else {
;;;1543   			if (a == AM_LFN) {			/* An LFN entry is found */
;;;1544   				if (c & LLEF) {			/* Is it start of LFN sequence? */
;;;1545   					sum = dir[LDIR_Chksum];
;;;1546   					c &= ~LLEF; ord = c;
;;;1547   					dp->lfn_idx = dp->index;
;;;1548   				}
;;;1549   				/* Check LFN validity and capture it */
;;;1550   				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dp->lfn, dir)) ? ord - 1 : 0xFF;
;;;1551   			} else {					/* An SFN entry is found */
;;;1552   				if (ord || sum != sum_sfn(dir))	/* Is there a valid LFN? */
;;;1553   					dp->lfn_idx = 0xFFFF;		/* It has no LFN. */
;;;1554   				break;
;;;1555   			}
;;;1556   		}
;;;1557   #else		/* Non LFN configuration */
;;;1558   		if (c != DDEM && (_FS_RPATH || c != '.') && a != AM_LFN && (int)((a & ~AM_ARC) == AM_VOL) == vol)	/* Is it a valid entry? */
00001a  2ae5              CMP      r2,#0xe5
00001c  f001013f          AND      r1,r1,#0x3f           ;1538
000020  d00a              BEQ      |L6.56|
000022  2a2e              CMP      r2,#0x2e
000024  d008              BEQ      |L6.56|
000026  290f              CMP      r1,#0xf
000028  d006              BEQ      |L6.56|
00002a  f0210120          BIC      r1,r1,#0x20
00002e  2908              CMP      r1,#8
000030  d00a              BEQ      |L6.72|
000032  2100              MOVS     r1,#0
                  |L6.52|
000034  42a9              CMP      r1,r5
000036  d010              BEQ      |L6.90|
                  |L6.56|
;;;1559   			break;
;;;1560   #endif
;;;1561   		res = dir_next(dp, 0);				/* Next entry */
000038  2100              MOVS     r1,#0
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       dir_next
;;;1562   		if (res != FR_OK) break;
000040  b120              CBZ      r0,|L6.76|
000042  e008              B        |L6.86|
                  |L6.68|
000044  2004              MOVS     r0,#4                 ;1537
000046  e006              B        |L6.86|
                  |L6.72|
000048  2101              MOVS     r1,#1                 ;1558
00004a  e7f3              B        |L6.52|
                  |L6.76|
00004c  6921              LDR      r1,[r4,#0x10]         ;1532
00004e  2900              CMP      r1,#0                 ;1532
000050  d1db              BNE      |L6.10|
;;;1563   	}
;;;1564   
;;;1565   	if (res != FR_OK) dp->sect = 0;
000052  2800              CMP      r0,#0
000054  d001              BEQ      |L6.90|
                  |L6.86|
000056  2100              MOVS     r1,#0
000058  6121              STR      r1,[r4,#0x10]
                  |L6.90|
;;;1566   
;;;1567   	return res;
;;;1568   }
00005a  bd70              POP      {r4-r6,pc}
;;;1569   #endif	/* _FS_MINIMIZE <= 1 || _USE_LABEL || _FS_RPATH >= 2 */
                          ENDP


                          AREA ||i.dir_register||, CODE, READONLY, ALIGN=1

                  dir_register PROC
;;;1578   static
;;;1579   FRESULT dir_register (	/* FR_OK:succeeded, FR_DENIED:no free entry or too many SFN collision, FR_DISK_ERR:disk error */
000000  b570              PUSH     {r4-r6,lr}
;;;1580   	DIR* dp				/* Target directory with object name to be created */
;;;1581   )
;;;1582   {
000002  4604              MOV      r4,r0
000004  2100              MOVS     r1,#0
000006  f7fffffe          BL       dir_sdi
00000a  e00d              B        |L7.40|
                  |L7.12|
00000c  6921              LDR      r1,[r4,#0x10]
00000e  6820              LDR      r0,[r4,#0]
000010  f7fffffe          BL       move_window
000014  b950              CBNZ     r0,|L7.44|
000016  6960              LDR      r0,[r4,#0x14]
000018  7800              LDRB     r0,[r0,#0]
00001a  28e5              CMP      r0,#0xe5
00001c  d009              BEQ      |L7.50|
00001e  b140              CBZ      r0,|L7.50|
000020  2101              MOVS     r1,#1
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       dir_next
                  |L7.40|
000028  2800              CMP      r0,#0
00002a  d0ef              BEQ      |L7.12|
                  |L7.44|
00002c  2804              CMP      r0,#4
00002e  d007              BEQ      |L7.64|
000030  e007              B        |L7.66|
                  |L7.50|
;;;1583   	FRESULT res;
;;;1584   #if _USE_LFN	/* LFN configuration */
;;;1585   	UINT n, nent;
;;;1586   	BYTE sn[12], *fn, sum;
;;;1587   	WCHAR *lfn;
;;;1588   
;;;1589   
;;;1590   	fn = dp->fn; lfn = dp->lfn;
;;;1591   	mem_cpy(sn, fn, 12);
;;;1592   
;;;1593   	if (_FS_RPATH && (sn[NSFLAG] & NS_DOT))		/* Cannot create dot entry */
;;;1594   		return FR_INVALID_NAME;
;;;1595   
;;;1596   	if (sn[NSFLAG] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
;;;1597   		fn[NSFLAG] = 0; dp->lfn = 0;			/* Find only SFN */
;;;1598   		for (n = 1; n < 100; n++) {
;;;1599   			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
;;;1600   			res = dir_find(dp);				/* Check if the name collides with existing SFN */
;;;1601   			if (res != FR_OK) break;
;;;1602   		}
;;;1603   		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
;;;1604   		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
;;;1605   		fn[NSFLAG] = sn[NSFLAG]; dp->lfn = lfn;
;;;1606   	}
;;;1607   
;;;1608   	if (sn[NSFLAG] & NS_LFN) {			/* When LFN is to be created, allocate entries for an SFN + LFNs. */
;;;1609   		for (n = 0; lfn[n]; n++) ;
;;;1610   		nent = (n + 25) / 13;
;;;1611   	} else {						/* Otherwise allocate an entry for an SFN  */
;;;1612   		nent = 1;
;;;1613   	}
;;;1614   	res = dir_alloc(dp, nent);		/* Allocate entries */
;;;1615   
;;;1616   	if (res == FR_OK && --nent) {	/* Set LFN entry if needed */
;;;1617   		res = dir_sdi(dp, dp->index - nent);
;;;1618   		if (res == FR_OK) {
;;;1619   			sum = sum_sfn(dp->fn);	/* Checksum value of the SFN tied to the LFN */
;;;1620   			do {					/* Store LFN entries in bottom first */
;;;1621   				res = move_window(dp->fs, dp->sect);
;;;1622   				if (res != FR_OK) break;
;;;1623   				fit_lfn(dp->lfn, dp->dir, (BYTE)nent, sum);
;;;1624   				dp->fs->wflag = 1;
;;;1625   				res = dir_next(dp, 0);	/* Next entry */
;;;1626   			} while (res == FR_OK && --nent);
;;;1627   		}
;;;1628   	}
;;;1629   #else	/* Non LFN configuration */
;;;1630   	res = dir_alloc(dp, 1);		/* Allocate an entry for SFN */
;;;1631   #endif
;;;1632   
;;;1633   	if (res == FR_OK) {				/* Set SFN entry */
;;;1634   		res = move_window(dp->fs, dp->sect);
000032  6921              LDR      r1,[r4,#0x10]
000034  6820              LDR      r0,[r4,#0]
000036  f7fffffe          BL       move_window
00003a  0005              MOVS     r5,r0
00003c  d003              BEQ      |L7.70|
00003e  e00f              B        |L7.96|
                  |L7.64|
000040  2007              MOVS     r0,#7
                  |L7.66|
000042  4605              MOV      r5,r0                 ;1630
000044  e00c              B        |L7.96|
                  |L7.70|
;;;1635   		if (res == FR_OK) {
;;;1636   			mem_set(dp->dir, 0, SZ_DIRE);	/* Clean the entry */
000046  2220              MOVS     r2,#0x20
000048  2100              MOVS     r1,#0
00004a  6960              LDR      r0,[r4,#0x14]
00004c  f7fffffe          BL       mem_set
;;;1637   			mem_cpy(dp->dir, dp->fn, 11);	/* Put SFN */
000050  e9d40105          LDRD     r0,r1,[r4,#0x14]
000054  220b              MOVS     r2,#0xb
000056  f7fffffe          BL       mem_cpy
;;;1638   #if _USE_LFN
;;;1639   			dp->dir[DIR_NTres] = dp->fn[NSFLAG] & (NS_BODY | NS_EXT);	/* Put NT flag */
;;;1640   #endif
;;;1641   			dp->fs->wflag = 1;
00005a  6821              LDR      r1,[r4,#0]
00005c  2001              MOVS     r0,#1
00005e  7108              STRB     r0,[r1,#4]
                  |L7.96|
;;;1642   		}
;;;1643   	}
;;;1644   
;;;1645   	return res;
000060  4628              MOV      r0,r5
;;;1646   }
000062  bd70              POP      {r4-r6,pc}
;;;1647   #endif /* !_FS_READONLY */
                          ENDP


                          AREA ||i.dir_remove||, CODE, READONLY, ALIGN=1

                  dir_remove PROC
;;;1656   static
;;;1657   FRESULT dir_remove (	/* FR_OK:Succeeded, FR_DISK_ERR:A disk error */
000000  b570              PUSH     {r4-r6,lr}
;;;1658   	DIR* dp				/* Directory object pointing the entry to be removed */
;;;1659   )
;;;1660   {
000002  4604              MOV      r4,r0
;;;1661   	FRESULT res;
;;;1662   #if _USE_LFN	/* LFN configuration */
;;;1663   	UINT i;
;;;1664   
;;;1665   	i = dp->index;	/* SFN index */
;;;1666   	res = dir_sdi(dp, (dp->lfn_idx == 0xFFFF) ? i : dp->lfn_idx);	/* Goto the SFN or top of the LFN entries */
;;;1667   	if (res == FR_OK) {
;;;1668   		do {
;;;1669   			res = move_window(dp->fs, dp->sect);
;;;1670   			if (res != FR_OK) break;
;;;1671   			mem_set(dp->dir, 0, SZ_DIRE);	/* Clear and mark the entry "deleted" */
;;;1672   			*dp->dir = DDEM;
;;;1673   			dp->fs->wflag = 1;
;;;1674   			if (dp->index >= i) break;	/* When reached SFN, all entries of the object has been deleted. */
;;;1675   			res = dir_next(dp, 0);		/* Next entry */
;;;1676   		} while (res == FR_OK);
;;;1677   		if (res == FR_NO_FILE) res = FR_INT_ERR;
;;;1678   	}
;;;1679   
;;;1680   #else			/* Non LFN configuration */
;;;1681   	res = dir_sdi(dp, dp->index);
000004  88c1              LDRH     r1,[r0,#6]
000006  f7fffffe          BL       dir_sdi
00000a  0005              MOVS     r5,r0
;;;1682   	if (res == FR_OK) {
00000c  d110              BNE      |L8.48|
;;;1683   		res = move_window(dp->fs, dp->sect);
00000e  6921              LDR      r1,[r4,#0x10]
000010  6820              LDR      r0,[r4,#0]
000012  f7fffffe          BL       move_window
000016  0005              MOVS     r5,r0
;;;1684   		if (res == FR_OK) {
000018  d10a              BNE      |L8.48|
;;;1685   			mem_set(dp->dir, 0, SZ_DIRE);	/* Clear and mark the entry "deleted" */
00001a  2220              MOVS     r2,#0x20
00001c  2100              MOVS     r1,#0
00001e  6960              LDR      r0,[r4,#0x14]
000020  f7fffffe          BL       mem_set
;;;1686   			*dp->dir = DDEM;
000024  6961              LDR      r1,[r4,#0x14]
000026  20e5              MOVS     r0,#0xe5
000028  7008              STRB     r0,[r1,#0]
;;;1687   			dp->fs->wflag = 1;
00002a  6821              LDR      r1,[r4,#0]
00002c  2001              MOVS     r0,#1
00002e  7108              STRB     r0,[r1,#4]
                  |L8.48|
;;;1688   		}
;;;1689   	}
;;;1690   #endif
;;;1691   
;;;1692   	return res;
000030  4628              MOV      r0,r5
;;;1693   }
000032  bd70              POP      {r4-r6,pc}
;;;1694   #endif /* !_FS_READONLY */
                          ENDP


                          AREA ||i.dir_sdi||, CODE, READONLY, ALIGN=2

                  dir_sdi PROC
;;;1080   static
;;;1081   FRESULT dir_sdi (	/* FR_OK(0):succeeded, !=0:error */
000000  b570              PUSH     {r4-r6,lr}
;;;1082   	DIR* dp,		/* Pointer to directory object */
;;;1083   	UINT idx		/* Index of directory table */
;;;1084   )
;;;1085   {
;;;1086   	DWORD clst, sect;
;;;1087   	UINT ic;
;;;1088   
;;;1089   
;;;1090   	dp->index = (WORD)idx;	/* Current index */
000002  80c1              STRH     r1,[r0,#6]
;;;1091   	clst = dp->sclust;		/* Table start cluster (0:root) */
;;;1092   	if (clst == 1 || clst >= dp->fs->n_fatent)	/* Check start cluster range */
000004  6883              LDR      r3,[r0,#8]
000006  460d              MOV      r5,r1                 ;1085
000008  4604              MOV      r4,r0                 ;1085
00000a  2b01              CMP      r3,#1
00000c  d035              BEQ      |L9.122|
00000e  6820              LDR      r0,[r4,#0]
000010  6941              LDR      r1,[r0,#0x14]
000012  4299              CMP      r1,r3
000014  d931              BLS      |L9.122|
;;;1093   		return FR_INT_ERR;
;;;1094   	if (!clst && dp->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
000016  b923              CBNZ     r3,|L9.34|
000018  7801              LDRB     r1,[r0,#0]
00001a  2903              CMP      r1,#3
00001c  d104              BNE      |L9.40|
;;;1095   		clst = dp->fs->dirbase;
00001e  6a43              LDR      r3,[r0,#0x24]
000020  b113              CBZ      r3,|L9.40|
                  |L9.34|
;;;1096   
;;;1097   	if (clst == 0) {	/* Static table (root-directory in FAT12/16) */
;;;1098   		if (idx >= dp->fs->n_rootdir)	/* Is index out of range? */
;;;1099   			return FR_INT_ERR;
;;;1100   		sect = dp->fs->dirbase;
;;;1101   	}
;;;1102   	else {				/* Dynamic table (root-directory in FAT32 or sub-directory) */
;;;1103   		ic = SS(dp->fs) / SZ_DIRE * dp->fs->csize;	/* Entries per cluster */
000022  7880              LDRB     r0,[r0,#2]
000024  0106              LSLS     r6,r0,#4
;;;1104   		while (idx >= ic) {	/* Follow cluster chain */
000026  e011              B        |L9.76|
                  |L9.40|
000028  8901              LDRH     r1,[r0,#8]            ;1098
00002a  42a9              CMP      r1,r5                 ;1098
00002c  d925              BLS      |L9.122|
00002e  6a40              LDR      r0,[r0,#0x24]         ;1100
000030  e012              B        |L9.88|
;;;1105   			clst = get_fat(dp->fs, clst);				/* Get next cluster */
000032  bf00              NOP      
                  |L9.52|
000034  f7fffffe          BL       get_fat
000038  4603              MOV      r3,r0
;;;1106   			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
00003a  1c40              ADDS     r0,r0,#1
00003c  d01b              BEQ      |L9.118|
;;;1107   			if (clst < 2 || clst >= dp->fs->n_fatent)	/* Reached to end of table or internal error */
00003e  2b02              CMP      r3,#2
000040  d31b              BCC      |L9.122|
000042  6820              LDR      r0,[r4,#0]
000044  6940              LDR      r0,[r0,#0x14]
000046  4298              CMP      r0,r3
000048  d917              BLS      |L9.122|
;;;1108   				return FR_INT_ERR;
;;;1109   			idx -= ic;
00004a  1bad              SUBS     r5,r5,r6
                  |L9.76|
00004c  6820              LDR      r0,[r4,#0]            ;1104
00004e  42b5              CMP      r5,r6                 ;1104
;;;1110   		}
;;;1111   		sect = clust2sect(dp->fs, clst);
000050  4619              MOV      r1,r3
000052  d2ef              BCS      |L9.52|
000054  f7fffffe          BL       clust2sect
                  |L9.88|
;;;1112   	}
;;;1113   	dp->clust = clst;	/* Current cluster# */
;;;1114   	if (!sect) return FR_INT_ERR;
000058  60e3              STR      r3,[r4,#0xc]
00005a  b170              CBZ      r0,|L9.122|
;;;1115   	dp->sect = sect + idx / (SS(dp->fs) / SZ_DIRE);					/* Sector# of the directory entry */
00005c  eb001015          ADD      r0,r0,r5,LSR #4
;;;1116   	dp->dir = dp->fs->win + (idx % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE;	/* Ptr to the entry in the sector */
000060  6120              STR      r0,[r4,#0x10]
000062  f005010f          AND      r1,r5,#0xf
000066  2230              MOVS     r2,#0x30
000068  6820              LDR      r0,[r4,#0]
00006a  eb021141          ADD      r1,r2,r1,LSL #5
00006e  4408              ADD      r0,r0,r1
;;;1117   
;;;1118   	return FR_OK;
000070  6160              STR      r0,[r4,#0x14]
000072  2000              MOVS     r0,#0
;;;1119   }
000074  bd70              POP      {r4-r6,pc}
                  |L9.118|
000076  2001              MOVS     r0,#1                 ;1106
000078  bd70              POP      {r4-r6,pc}
                  |L9.122|
00007a  2002              MOVS     r0,#2                 ;1114
00007c  bd70              POP      {r4-r6,pc}
;;;1120   
                          ENDP


                          AREA ||i.f_chmod||, CODE, READONLY, ALIGN=1

                  f_chmod PROC
;;;3676   
;;;3677   FRESULT f_chmod (
000000  b537              PUSH     {r0-r2,r4,r5,lr}
;;;3678   	const TCHAR* path,	/* Pointer to the file path */
;;;3679   	BYTE attr,			/* Attribute bits */
;;;3680   	BYTE mask			/* Attribute mask to change */
;;;3681   )
;;;3682   {
000002  b08a              SUB      sp,sp,#0x28
000004  4615              MOV      r5,r2
000006  460c              MOV      r4,r1
;;;3683   	FRESULT res;
;;;3684   	DIR dj;
;;;3685   	BYTE *dir;
;;;3686   	DEFINE_NAMEBUF;
;;;3687   
;;;3688   
;;;3689   	res = find_volume(&dj.fs, &path, 1);	/* Get logical drive number */
000008  2201              MOVS     r2,#1
00000a  a90a              ADD      r1,sp,#0x28
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       find_volume
;;;3690   	if (res == FR_OK) {
000012  2800              CMP      r0,#0
000014  d116              BNE      |L10.68|
;;;3691   		INIT_BUF(dj);
000016  a807              ADD      r0,sp,#0x1c
;;;3692   		res = follow_path(&dj, path);		/* Follow the file path */
000018  9006              STR      r0,[sp,#0x18]
00001a  4668              MOV      r0,sp
00001c  990a              LDR      r1,[sp,#0x28]
00001e  f7fffffe          BL       follow_path
;;;3693   		FREE_BUF();
;;;3694   		if (_FS_RPATH && res == FR_OK && (dj.fn[NSFLAG] & NS_DOT))
;;;3695   			res = FR_INVALID_NAME;
;;;3696   		if (res == FR_OK) {
000022  2800              CMP      r0,#0
000024  d10e              BNE      |L10.68|
;;;3697   			dir = dj.dir;
;;;3698   			if (!dir) {						/* Is it a root directory? */
000026  9805              LDR      r0,[sp,#0x14]
000028  b170              CBZ      r0,|L10.72|
;;;3699   				res = FR_INVALID_NAME;
;;;3700   			} else {						/* File or sub directory */
;;;3701   				mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;	/* Valid attribute mask */
00002a  f0050127          AND      r1,r5,#0x27
;;;3702   				dir[DIR_Attr] = (attr & mask) | (dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
00002e  7ac2              LDRB     r2,[r0,#0xb]
000030  400c              ANDS     r4,r4,r1
000032  438a              BICS     r2,r2,r1
000034  4314              ORRS     r4,r4,r2
000036  72c4              STRB     r4,[r0,#0xb]
;;;3703   				dj.fs->wflag = 1;
000038  9900              LDR      r1,[sp,#0]
00003a  2001              MOVS     r0,#1
00003c  7108              STRB     r0,[r1,#4]
;;;3704   				res = sync_fs(dj.fs);
00003e  9800              LDR      r0,[sp,#0]
000040  f7fffffe          BL       sync_fs
                  |L10.68|
;;;3705   			}
;;;3706   		}
;;;3707   	}
;;;3708   
;;;3709   	LEAVE_FF(dj.fs, res);
;;;3710   }
000044  b00d              ADD      sp,sp,#0x34
000046  bd30              POP      {r4,r5,pc}
                  |L10.72|
000048  2006              MOVS     r0,#6                 ;3699
00004a  e7fb              B        |L10.68|
;;;3711   
                          ENDP


                          AREA ||i.f_close||, CODE, READONLY, ALIGN=1

                  f_close PROC
;;;2864   
;;;2865   FRESULT f_close (
000000  b510              PUSH     {r4,lr}
;;;2866   	FIL *fp		/* Pointer to the file object to be closed */
;;;2867   )
;;;2868   {
000002  4604              MOV      r4,r0
;;;2869   	FRESULT res;
;;;2870   
;;;2871   
;;;2872   #if !_FS_READONLY
;;;2873   	res = f_sync(fp);					/* Flush cached data */
000004  f7fffffe          BL       f_sync
;;;2874   	if (res == FR_OK)
000008  2800              CMP      r0,#0
00000a  d106              BNE      |L11.26|
;;;2875   #endif
;;;2876   	{
;;;2877   		res = validate(fp);				/* Lock volume */
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       validate
;;;2878   		if (res == FR_OK) {
000012  2800              CMP      r0,#0
000014  d101              BNE      |L11.26|
;;;2879   #if _FS_REENTRANT
;;;2880   			FATFS *fs = fp->fs;
;;;2881   #endif
;;;2882   #if _FS_LOCK
;;;2883   			res = dec_lock(fp->lockid);	/* Decrement file open counter */
;;;2884   			if (res == FR_OK)
;;;2885   #endif
;;;2886   				fp->fs = 0;				/* Invalidate file object */
000016  2100              MOVS     r1,#0
000018  6021              STR      r1,[r4,#0]
                  |L11.26|
;;;2887   #if _FS_REENTRANT
;;;2888   			unlock_fs(fs, FR_OK);		/* Unlock volume */
;;;2889   #endif
;;;2890   		}
;;;2891   	}
;;;2892   	return res;
;;;2893   }
00001a  bd10              POP      {r4,pc}
;;;2894   
                          ENDP


                          AREA ||i.f_closedir||, CODE, READONLY, ALIGN=1

                  f_closedir PROC
;;;3250   
;;;3251   FRESULT f_closedir (
000000  b510              PUSH     {r4,lr}
;;;3252   	DIR *dp		/* Pointer to the directory object to be closed */
;;;3253   )
;;;3254   {
000002  4604              MOV      r4,r0
;;;3255   	FRESULT res;
;;;3256   
;;;3257   
;;;3258   	res = validate(dp);
000004  f7fffffe          BL       validate
;;;3259   	if (res == FR_OK) {
000008  2800              CMP      r0,#0
00000a  d101              BNE      |L12.16|
;;;3260   #if _FS_REENTRANT
;;;3261   		FATFS *fs = dp->fs;
;;;3262   #endif
;;;3263   #if _FS_LOCK
;;;3264   		if (dp->lockid)				/* Decrement sub-directory open counter */
;;;3265   			res = dec_lock(dp->lockid);
;;;3266   		if (res == FR_OK)
;;;3267   #endif
;;;3268   			dp->fs = 0;				/* Invalidate directory object */
00000c  2100              MOVS     r1,#0
00000e  6021              STR      r1,[r4,#0]
                  |L12.16|
;;;3269   #if _FS_REENTRANT
;;;3270   		unlock_fs(fs, FR_OK);		/* Unlock volume */
;;;3271   #endif
;;;3272   	}
;;;3273   	return res;
;;;3274   }
000010  bd10              POP      {r4,pc}
;;;3275   
                          ENDP


                          AREA ||i.f_getfree||, CODE, READONLY, ALIGN=1

                  f_getfree PROC
;;;3411   
;;;3412   FRESULT f_getfree (
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;3413   	const TCHAR* path,	/* Path name of the logical drive number */
;;;3414   	DWORD* nclst,		/* Pointer to a variable to return number of free clusters */
;;;3415   	FATFS** fatfs		/* Pointer to return pointer to corresponding file system object */
;;;3416   )
;;;3417   {
000004  4614              MOV      r4,r2
000006  468a              MOV      r10,r1
;;;3418   	FRESULT res;
;;;3419   	FATFS *fs;
;;;3420   	DWORD nfree, clst, sect, stat;
;;;3421   	UINT i;
;;;3422   	BYTE fat, *p;
;;;3423   
;;;3424   
;;;3425   	/* Get logical drive number */
;;;3426   	res = find_volume(fatfs, &path, 0);
000008  2200              MOVS     r2,#0
00000a  4669              MOV      r1,sp
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       find_volume
;;;3427   	fs = *fatfs;
000012  6824              LDR      r4,[r4,#0]
000014  ea5f0800          MOVS     r8,r0                 ;3426
;;;3428   	if (res == FR_OK) {
000018  d14f              BNE      |L13.186|
00001a  e9d40704          LDRD     r0,r7,[r4,#0x10]
;;;3429   		/* If free_clust is valid, return it without full cluster scan */
;;;3430   		if (fs->free_clust <= fs->n_fatent - 2) {
00001e  1eb9              SUBS     r1,r7,#2
000020  4288              CMP      r0,r1
000022  d802              BHI      |L13.42|
;;;3431   			*nclst = fs->free_clust;
000024  f8ca0000          STR      r0,[r10,#0]
000028  e047              B        |L13.186|
                  |L13.42|
;;;3432   		} else {
;;;3433   			/* Get number of free clusters */
;;;3434   			fat = fs->fs_type;
00002a  f8949000          LDRB     r9,[r4,#0]
;;;3435   			nfree = 0;
00002e  2500              MOVS     r5,#0
;;;3436   			if (fat == FS_FAT12) {	/* Sector unalighed entries: Search FAT via regular routine. */
000030  f1b90f01          CMP      r9,#1
000034  d001              BEQ      |L13.58|
;;;3437   				clst = 2;
;;;3438   				do {
;;;3439   					stat = get_fat(fs, clst);
;;;3440   					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
;;;3441   					if (stat == 1) { res = FR_INT_ERR; break; }
;;;3442   					if (stat == 0) nfree++;
;;;3443   				} while (++clst < fs->n_fatent);
;;;3444   			} else {				/* Sector alighed entries: Accelerate the FAT search. */
;;;3445   				clst = fs->n_fatent; sect = fs->fatbase;
;;;3446   				i = 0; p = 0;
;;;3447   				do {
000036  6a26              LDR      r6,[r4,#0x20]
000038  e016              B        |L13.104|
                  |L13.58|
00003a  2602              MOVS     r6,#2                 ;3437
                  |L13.60|
00003c  4631              MOV      r1,r6                 ;3439
00003e  4620              MOV      r0,r4                 ;3439
000040  f7fffffe          BL       get_fat
000044  1c41              ADDS     r1,r0,#1              ;3440
000046  d003              BEQ      |L13.80|
000048  2801              CMP      r0,#1                 ;3441
00004a  d003              BEQ      |L13.84|
00004c  b128              CBZ      r0,|L13.90|
00004e  e005              B        |L13.92|
                  |L13.80|
000050  2001              MOVS     r0,#1                 ;3440
000052  e000              B        |L13.86|
                  |L13.84|
000054  2002              MOVS     r0,#2                 ;3441
                  |L13.86|
000056  4680              MOV      r8,r0                 ;3441
000058  e028              B        |L13.172|
                  |L13.90|
00005a  1c6d              ADDS     r5,r5,#1              ;3441
                  |L13.92|
00005c  6960              LDR      r0,[r4,#0x14]         ;3443
00005e  1c76              ADDS     r6,r6,#1              ;3443
000060  4286              CMP      r6,r0                 ;3443
000062  d3eb              BCC      |L13.60|
000064  e022              B        |L13.172|
                  |L13.102|
;;;3448   					if (!i) {
000066  b959              CBNZ     r1,|L13.128|
                  |L13.104|
;;;3449   						res = move_window(fs, sect++);
000068  4631              MOV      r1,r6
00006a  1c76              ADDS     r6,r6,#1
00006c  4620              MOV      r0,r4
00006e  f7fffffe          BL       move_window
000072  ea5f0800          MOVS     r8,r0
;;;3450   						if (res != FR_OK) break;
000076  d119              BNE      |L13.172|
;;;3451   						p = fs->win;
000078  f1040030          ADD      r0,r4,#0x30
;;;3452   						i = SS(fs);
00007c  f44f7100          MOV      r1,#0x200
                  |L13.128|
;;;3453   					}
;;;3454   					if (fat == FS_FAT16) {
000080  f1b90f02          CMP      r9,#2
000084  d007              BEQ      |L13.150|
;;;3455   						if (LD_WORD(p) == 0) nfree++;
;;;3456   						p += 2; i -= 2;
;;;3457   					} else {
;;;3458   						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) nfree++;
000086  7802              LDRB     r2,[r0,#0]
000088  f8d03001          LDR      r3,[r0,#1]
00008c  ea422203          ORR      r2,r2,r3,LSL #8
000090  0112              LSLS     r2,r2,#4
000092  d006              BEQ      |L13.162|
000094  e006              B        |L13.164|
                  |L13.150|
000096  8802              LDRH     r2,[r0,#0]            ;3455
000098  b902              CBNZ     r2,|L13.156|
00009a  1c6d              ADDS     r5,r5,#1              ;3455
                  |L13.156|
00009c  1c80              ADDS     r0,r0,#2              ;3455
00009e  1e89              SUBS     r1,r1,#2              ;3455
0000a0  e002              B        |L13.168|
                  |L13.162|
0000a2  1c6d              ADDS     r5,r5,#1              ;3456
                  |L13.164|
0000a4  1d00              ADDS     r0,r0,#4              ;3456
0000a6  1f09              SUBS     r1,r1,#4              ;3456
                  |L13.168|
0000a8  1e7f              SUBS     r7,r7,#1              ;3456
;;;3459   						p += 4; i -= 4;
;;;3460   					}
;;;3461   				} while (--clst);
0000aa  d1dc              BNE      |L13.102|
                  |L13.172|
;;;3462   			}
;;;3463   			fs->free_clust = nfree;	/* free_clust is valid */
;;;3464   			fs->fsi_flag |= 1;		/* FSInfo is to be updated */
0000ac  6125              STR      r5,[r4,#0x10]
0000ae  7960              LDRB     r0,[r4,#5]
0000b0  f0400001          ORR      r0,r0,#1
0000b4  7160              STRB     r0,[r4,#5]
;;;3465   			*nclst = nfree;			/* Return the free clusters */
0000b6  f8ca5000          STR      r5,[r10,#0]
                  |L13.186|
;;;3466   		}
;;;3467   	}
;;;3468   	LEAVE_FF(fs, res);
0000ba  4640              MOV      r0,r8
;;;3469   }
0000bc  e8bd8ffe          POP      {r1-r11,pc}
;;;3470   
                          ENDP


                          AREA ||i.f_gets||, CODE, READONLY, ALIGN=1

                  f_gets PROC
;;;4396   
;;;4397   TCHAR* f_gets (
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;4398   	TCHAR* buff,	/* Pointer to the string buffer to read */
;;;4399   	int len,		/* Size of string buffer (characters) */
;;;4400   	FIL* fp			/* Pointer to the file object */
;;;4401   )
;;;4402   {
;;;4403   	int n = 0;
000004  2500              MOVS     r5,#0
000006  4690              MOV      r8,r2                 ;4402
000008  4607              MOV      r7,r0                 ;4402
;;;4404   	TCHAR c, *p = buff;
00000a  4604              MOV      r4,r0
;;;4405   	BYTE s[2];
;;;4406   	UINT rc;
;;;4407   
;;;4408   
;;;4409   	while (n < len - 1) {	/* Read characters until buffer gets filled */
00000c  1e4e              SUBS     r6,r1,#1
00000e  e011              B        |L14.52|
                  |L14.16|
;;;4410   #if _USE_LFN && _LFN_UNICODE
;;;4411   #if _STRF_ENCODE == 3		/* Read a character in UTF-8 */
;;;4412   		f_read(fp, s, 1, &rc);
;;;4413   		if (rc != 1) break;
;;;4414   		c = s[0];
;;;4415   		if (c >= 0x80) {
;;;4416   			if (c < 0xC0) continue;	/* Skip stray trailer */
;;;4417   			if (c < 0xE0) {			/* Two-byte sequence */
;;;4418   				f_read(fp, s, 1, &rc);
;;;4419   				if (rc != 1) break;
;;;4420   				c = (c & 0x1F) << 6 | (s[0] & 0x3F);
;;;4421   				if (c < 0x80) c = '?';
;;;4422   			} else {
;;;4423   				if (c < 0xF0) {		/* Three-byte sequence */
;;;4424   					f_read(fp, s, 2, &rc);
;;;4425   					if (rc != 2) break;
;;;4426   					c = c << 12 | (s[0] & 0x3F) << 6 | (s[1] & 0x3F);
;;;4427   					if (c < 0x800) c = '?';
;;;4428   				} else {			/* Reject four-byte sequence */
;;;4429   					c = '?';
;;;4430   				}
;;;4431   			}
;;;4432   		}
;;;4433   #elif _STRF_ENCODE == 2		/* Read a character in UTF-16BE */
;;;4434   		f_read(fp, s, 2, &rc);
;;;4435   		if (rc != 2) break;
;;;4436   		c = s[1] + (s[0] << 8);
;;;4437   #elif _STRF_ENCODE == 1		/* Read a character in UTF-16LE */
;;;4438   		f_read(fp, s, 2, &rc);
;;;4439   		if (rc != 2) break;
;;;4440   		c = s[0] + (s[1] << 8);
;;;4441   #else						/* Read a character in ANSI/OEM */
;;;4442   		f_read(fp, s, 1, &rc);
;;;4443   		if (rc != 1) break;
;;;4444   		c = s[0];
;;;4445   		if (IsDBCS1(c)) {
;;;4446   			f_read(fp, s, 1, &rc);
;;;4447   			if (rc != 1) break;
;;;4448   			c = (c << 8) + s[0];
;;;4449   		}
;;;4450   		c = ff_convert(c, 1);	/* OEM -> Unicode */
;;;4451   		if (!c) c = '?';
;;;4452   #endif
;;;4453   #else						/* Read a character without conversion */
;;;4454   		f_read(fp, s, 1, &rc);
000010  ab01              ADD      r3,sp,#4
000012  2201              MOVS     r2,#1
000014  4669              MOV      r1,sp
000016  4640              MOV      r0,r8
000018  f7fffffe          BL       f_read
;;;4455   		if (rc != 1) break;
00001c  9801              LDR      r0,[sp,#4]
00001e  2801              CMP      r0,#1
000020  d10a              BNE      |L14.56|
;;;4456   		c = s[0];
000022  f89d0000          LDRB     r0,[sp,#0]
;;;4457   #endif
;;;4458   		if (_USE_STRFUNC == 2 && c == '\r') continue;	/* Strip '\r' */
000026  280d              CMP      r0,#0xd
000028  d004              BEQ      |L14.52|
;;;4459   		*p++ = c;
00002a  1c6d              ADDS     r5,r5,#1
00002c  f8040b01          STRB     r0,[r4],#1
;;;4460   		n++;
;;;4461   		if (c == '\n') break;		/* Break on EOL */
000030  280a              CMP      r0,#0xa
000032  d001              BEQ      |L14.56|
                  |L14.52|
000034  42b5              CMP      r5,r6                 ;4409
000036  dbeb              BLT      |L14.16|
                  |L14.56|
;;;4462   	}
;;;4463   	*p = 0;
000038  2000              MOVS     r0,#0
00003a  7020              STRB     r0,[r4,#0]
;;;4464   	return n ? buff : 0;			/* When no data read (eof or error), return with error. */
00003c  b115              CBZ      r5,|L14.68|
00003e  4638              MOV      r0,r7
                  |L14.64|
;;;4465   }
000040  e8bd81fc          POP      {r2-r8,pc}
                  |L14.68|
000044  2000              MOVS     r0,#0                 ;4464
000046  e7fb              B        |L14.64|
;;;4466   
                          ENDP


                          AREA ||i.f_lseek||, CODE, READONLY, ALIGN=1

                  f_lseek PROC
;;;3036   
;;;3037   FRESULT f_lseek (
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;3038   	FIL* fp,		/* Pointer to the file object */
;;;3039   	DWORD ofs		/* File pointer from top of file */
;;;3040   )
;;;3041   {
000004  460d              MOV      r5,r1
000006  4604              MOV      r4,r0
;;;3042   	FRESULT res;
;;;3043   	DWORD clst, bcs, nsect, ifptr;
;;;3044   #if _USE_FASTSEEK
;;;3045   	DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
;;;3046   #endif
;;;3047   
;;;3048   
;;;3049   	res = validate(fp);					/* Check validity of the object */
000008  f7fffffe          BL       validate
00000c  ea5f0800          MOVS     r8,r0
;;;3050   	if (res != FR_OK) LEAVE_FF(fp->fs, res);
000010  d16f              BNE      |L15.242|
;;;3051   	if (fp->err)						/* Check error */
000012  79e0              LDRB     r0,[r4,#7]
000014  2800              CMP      r0,#0
000016  d16c              BNE      |L15.242|
;;;3052   		LEAVE_FF(fp->fs, (FRESULT)fp->err);
;;;3053   
;;;3054   #if _USE_FASTSEEK
;;;3055   	if (fp->cltbl) {	/* Fast seek */
;;;3056   		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
;;;3057   			tbl = fp->cltbl;
;;;3058   			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
;;;3059   			cl = fp->sclust;			/* Top of the chain */
;;;3060   			if (cl) {
;;;3061   				do {
;;;3062   					/* Get a fragment */
;;;3063   					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
;;;3064   					do {
;;;3065   						pcl = cl; ncl++;
;;;3066   						cl = get_fat(fp->fs, cl);
;;;3067   						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
;;;3068   						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
;;;3069   					} while (cl == pcl + 1);
;;;3070   					if (ulen <= tlen) {		/* Store the length and top of the fragment */
;;;3071   						*tbl++ = ncl; *tbl++ = tcl;
;;;3072   					}
;;;3073   				} while (cl < fp->fs->n_fatent);	/* Repeat until end of chain */
;;;3074   			}
;;;3075   			*fp->cltbl = ulen;	/* Number of items used */
;;;3076   			if (ulen <= tlen)
;;;3077   				*tbl = 0;		/* Terminate table */
;;;3078   			else
;;;3079   				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
;;;3080   
;;;3081   		} else {						/* Fast seek */
;;;3082   			if (ofs > fp->fsize)		/* Clip offset at the file size */
;;;3083   				ofs = fp->fsize;
;;;3084   			fp->fptr = ofs;				/* Set file pointer */
;;;3085   			if (ofs) {
;;;3086   				fp->clust = clmt_clust(fp, ofs - 1);
;;;3087   				dsc = clust2sect(fp->fs, fp->clust);
;;;3088   				if (!dsc) ABORT(fp->fs, FR_INT_ERR);
;;;3089   				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
;;;3090   				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) {	/* Refill sector cache if needed */
;;;3091   #if !_FS_TINY
;;;3092   #if !_FS_READONLY
;;;3093   					if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
;;;3094   						if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
;;;3095   							ABORT(fp->fs, FR_DISK_ERR);
;;;3096   						fp->flag &= ~FA__DIRTY;
;;;3097   					}
;;;3098   #endif
;;;3099   					if (disk_read(fp->fs->drv, fp->buf, dsc, 1) != RES_OK)	/* Load current sector */
;;;3100   						ABORT(fp->fs, FR_DISK_ERR);
;;;3101   #endif
;;;3102   					fp->dsect = dsc;
;;;3103   				}
;;;3104   			}
;;;3105   		}
;;;3106   	} else
;;;3107   #endif
;;;3108   
;;;3109   	/* Normal Seek */
;;;3110   	{
;;;3111   		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
000018  68e0              LDR      r0,[r4,#0xc]
00001a  42a8              CMP      r0,r5
00001c  d203              BCS      |L15.38|
;;;3112   #if !_FS_READONLY
;;;3113   			 && !(fp->flag & FA_WRITE)
00001e  79a1              LDRB     r1,[r4,#6]
000020  0789              LSLS     r1,r1,#30
000022  d400              BMI      |L15.38|
;;;3114   #endif
;;;3115   			) ofs = fp->fsize;
000024  4605              MOV      r5,r0
                  |L15.38|
;;;3116   
;;;3117   		ifptr = fp->fptr;
;;;3118   		fp->fptr = nsect = 0;
000026  2700              MOVS     r7,#0
000028  68a0              LDR      r0,[r4,#8]
00002a  f04f0901          MOV      r9,#1                 ;3043
;;;3119   		if (ofs) {
00002e  60a7              STR      r7,[r4,#8]
000030  b30d              CBZ      r5,|L15.118|
;;;3120   			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
000032  6822              LDR      r2,[r4,#0]
;;;3121   			if (ifptr > 0 &&
;;;3122   				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
;;;3123   				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
;;;3124   				ofs -= fp->fptr;
;;;3125   				clst = fp->clust;
;;;3126   			} else {									/* When seek to back cluster, */
;;;3127   				clst = fp->sclust;						/* start from the first cluster */
;;;3128   #if !_FS_READONLY
;;;3129   				if (clst == 0) {						/* If no cluster chain, create a new chain */
;;;3130   					clst = create_chain(fp->fs, 0);
;;;3131   					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
000034  f04f0a02          MOV      r10,#2
000038  7891              LDRB     r1,[r2,#2]            ;3120
00003a  024e              LSLS     r6,r1,#9              ;3120
00003c  b168              CBZ      r0,|L15.90|
00003e  1e69              SUBS     r1,r5,#1              ;3122
000040  1e40              SUBS     r0,r0,#1              ;3122
000042  fbb1f1f6          UDIV     r1,r1,r6              ;3122
000046  fbb0f3f6          UDIV     r3,r0,r6              ;3122
00004a  4299              CMP      r1,r3                 ;3122
00004c  d305              BCC      |L15.90|
00004e  1e71              SUBS     r1,r6,#1              ;3123
000050  4388              BICS     r0,r0,r1              ;3123
000052  60a0              STR      r0,[r4,#8]            ;3125
000054  1a2d              SUBS     r5,r5,r0              ;3124
000056  6961              LDR      r1,[r4,#0x14]         ;3125
000058  e00c              B        |L15.116|
                  |L15.90|
00005a  6921              LDR      r1,[r4,#0x10]         ;3129
00005c  b949              CBNZ     r1,|L15.114|
00005e  2100              MOVS     r1,#0                 ;3130
000060  4610              MOV      r0,r2                 ;3130
000062  f7fffffe          BL       create_chain
000066  4601              MOV      r1,r0                 ;3130
000068  2801              CMP      r0,#1
00006a  d03f              BEQ      |L15.236|
;;;3132   					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
00006c  1c48              ADDS     r0,r1,#1
00006e  d04e              BEQ      |L15.270|
;;;3133   					fp->sclust = clst;
000070  6121              STR      r1,[r4,#0x10]
                  |L15.114|
;;;3134   				}
;;;3135   #endif
;;;3136   				fp->clust = clst;
000072  6161              STR      r1,[r4,#0x14]
                  |L15.116|
;;;3137   			}
;;;3138   			if (clst != 0) {
000074  b9d1              CBNZ     r1,|L15.172|
                  |L15.118|
000076  e026              B        |L15.198|
                  |L15.120|
;;;3139   				while (ofs > bcs) {						/* Cluster following loop */
;;;3140   #if !_FS_READONLY
;;;3141   					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
000078  79a0              LDRB     r0,[r4,#6]
00007a  0780              LSLS     r0,r0,#30
00007c  6820              LDR      r0,[r4,#0]
00007e  d505              BPL      |L15.140|
;;;3142   						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
000080  f7fffffe          BL       create_chain
000084  0001              MOVS     r1,r0
;;;3143   						if (clst == 0) {				/* When disk gets full, clip file size */
000086  d104              BNE      |L15.146|
;;;3144   							ofs = bcs; break;
000088  4635              MOV      r5,r6
00008a  e011              B        |L15.176|
                  |L15.140|
;;;3145   						}
;;;3146   					} else
;;;3147   #endif
;;;3148   						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
00008c  f7fffffe          BL       get_fat
000090  4601              MOV      r1,r0
                  |L15.146|
;;;3149   					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
000092  1c48              ADDS     r0,r1,#1
000094  d03b              BEQ      |L15.270|
;;;3150   					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
000096  2901              CMP      r1,#1
000098  d928              BLS      |L15.236|
00009a  6820              LDR      r0,[r4,#0]
00009c  6940              LDR      r0,[r0,#0x14]
00009e  4288              CMP      r0,r1
0000a0  d924              BLS      |L15.236|
;;;3151   					fp->clust = clst;
;;;3152   					fp->fptr += bcs;
0000a2  6161              STR      r1,[r4,#0x14]
0000a4  68a0              LDR      r0,[r4,#8]
;;;3153   					ofs -= bcs;
0000a6  1bad              SUBS     r5,r5,r6
0000a8  4430              ADD      r0,r0,r6              ;3152
0000aa  60a0              STR      r0,[r4,#8]
                  |L15.172|
0000ac  42b5              CMP      r5,r6                 ;3139
0000ae  d8e3              BHI      |L15.120|
                  |L15.176|
;;;3154   				}
;;;3155   				fp->fptr += ofs;
0000b0  68a0              LDR      r0,[r4,#8]
0000b2  4428              ADD      r0,r0,r5
;;;3156   				if (ofs % SS(fp->fs)) {
0000b4  60a0              STR      r0,[r4,#8]
0000b6  05e8              LSLS     r0,r5,#23
0000b8  d005              BEQ      |L15.198|
;;;3157   					nsect = clust2sect(fp->fs, clst);	/* Current sector */
0000ba  6820              LDR      r0,[r4,#0]
0000bc  f7fffffe          BL       clust2sect
;;;3158   					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
0000c0  b1a0              CBZ      r0,|L15.236|
;;;3159   					nsect += ofs / SS(fp->fs);
0000c2  eb002755          ADD      r7,r0,r5,LSR #9
                  |L15.198|
;;;3160   				}
;;;3161   			}
;;;3162   		}
;;;3163   		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
0000c6  8920              LDRH     r0,[r4,#8]
0000c8  05c0              LSLS     r0,r0,#23
0000ca  d025              BEQ      |L15.280|
0000cc  69a2              LDR      r2,[r4,#0x18]
0000ce  42ba              CMP      r2,r7
0000d0  d022              BEQ      |L15.280|
;;;3164   #if !_FS_TINY
;;;3165   #if !_FS_READONLY
;;;3166   			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
0000d2  79a0              LDRB     r0,[r4,#6]
;;;3167   				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
0000d4  f1040524          ADD      r5,r4,#0x24
0000d8  0640              LSLS     r0,r0,#25             ;3166
0000da  d510              BPL      |L15.254|
0000dc  6820              LDR      r0,[r4,#0]
0000de  2301              MOVS     r3,#1
0000e0  4629              MOV      r1,r5
0000e2  7840              LDRB     r0,[r0,#1]
0000e4  f7fffffe          BL       disk_write
0000e8  b988              CBNZ     r0,|L15.270|
0000ea  e004              B        |L15.246|
                  |L15.236|
0000ec  f884a007          STRB     r10,[r4,#7]           ;3158
0000f0  2002              MOVS     r0,#2                 ;3158
                  |L15.242|
;;;3168   					ABORT(fp->fs, FR_DISK_ERR);
;;;3169   				fp->flag &= ~FA__DIRTY;
;;;3170   			}
;;;3171   #endif
;;;3172   			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
;;;3173   				ABORT(fp->fs, FR_DISK_ERR);
;;;3174   #endif
;;;3175   			fp->dsect = nsect;
;;;3176   		}
;;;3177   #if !_FS_READONLY
;;;3178   		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
;;;3179   			fp->fsize = fp->fptr;
;;;3180   			fp->flag |= FA__WRITTEN;
;;;3181   		}
;;;3182   #endif
;;;3183   	}
;;;3184   
;;;3185   	LEAVE_FF(fp->fs, res);
;;;3186   }
0000f2  e8bd87f0          POP      {r4-r10,pc}
                  |L15.246|
0000f6  79a0              LDRB     r0,[r4,#6]            ;3169
0000f8  f0200040          BIC      r0,r0,#0x40           ;3169
0000fc  71a0              STRB     r0,[r4,#6]            ;3169
                  |L15.254|
0000fe  6820              LDR      r0,[r4,#0]            ;3172
000100  2301              MOVS     r3,#1                 ;3172
000102  463a              MOV      r2,r7                 ;3172
000104  7840              LDRB     r0,[r0,#1]            ;3172
000106  4629              MOV      r1,r5                 ;3172
000108  f7fffffe          BL       disk_read
00010c  b118              CBZ      r0,|L15.278|
                  |L15.270|
00010e  f8849007          STRB     r9,[r4,#7]            ;3173
000112  2001              MOVS     r0,#1                 ;3173
000114  e7ed              B        |L15.242|
                  |L15.278|
000116  61a7              STR      r7,[r4,#0x18]         ;3175
                  |L15.280|
000118  e9d40102          LDRD     r0,r1,[r4,#8]         ;3175
00011c  4288              CMP      r0,r1                 ;3178
00011e  d904              BLS      |L15.298|
000120  60e0              STR      r0,[r4,#0xc]          ;3180
000122  79a0              LDRB     r0,[r4,#6]            ;3180
000124  f0400020          ORR      r0,r0,#0x20           ;3180
000128  71a0              STRB     r0,[r4,#6]            ;3180
                  |L15.298|
00012a  4640              MOV      r0,r8                 ;3185
00012c  e7e1              B        |L15.242|
;;;3187   
                          ENDP


                          AREA ||i.f_mkdir||, CODE, READONLY, ALIGN=1

                  f_mkdir PROC
;;;3602   
;;;3603   FRESULT f_mkdir (
000000  e92d4ff1          PUSH     {r0,r4-r11,lr}
;;;3604   	const TCHAR* path		/* Pointer to the directory path */
;;;3605   )
;;;3606   {
000004  b08c              SUB      sp,sp,#0x30
;;;3607   	FRESULT res;
;;;3608   	DIR dj;
;;;3609   	BYTE *dir, n;
;;;3610   	DWORD dsc, dcl, pcl, tm = GET_FATTIME();
000006  f7fffffe          BL       get_fattime
00000a  4607              MOV      r7,r0
;;;3611   	DEFINE_NAMEBUF;
;;;3612   
;;;3613   
;;;3614   	/* Get logical drive number */
;;;3615   	res = find_volume(&dj.fs, &path, 1);
00000c  2201              MOVS     r2,#1
00000e  a90c              ADD      r1,sp,#0x30
000010  4668              MOV      r0,sp
000012  f7fffffe          BL       find_volume
000016  0004              MOVS     r4,r0
;;;3616   	if (res == FR_OK) {
000018  d109              BNE      |L16.46|
;;;3617   		INIT_BUF(dj);
00001a  a808              ADD      r0,sp,#0x20
;;;3618   		res = follow_path(&dj, path);			/* Follow the file path */
00001c  9006              STR      r0,[sp,#0x18]
00001e  4668              MOV      r0,sp
000020  990c              LDR      r1,[sp,#0x30]
000022  f7fffffe          BL       follow_path
000026  0004              MOVS     r4,r0
;;;3619   		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
000028  d002              BEQ      |L16.48|
;;;3620   		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NSFLAG] & NS_DOT))
;;;3621   			res = FR_INVALID_NAME;
;;;3622   		if (res == FR_NO_FILE) {				/* Can create a new directory */
00002a  2c04              CMP      r4,#4
00002c  d002              BEQ      |L16.52|
                  |L16.46|
00002e  e08f              B        |L16.336|
                  |L16.48|
000030  2408              MOVS     r4,#8                 ;3619
000032  e08d              B        |L16.336|
                  |L16.52|
;;;3623   			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
000034  2100              MOVS     r1,#0
000036  9800              LDR      r0,[sp,#0]
000038  f7fffffe          BL       create_chain
00003c  0006              MOVS     r6,r0
;;;3624   			res = FR_OK;
;;;3625   			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
00003e  d009              BEQ      |L16.84|
;;;3626   			if (dcl == 1) res = FR_INT_ERR;
000040  2e01              CMP      r6,#1
000042  d009              BEQ      |L16.88|
;;;3627   			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
000044  1c70              ADDS     r0,r6,#1
000046  d009              BEQ      |L16.92|
;;;3628   			if (res == FR_OK)					/* Flush FAT */
;;;3629   				res = sync_window(dj.fs);
000048  9800              LDR      r0,[sp,#0]
00004a  f7fffffe          BL       sync_window
00004e  0004              MOVS     r4,r0
000050  d006              BEQ      |L16.96|
000052  e063              B        |L16.284|
                  |L16.84|
000054  2407              MOVS     r4,#7                 ;3625
000056  e061              B        |L16.284|
                  |L16.88|
000058  2402              MOVS     r4,#2                 ;3626
00005a  e05f              B        |L16.284|
                  |L16.92|
00005c  2401              MOVS     r4,#1                 ;3627
00005e  e05d              B        |L16.284|
                  |L16.96|
;;;3630   			if (res == FR_OK) {					/* Initialize the new directory table */
;;;3631   				dsc = clust2sect(dj.fs, dcl);
000060  4631              MOV      r1,r6
000062  9800              LDR      r0,[sp,#0]
000064  f7fffffe          BL       clust2sect
;;;3632   				dir = dj.fs->win;
;;;3633   				mem_set(dir, 0, SS(dj.fs));
000068  9d00              LDR      r5,[sp,#0]
00006a  4680              MOV      r8,r0                 ;3631
00006c  3530              ADDS     r5,r5,#0x30
00006e  f44f7200          MOV      r2,#0x200
000072  2100              MOVS     r1,#0
000074  4628              MOV      r0,r5
000076  f7fffffe          BL       mem_set
;;;3634   				mem_set(dir + DIR_Name, ' ', 11);	/* Create "." entry */
00007a  220b              MOVS     r2,#0xb
00007c  2120              MOVS     r1,#0x20
00007e  4628              MOV      r0,r5
000080  f7fffffe          BL       mem_set
;;;3635   				dir[DIR_Name] = '.';
000084  242e              MOVS     r4,#0x2e
000086  702c              STRB     r4,[r5,#0]
;;;3636   				dir[DIR_Attr] = AM_DIR;
000088  2010              MOVS     r0,#0x10
00008a  72e8              STRB     r0,[r5,#0xb]
;;;3637   				ST_DWORD(dir + DIR_WrtTime, tm);
00008c  b2f8              UXTB     r0,r7
00008e  9007              STR      r0,[sp,#0x1c]
000090  75a8              STRB     r0,[r5,#0x16]
000092  f3c72b07          UBFX     r11,r7,#8,#8
000096  f885b017          STRB     r11,[r5,#0x17]
00009a  f3c74a07          UBFX     r10,r7,#16,#8
00009e  f885a018          STRB     r10,[r5,#0x18]
0000a2  ea4f6917          LSR      r9,r7,#24
0000a6  f8859019          STRB     r9,[r5,#0x19]
;;;3638   				st_clust(dir, dcl);
0000aa  4631              MOV      r1,r6
0000ac  4628              MOV      r0,r5
0000ae  f7fffffe          BL       st_clust
;;;3639   				mem_cpy(dir + SZ_DIRE, dir, SZ_DIRE); 	/* Create ".." entry */
0000b2  f1050020          ADD      r0,r5,#0x20
0000b6  2220              MOVS     r2,#0x20
0000b8  4629              MOV      r1,r5
0000ba  4607              MOV      r7,r0
0000bc  f7fffffe          BL       mem_cpy
;;;3640   				dir[SZ_DIRE + 1] = '.'; pcl = dj.sclust;
0000c0  f8854021          STRB     r4,[r5,#0x21]
;;;3641   				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
0000c4  9800              LDR      r0,[sp,#0]
0000c6  9902              LDR      r1,[sp,#8]
0000c8  7800              LDRB     r0,[r0,#0]
0000ca  2803              CMP      r0,#3
0000cc  d104              BNE      |L16.216|
0000ce  9800              LDR      r0,[sp,#0]
0000d0  6a40              LDR      r0,[r0,#0x24]
0000d2  4288              CMP      r0,r1
0000d4  d100              BNE      |L16.216|
;;;3642   					pcl = 0;
0000d6  2100              MOVS     r1,#0
                  |L16.216|
0000d8  4638              MOV      r0,r7
;;;3643   				st_clust(dir + SZ_DIRE, pcl);
0000da  f7fffffe          BL       st_clust
;;;3644   				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
0000de  9800              LDR      r0,[sp,#0]
0000e0  7887              LDRB     r7,[r0,#2]
0000e2  e014              B        |L16.270|
                  |L16.228|
;;;3645   					dj.fs->winsect = dsc++;
0000e4  9900              LDR      r1,[sp,#0]
;;;3646   					dj.fs->wflag = 1;
0000e6  2001              MOVS     r0,#1
0000e8  f8c1802c          STR      r8,[r1,#0x2c]         ;3645
0000ec  9900              LDR      r1,[sp,#0]
0000ee  f1080801          ADD      r8,r8,#1              ;3645
0000f2  7108              STRB     r0,[r1,#4]
;;;3647   					res = sync_window(dj.fs);
0000f4  9800              LDR      r0,[sp,#0]
0000f6  f7fffffe          BL       sync_window
0000fa  0004              MOVS     r4,r0
;;;3648   					if (res != FR_OK) break;
0000fc  d10e              BNE      |L16.284|
;;;3649   					mem_set(dir, 0, SS(dj.fs));
0000fe  f44f7200          MOV      r2,#0x200
000102  2100              MOVS     r1,#0
000104  4628              MOV      r0,r5
000106  f7fffffe          BL       mem_set
00010a  1e7f              SUBS     r7,r7,#1
00010c  b2ff              UXTB     r7,r7                 ;3644
                  |L16.270|
00010e  2f00              CMP      r7,#0                 ;3644
000110  d1e8              BNE      |L16.228|
;;;3650   				}
;;;3651   			}
;;;3652   			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
000112  4668              MOV      r0,sp
000114  f7fffffe          BL       dir_register
000118  0004              MOVS     r4,r0
00011a  d004              BEQ      |L16.294|
                  |L16.284|
;;;3653   			if (res != FR_OK) {
;;;3654   				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
00011c  4631              MOV      r1,r6
00011e  9800              LDR      r0,[sp,#0]
000120  f7fffffe          BL       remove_chain
000124  e014              B        |L16.336|
                  |L16.294|
;;;3655   			} else {
;;;3656   				dir = dj.dir;
;;;3657   				dir[DIR_Attr] = AM_DIR;				/* Attribute */
000126  9805              LDR      r0,[sp,#0x14]
000128  2110              MOVS     r1,#0x10
00012a  72c1              STRB     r1,[r0,#0xb]
;;;3658   				ST_DWORD(dir + DIR_WrtTime, tm);	/* Created time */
00012c  9907              LDR      r1,[sp,#0x1c]
00012e  7581              STRB     r1,[r0,#0x16]
000130  f880b017          STRB     r11,[r0,#0x17]
000134  f880a018          STRB     r10,[r0,#0x18]
000138  f8809019          STRB     r9,[r0,#0x19]
;;;3659   				st_clust(dir, dcl);					/* Table start cluster */
00013c  4631              MOV      r1,r6
00013e  f7fffffe          BL       st_clust
;;;3660   				dj.fs->wflag = 1;
000142  9900              LDR      r1,[sp,#0]
000144  2001              MOVS     r0,#1
000146  7108              STRB     r0,[r1,#4]
;;;3661   				res = sync_fs(dj.fs);
000148  9800              LDR      r0,[sp,#0]
00014a  f7fffffe          BL       sync_fs
00014e  4604              MOV      r4,r0
                  |L16.336|
;;;3662   			}
;;;3663   		}
;;;3664   		FREE_BUF();
;;;3665   	}
;;;3666   
;;;3667   	LEAVE_FF(dj.fs, res);
;;;3668   }
000150  b00d              ADD      sp,sp,#0x34
000152  4620              MOV      r0,r4                 ;3667
000154  e8bd8ff0          POP      {r4-r11,pc}
;;;3669   
                          ENDP


                          AREA ||i.f_mkfs||, CODE, READONLY, ALIGN=2

                  f_mkfs PROC
;;;4070   
;;;4071   FRESULT f_mkfs (
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;4072   	const TCHAR* path,	/* Logical drive number */
;;;4073   	BYTE sfd,			/* Partitioning rule 0:FDISK, 1:SFD */
;;;4074   	UINT au				/* Size of allocation unit in unit of byte or sector */
;;;4075   )
;;;4076   {
000004  b090              SUB      sp,sp,#0x40
000006  4615              MOV      r5,r2
;;;4077   	static const WORD vst[] = { 1024,   512,  256,  128,   64,    32,   16,    8,    4,    2,   0};
;;;4078   	static const WORD cst[] = {32768, 16384, 8192, 4096, 2048, 16384, 8192, 4096, 2048, 1024, 512};
;;;4079   	int vol;
;;;4080   	BYTE fmt, md, sys, *tbl, pdrv, part;
;;;4081   	DWORD n_clst, vs, n, wsect;
;;;4082   	UINT i;
;;;4083   	DWORD b_vol, b_fat, b_dir, b_data;	/* LBA */
;;;4084   	DWORD n_vol, n_rsv, n_fat, n_dir;	/* Size */
;;;4085   	FATFS *fs;
;;;4086   	DSTATUS stat;
;;;4087   #if _USE_TRIM
;;;4088   	DWORD eb[2];
;;;4089   #endif
;;;4090   
;;;4091   
;;;4092   	/* Check mounted drive and clear work area */
;;;4093   	if (sfd > 1) return FR_INVALID_PARAMETER;
000008  9811              LDR      r0,[sp,#0x44]
00000a  2801              CMP      r0,#1
00000c  d903              BLS      |L17.22|
00000e  2013              MOVS     r0,#0x13
                  |L17.16|
;;;4094   	vol = get_ldnumber(&path);
;;;4095   	if (vol < 0) return FR_INVALID_DRIVE;
;;;4096   	fs = FatFs[vol];
;;;4097   	if (!fs) return FR_NOT_ENABLED;
;;;4098   	fs->fs_type = 0;
;;;4099   	pdrv = LD2PD(vol);	/* Physical drive */
;;;4100   	part = LD2PT(vol);	/* Partition (0:auto detect, 1-4:get from partition table)*/
;;;4101   
;;;4102   	/* Get disk statics */
;;;4103   	stat = disk_initialize(pdrv);
;;;4104   	if (stat & STA_NOINIT) return FR_NOT_READY;
;;;4105   	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
;;;4106   #if _MAX_SS != _MIN_SS		/* Get disk sector size */
;;;4107   	if (disk_ioctl(pdrv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK || SS(fs) > _MAX_SS || SS(fs) < _MIN_SS)
;;;4108   		return FR_DISK_ERR;
;;;4109   #endif
;;;4110   	if (_MULTI_PARTITION && part) {
;;;4111   		/* Get partition information from partition table in the MBR */
;;;4112   		if (disk_read(pdrv, fs->win, 0, 1) != RES_OK) return FR_DISK_ERR;
;;;4113   		if (LD_WORD(fs->win + BS_55AA) != 0xAA55) return FR_MKFS_ABORTED;
;;;4114   		tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
;;;4115   		if (!tbl[4]) return FR_MKFS_ABORTED;	/* No partition? */
;;;4116   		b_vol = LD_DWORD(tbl + 8);	/* Volume start sector */
;;;4117   		n_vol = LD_DWORD(tbl + 12);	/* Volume size */
;;;4118   	} else {
;;;4119   		/* Create a partition in this function */
;;;4120   		if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &n_vol) != RES_OK || n_vol < 128)
;;;4121   			return FR_DISK_ERR;
;;;4122   		b_vol = (sfd) ? 0 : 63;		/* Volume start sector */
;;;4123   		n_vol -= b_vol;				/* Volume size */
;;;4124   	}
;;;4125   
;;;4126   	if (au & (au - 1)) au = 0;
;;;4127   	if (!au) {						/* AU auto selection */
;;;4128   		vs = n_vol / (2000 / (SS(fs) / 512));
;;;4129   		for (i = 0; vs < vst[i]; i++) ;
;;;4130   		au = cst[i];
;;;4131   	}
;;;4132   	if (au >= _MIN_SS) au /= SS(fs);	/* Number of sectors per cluster */
;;;4133   	if (!au) au = 1;
;;;4134   	if (au > 128) au = 128;
;;;4135   
;;;4136   	/* Pre-compute number of clusters and FAT sub-type */
;;;4137   	n_clst = n_vol / au;
;;;4138   	fmt = FS_FAT12;
;;;4139   	if (n_clst >= MIN_FAT16) fmt = FS_FAT16;
;;;4140   	if (n_clst >= MIN_FAT32) fmt = FS_FAT32;
;;;4141   
;;;4142   	/* Determine offset and size of FAT structure */
;;;4143   	if (fmt == FS_FAT32) {
;;;4144   		n_fat = ((n_clst * 4) + 8 + SS(fs) - 1) / SS(fs);
;;;4145   		n_rsv = 32;
;;;4146   		n_dir = 0;
;;;4147   	} else {
;;;4148   		n_fat = (fmt == FS_FAT12) ? (n_clst * 3 + 1) / 2 + 3 : (n_clst * 2) + 4;
;;;4149   		n_fat = (n_fat + SS(fs) - 1) / SS(fs);
;;;4150   		n_rsv = 1;
;;;4151   		n_dir = (DWORD)N_ROOTDIR * SZ_DIRE / SS(fs);
;;;4152   	}
;;;4153   	b_fat = b_vol + n_rsv;				/* FAT area start sector */
;;;4154   	b_dir = b_fat + n_fat * N_FATS;		/* Directory area start sector */
;;;4155   	b_data = b_dir + n_dir;				/* Data area start sector */
;;;4156   	if (n_vol < b_data + au - b_vol) return FR_MKFS_ABORTED;	/* Too small volume */
;;;4157   
;;;4158   	/* Align data start sector to erase block boundary (for flash memory media) */
;;;4159   	if (disk_ioctl(pdrv, GET_BLOCK_SIZE, &n) != RES_OK || !n || n > 32768) n = 1;
;;;4160   
;;;4161   //       v1000_debug("n :%d \r\n",n);
;;;4162    //      v1000_debug("b_data :%d \r\n",b_data);
;;;4163   
;;;4164   	n = (b_data + n - 1) & ~(n - 1);	/* Next nearest erase block from current data start */
;;;4165   	n = (n - b_data) / N_FATS;
;;;4166   	if (fmt == FS_FAT32) {		/* FAT32: Move FAT offset */
;;;4167   		n_rsv += n;
;;;4168   		b_fat += n;
;;;4169   	} else {					/* FAT12/16: Expand FAT size */
;;;4170   		n_fat += n;
;;;4171   	}
;;;4172   
;;;4173   	/* Determine number of clusters and final check of validity of the FAT sub-type */
;;;4174   	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
;;;4175   	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
;;;4176   		|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
;;;4177   		return FR_MKFS_ABORTED;
;;;4178   
;;;4179   	/* Determine system ID in the partition table */
;;;4180   	if (fmt == FS_FAT32) {
;;;4181   		sys = 0x0C;		/* FAT32X */
;;;4182   	} else {
;;;4183   		if (fmt == FS_FAT12 && n_vol < 0x10000) {
;;;4184   			sys = 0x01;	/* FAT12(<65536) */
;;;4185   		} else {
;;;4186   			sys = (n_vol < 0x10000) ? 0x04 : 0x06;	/* FAT16(<65536) : FAT12/16(>=65536) */
;;;4187   		}
;;;4188   	}
;;;4189   
;;;4190   	if (_MULTI_PARTITION && part) {
;;;4191   		/* Update system ID in the partition table */
;;;4192   		tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
;;;4193   		tbl[4] = sys;
;;;4194   		if (disk_write(pdrv, fs->win, 0, 1) != RES_OK)	/* Write it to teh MBR */
;;;4195   			return FR_DISK_ERR;
;;;4196   		md = 0xF8;
;;;4197   	} else {
;;;4198   		if (sfd) {	/* No partition table (SFD) */
;;;4199   			md = 0xF0;
;;;4200   		} else {	/* Create partition table (FDISK) */
;;;4201   			mem_set(fs->win, 0, SS(fs));
;;;4202   			tbl = fs->win + MBR_Table;	/* Create partition table for single partition in the drive */
;;;4203   			tbl[1] = 1;						/* Partition start head */
;;;4204   			tbl[2] = 1;						/* Partition start sector */
;;;4205   			tbl[3] = 0;						/* Partition start cylinder */
;;;4206   			tbl[4] = sys;					/* System type */
;;;4207   			tbl[5] = 254;					/* Partition end head */
;;;4208   			n = (b_vol + n_vol) / 63 / 255;
;;;4209   			tbl[6] = (BYTE)(n >> 2 | 63);	/* Partition end sector */
;;;4210   			tbl[7] = (BYTE)n;				/* End cylinder */
;;;4211   			ST_DWORD(tbl + 8, 63);			/* Partition start in LBA */
;;;4212   			ST_DWORD(tbl + 12, n_vol);		/* Partition size in LBA */
;;;4213   			ST_WORD(fs->win + BS_55AA, 0xAA55);	/* MBR signature */
;;;4214   			if (disk_write(pdrv, fs->win, 0, 1) != RES_OK)	/* Write it to the MBR */
;;;4215   				return FR_DISK_ERR;
;;;4216   			md = 0xF8;
;;;4217   		}
;;;4218   	}
;;;4219   
;;;4220   	/* Create BPB in the VBR */
;;;4221   	tbl = fs->win;							/* Clear sector */
;;;4222   	mem_set(tbl, 0, SS(fs));
;;;4223   	mem_cpy(tbl, "\xEB\xFE\x90" "MSDOS5.0", 11);/* Boot jump code, OEM name */
;;;4224   	i = SS(fs);								/* Sector size */
;;;4225   	ST_WORD(tbl + BPB_BytsPerSec, i);
;;;4226   	tbl[BPB_SecPerClus] = (BYTE)au;			/* Sectors per cluster */
;;;4227   	ST_WORD(tbl + BPB_RsvdSecCnt, n_rsv);	/* Reserved sectors */
;;;4228   	tbl[BPB_NumFATs] = N_FATS;				/* Number of FATs */
;;;4229   	i = (fmt == FS_FAT32) ? 0 : N_ROOTDIR;	/* Number of root directory entries */
;;;4230   	ST_WORD(tbl + BPB_RootEntCnt, i);
;;;4231   	if (n_vol < 0x10000) {					/* Number of total sectors */
;;;4232   		ST_WORD(tbl + BPB_TotSec16, n_vol);
;;;4233   	} else {
;;;4234   		ST_DWORD(tbl + BPB_TotSec32, n_vol);
;;;4235   	}
;;;4236   	tbl[BPB_Media] = md;					/* Media descriptor */
;;;4237   	ST_WORD(tbl + BPB_SecPerTrk, 63);		/* Number of sectors per track */
;;;4238   	ST_WORD(tbl + BPB_NumHeads, 255);		/* Number of heads */
;;;4239   	ST_DWORD(tbl + BPB_HiddSec, b_vol);		/* Hidden sectors */
;;;4240   	n = GET_FATTIME();						/* Use current time as VSN */
;;;4241   	if (fmt == FS_FAT32) {
;;;4242   		ST_DWORD(tbl + BS_VolID32, n);		/* VSN */
;;;4243   		ST_DWORD(tbl + BPB_FATSz32, n_fat);	/* Number of sectors per FAT */
;;;4244   		ST_DWORD(tbl + BPB_RootClus, 2);	/* Root directory start cluster (2) */
;;;4245   		ST_WORD(tbl + BPB_FSInfo, 1);		/* FSINFO record offset (VBR + 1) */
;;;4246   		ST_WORD(tbl + BPB_BkBootSec, 6);	/* Backup boot record offset (VBR + 6) */
;;;4247   		tbl[BS_DrvNum32] = 0x80;			/* Drive number */
;;;4248   		tbl[BS_BootSig32] = 0x29;			/* Extended boot signature */
;;;4249   		mem_cpy(tbl + BS_VolLab32, "NO NAME    " "FAT32   ", 19);	/* Volume label, FAT signature */
;;;4250   	} else {
;;;4251   		ST_DWORD(tbl + BS_VolID, n);		/* VSN */
;;;4252   		ST_WORD(tbl + BPB_FATSz16, n_fat);	/* Number of sectors per FAT */
;;;4253   		tbl[BS_DrvNum] = 0x80;				/* Drive number */
;;;4254   		tbl[BS_BootSig] = 0x29;				/* Extended boot signature */
;;;4255   		mem_cpy(tbl + BS_VolLab, "NO NAME    " "FAT     ", 19);	/* Volume label, FAT signature */
;;;4256   	}
;;;4257   	ST_WORD(tbl + BS_55AA, 0xAA55);			/* Signature (Offset is fixed here regardless of sector size) */
;;;4258   	if (disk_write(pdrv, tbl, b_vol, 1) != RES_OK)	/* Write it to the VBR sector */
;;;4259   		return FR_DISK_ERR;
;;;4260   	if (fmt == FS_FAT32)					/* Write it to the backup VBR if needed (VBR + 6) */
;;;4261   		disk_write(pdrv, tbl, b_vol + 6, 1);
;;;4262   
;;;4263   	/* Initialize FAT area */
;;;4264   	wsect = b_fat;
;;;4265   	for (i = 0; i < N_FATS; i++) {		/* Initialize each FAT copy */
;;;4266   		mem_set(tbl, 0, SS(fs));			/* 1st sector of the FAT  */
;;;4267   		n = md;								/* Media descriptor byte */
;;;4268   		if (fmt != FS_FAT32) {
;;;4269   			n |= (fmt == FS_FAT12) ? 0x00FFFF00 : 0xFFFFFF00;
;;;4270   			ST_DWORD(tbl + 0, n);			/* Reserve cluster #0-1 (FAT12/16) */
;;;4271   		} else {
;;;4272   			n |= 0xFFFFFF00;
;;;4273   			ST_DWORD(tbl + 0, n);			/* Reserve cluster #0-1 (FAT32) */
;;;4274   			ST_DWORD(tbl + 4, 0xFFFFFFFF);
;;;4275   			ST_DWORD(tbl + 8, 0x0FFFFFFF);	/* Reserve cluster #2 for root directory */
;;;4276   		}
;;;4277   		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
;;;4278   			return FR_DISK_ERR;
;;;4279   		mem_set(tbl, 0, SS(fs));			/* Fill following FAT entries with zero */
;;;4280   //               v1000_debug("n_fat :%d \r\n",n_fat);
;;;4281   		for (n = 1; n < n_fat; n++) {		/* This loop may take a time on FAT32 volume due to many single sector writes */
;;;4282   			if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
;;;4283   				return FR_DISK_ERR;
;;;4284   		}
;;;4285   	}
;;;4286   
;;;4287   	/* Initialize root directory */
;;;4288   	i = (fmt == FS_FAT32) ? au : (UINT)n_dir;
;;;4289   //         v1000_debug("i :%d \r\n",i);
;;;4290   
;;;4291   	do {
;;;4292   		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
;;;4293   			return FR_DISK_ERR;
;;;4294   	} while (--i);
;;;4295   
;;;4296   #if _USE_TRIM	/* Erase data area if needed */
;;;4297   	{
;;;4298   		eb[0] = wsect; eb[1] = wsect + (n_clst - ((fmt == FS_FAT32) ? 1 : 0)) * au - 1;
;;;4299   		disk_ioctl(pdrv, CTRL_TRIM, eb);
;;;4300   	}
;;;4301   #endif
;;;4302   
;;;4303   	/* Create FSINFO if needed */
;;;4304   	if (fmt == FS_FAT32) {
;;;4305   		ST_DWORD(tbl + FSI_LeadSig, 0x41615252);
;;;4306   		ST_DWORD(tbl + FSI_StrucSig, 0x61417272);
;;;4307   		ST_DWORD(tbl + FSI_Free_Count, n_clst - 1);	/* Number of free clusters */
;;;4308   		ST_DWORD(tbl + FSI_Nxt_Free, 2);			/* Last allocated cluster# */
;;;4309   		ST_WORD(tbl + BS_55AA, 0xAA55);
;;;4310   		disk_write(pdrv, tbl, b_vol + 1, 1);	/* Write original (VBR + 1) */
;;;4311   		disk_write(pdrv, tbl, b_vol + 7, 1);	/* Write backup (VBR + 7) */
;;;4312   	}
;;;4313   //       v1000_debug("fmt :%d \n",fmt);
;;;4314   	return (disk_ioctl(pdrv, CTRL_SYNC, 0) == RES_OK) ? FR_OK : FR_DISK_ERR;
;;;4315   }
000010  b013              ADD      sp,sp,#0x4c
000012  e8bd8ff0          POP      {r4-r11,pc}
                  |L17.22|
000016  a810              ADD      r0,sp,#0x40           ;4094
000018  f7fffffe          BL       get_ldnumber
00001c  2800              CMP      r0,#0                 ;4095
00001e  da01              BGE      |L17.36|
000020  200b              MOVS     r0,#0xb               ;4095
                  |L17.34|
000022  e7f5              B        |L17.16|
                  |L17.36|
000024  49fe              LDR      r1,|L17.1056|
000026  f8514020          LDR      r4,[r1,r0,LSL #2]     ;4096
00002a  b14c              CBZ      r4,|L17.64|
00002c  2100              MOVS     r1,#0                 ;4098
00002e  7021              STRB     r1,[r4,#0]            ;4098
000030  b2c0              UXTB     r0,r0                 ;4099
000032  9003              STR      r0,[sp,#0xc]          ;4103
000034  f7fffffe          BL       disk_initialize
000038  07c1              LSLS     r1,r0,#31             ;4104
00003a  d003              BEQ      |L17.68|
00003c  2003              MOVS     r0,#3                 ;4104
00003e  e7e7              B        |L17.16|
                  |L17.64|
000040  200c              MOVS     r0,#0xc               ;4097
000042  e7e5              B        |L17.16|
                  |L17.68|
000044  0740              LSLS     r0,r0,#29             ;4105
000046  d501              BPL      |L17.76|
000048  200a              MOVS     r0,#0xa               ;4105
00004a  e7e1              B        |L17.16|
                  |L17.76|
00004c  aa07              ADD      r2,sp,#0x1c           ;4120
00004e  2101              MOVS     r1,#1                 ;4120
000050  9803              LDR      r0,[sp,#0xc]          ;4120
000052  f7fffffe          BL       disk_ioctl
000056  2800              CMP      r0,#0                 ;4120
000058  d17e              BNE      |L17.344|
00005a  9907              LDR      r1,[sp,#0x1c]         ;4120
00005c  2980              CMP      r1,#0x80              ;4120
00005e  d37b              BCC      |L17.344|
000060  9811              LDR      r0,[sp,#0x44]         ;4122
000062  b108              CBZ      r0,|L17.104|
000064  2000              MOVS     r0,#0                 ;4122
000066  e000              B        |L17.106|
                  |L17.104|
000068  203f              MOVS     r0,#0x3f              ;4122
                  |L17.106|
00006a  4680              MOV      r8,r0                 ;4122
00006c  eba10108          SUB      r1,r1,r8              ;4123
000070  1e68              SUBS     r0,r5,#1              ;4126
000072  4205              TST      r5,r0                 ;4126
000074  9107              STR      r1,[sp,#0x1c]         ;4123
000076  d100              BNE      |L17.122|
000078  b97d              CBNZ     r5,|L17.154|
                  |L17.122|
00007a  f44f60fa          MOV      r0,#0x7d0             ;4128
00007e  fbb1f2f0          UDIV     r2,r1,r0              ;4128
000082  2000              MOVS     r0,#0                 ;4129
000084  4be7              LDR      r3,|L17.1060|
000086  e000              B        |L17.138|
                  |L17.136|
000088  1c40              ADDS     r0,r0,#1              ;4129
                  |L17.138|
00008a  f8335010          LDRH     r5,[r3,r0,LSL #1]     ;4129
00008e  4295              CMP      r5,r2                 ;4129
000090  d8fa              BHI      |L17.136|
000092  4ae4              LDR      r2,|L17.1060|
000094  3216              ADDS     r2,r2,#0x16           ;4130
000096  f8325010          LDRH     r5,[r2,r0,LSL #1]     ;4130
                  |L17.154|
00009a  f5b57f00          CMP      r5,#0x200             ;4132
00009e  d300              BCC      |L17.162|
0000a0  0a6d              LSRS     r5,r5,#9              ;4132
                  |L17.162|
0000a2  b185              CBZ      r5,|L17.198|
0000a4  2d80              CMP      r5,#0x80              ;4134
0000a6  d900              BLS      |L17.170|
0000a8  2580              MOVS     r5,#0x80              ;4134
                  |L17.170|
0000aa  fbb1f0f5          UDIV     r0,r1,r5              ;4137
0000ae  2601              MOVS     r6,#1                 ;4138
0000b0  f64072f6          MOV      r2,#0xff6             ;4139
0000b4  4290              CMP      r0,r2                 ;4139
0000b6  d300              BCC      |L17.186|
0000b8  2602              MOVS     r6,#2                 ;4139
                  |L17.186|
0000ba  f64f72f6          MOV      r2,#0xfff6            ;4140
0000be  4290              CMP      r0,r2                 ;4140
0000c0  d303              BCC      |L17.202|
0000c2  2603              MOVS     r6,#3                 ;4140
0000c4  e021              B        |L17.266|
                  |L17.198|
0000c6  2501              MOVS     r5,#1                 ;4133
0000c8  e7ef              B        |L17.170|
                  |L17.202|
0000ca  2e03              CMP      r6,#3                 ;4143
0000cc  d01d              BEQ      |L17.266|
0000ce  2e01              CMP      r6,#1                 ;4148
0000d0  d024              BEQ      |L17.284|
0000d2  0040              LSLS     r0,r0,#1              ;4148
0000d4  f1100004          ADDS.W   r0,r0,#4              ;4148
                  |L17.216|
0000d8  f20010ff          ADD      r0,r0,#0x1ff          ;4148
0000dc  0a47              LSRS     r7,r0,#9              ;4149
0000de  f04f0901          MOV      r9,#1                 ;4150
0000e2  2020              MOVS     r0,#0x20              ;4151
                  |L17.228|
0000e4  4683              MOV      r11,r0                ;4151
0000e6  eb080a09          ADD      r10,r8,r9             ;4153
0000ea  eb0a0007          ADD      r0,r10,r7             ;4154
0000ee  4458              ADD      r0,r0,r11             ;4155
0000f0  1942              ADDS     r2,r0,r5              ;4156
0000f2  9008              STR      r0,[sp,#0x20]         ;4156
0000f4  eba20008          SUB      r0,r2,r8              ;4156
0000f8  4288              CMP      r0,r1                 ;4156
0000fa  d847              BHI      |L17.396|
0000fc  aa09              ADD      r2,sp,#0x24           ;4159
0000fe  2103              MOVS     r1,#3                 ;4159
000100  9803              LDR      r0,[sp,#0xc]          ;4159
000102  f7fffffe          BL       disk_ioctl
000106  b9a0              CBNZ     r0,|L17.306|
000108  e00e              B        |L17.296|
                  |L17.266|
00010a  f2402207          MOV      r2,#0x207             ;4144
00010e  eb020080          ADD      r0,r2,r0,LSL #2       ;4144
000112  0a47              LSRS     r7,r0,#9              ;4144
000114  f04f0920          MOV      r9,#0x20              ;4145
000118  2000              MOVS     r0,#0                 ;4146
00011a  e7e3              B        |L17.228|
                  |L17.284|
00011c  eb000040          ADD      r0,r0,r0,LSL #1       ;4148
000120  1c40              ADDS     r0,r0,#1              ;4148
000122  0840              LSRS     r0,r0,#1              ;4148
000124  1cc0              ADDS     r0,r0,#3              ;4148
000126  e7d7              B        |L17.216|
                  |L17.296|
000128  9809              LDR      r0,[sp,#0x24]         ;4159
00012a  b110              CBZ      r0,|L17.306|
00012c  f5b04f00          CMP      r0,#0x8000            ;4159
000130  d901              BLS      |L17.310|
                  |L17.306|
000132  2001              MOVS     r0,#1                 ;4159
000134  9009              STR      r0,[sp,#0x24]         ;4159
                  |L17.310|
000136  e9dd0108          LDRD     r0,r1,[sp,#0x20]      ;4159
00013a  4408              ADD      r0,r0,r1              ;4164
00013c  1e40              SUBS     r0,r0,#1              ;4164
00013e  1e49              SUBS     r1,r1,#1              ;4164
000140  4388              BICS     r0,r0,r1              ;4164
000142  9908              LDR      r1,[sp,#0x20]         ;4165
000144  1a40              SUBS     r0,r0,r1              ;4165
000146  9009              STR      r0,[sp,#0x24]         ;4166
000148  2e03              CMP      r6,#3                 ;4166
00014a  d012              BEQ      |L17.370|
00014c  4407              ADD      r7,r7,r0              ;4170
                  |L17.334|
00014e  9807              LDR      r0,[sp,#0x1c]         ;4174
000150  eba00109          SUB      r1,r0,r9              ;4174
000154  1bca              SUBS     r2,r1,r7              ;4174
000156  e000              B        |L17.346|
                  |L17.344|
000158  e0e1              B        |L17.798|
                  |L17.346|
00015a  eba2010b          SUB      r1,r2,r11             ;4174
00015e  fbb1f1f5          UDIV     r1,r1,r5              ;4174
000162  910d              STR      r1,[sp,#0x34]         ;4175
000164  2e02              CMP      r6,#2                 ;4175
000166  d007              BEQ      |L17.376|
000168  2e03              CMP      r6,#3                 ;4176
00016a  d00a              BEQ      |L17.386|
00016c  2e01              CMP      r6,#1                 ;4183
00016e  d015              BEQ      |L17.412|
000170  e019              B        |L17.422|
                  |L17.370|
000172  4481              ADD      r9,r9,r0              ;4167
000174  4482              ADD      r10,r10,r0            ;4168
000176  e7ea              B        |L17.334|
                  |L17.376|
000178  f64072f6          MOV      r2,#0xff6             ;4175
00017c  4291              CMP      r1,r2                 ;4175
00017e  d305              BCC      |L17.396|
000180  e011              B        |L17.422|
                  |L17.386|
000182  4608              MOV      r0,r1                 ;4176
000184  f64f71f6          MOV      r1,#0xfff6            ;4176
000188  4288              CMP      r0,r1                 ;4176
00018a  d201              BCS      |L17.400|
                  |L17.396|
00018c  200e              MOVS     r0,#0xe               ;4177
00018e  e73f              B        |L17.16|
                  |L17.400|
000190  200c              MOVS     r0,#0xc               ;4181
                  |L17.402|
000192  9002              STR      r0,[sp,#8]            ;4198
000194  9811              LDR      r0,[sp,#0x44]         ;4198
000196  b168              CBZ      r0,|L17.436|
000198  20f0              MOVS     r0,#0xf0              ;4199
00019a  e047              B        |L17.556|
                  |L17.412|
00019c  f5b03f80          CMP      r0,#0x10000           ;4183
0001a0  d206              BCS      |L17.432|
0001a2  2001              MOVS     r0,#1                 ;4184
0001a4  e7f5              B        |L17.402|
                  |L17.422|
0001a6  f5b03f80          CMP      r0,#0x10000           ;4186
0001aa  d201              BCS      |L17.432|
0001ac  2004              MOVS     r0,#4                 ;4186
0001ae  e7f0              B        |L17.402|
                  |L17.432|
0001b0  2006              MOVS     r0,#6                 ;4186
0001b2  e7ee              B        |L17.402|
                  |L17.436|
0001b4  f1040030          ADD      r0,r4,#0x30           ;4201
0001b8  f44f7200          MOV      r2,#0x200             ;4201
0001bc  2100              MOVS     r1,#0                 ;4201
0001be  9008              STR      r0,[sp,#0x20]         ;4201
0001c0  f7fffffe          BL       mem_set
0001c4  f50470f7          ADD      r0,r4,#0x1ee          ;4202
0001c8  2101              MOVS     r1,#1                 ;4203
0001ca  7041              STRB     r1,[r0,#1]            ;4203
0001cc  7081              STRB     r1,[r0,#2]            ;4204
0001ce  2100              MOVS     r1,#0                 ;4205
0001d0  70c1              STRB     r1,[r0,#3]            ;4205
0001d2  9a02              LDR      r2,[sp,#8]            ;4206
0001d4  7102              STRB     r2,[r0,#4]            ;4206
0001d6  22fe              MOVS     r2,#0xfe              ;4207
0001d8  7142              STRB     r2,[r0,#5]            ;4207
0001da  9b07              LDR      r3,[sp,#0x1c]         ;4208
0001dc  eb080203          ADD      r2,r8,r3              ;4208
0001e0  f64363c1          MOV      r3,#0x3ec1            ;4208
0001e4  fbb2f2f3          UDIV     r2,r2,r3              ;4208
0001e8  233f              MOVS     r3,#0x3f              ;4209
0001ea  ea430c92          ORR      r12,r3,r2,LSR #2      ;4209
0001ee  9209              STR      r2,[sp,#0x24]         ;4209
0001f0  f880c006          STRB     r12,[r0,#6]           ;4209
0001f4  71c2              STRB     r2,[r0,#7]            ;4210
0001f6  7203              STRB     r3,[r0,#8]            ;4211
0001f8  7241              STRB     r1,[r0,#9]            ;4211
0001fa  7281              STRB     r1,[r0,#0xa]          ;4211
0001fc  72c1              STRB     r1,[r0,#0xb]          ;4211
0001fe  9907              LDR      r1,[sp,#0x1c]         ;4212
000200  7301              STRB     r1,[r0,#0xc]          ;4212
000202  0a0a              LSRS     r2,r1,#8              ;4212
000204  7342              STRB     r2,[r0,#0xd]          ;4212
000206  0c0a              LSRS     r2,r1,#16             ;4212
000208  7382              STRB     r2,[r0,#0xe]          ;4212
00020a  0e09              LSRS     r1,r1,#24             ;4212
00020c  73c1              STRB     r1,[r0,#0xf]          ;4212
00020e  2055              MOVS     r0,#0x55              ;4213
000210  f884022e          STRB     r0,[r4,#0x22e]        ;4213
000214  20aa              MOVS     r0,#0xaa              ;4213
000216  f884022f          STRB     r0,[r4,#0x22f]        ;4213
00021a  2301              MOVS     r3,#1                 ;4214
00021c  2200              MOVS     r2,#0                 ;4214
00021e  9908              LDR      r1,[sp,#0x20]         ;4214
000220  9803              LDR      r0,[sp,#0xc]          ;4214
000222  f7fffffe          BL       disk_write
000226  2800              CMP      r0,#0                 ;4214
000228  d179              BNE      |L17.798|
00022a  20f8              MOVS     r0,#0xf8              ;4216
                  |L17.556|
00022c  3430              ADDS     r4,r4,#0x30           ;4222
00022e  9002              STR      r0,[sp,#8]            ;4222
000230  f44f7200          MOV      r2,#0x200             ;4222
000234  2100              MOVS     r1,#0                 ;4222
000236  4620              MOV      r0,r4                 ;4222
000238  f7fffffe          BL       mem_set
00023c  220b              MOVS     r2,#0xb               ;4223
00023e  a17a              ADR      r1,|L17.1064|
000240  4620              MOV      r0,r4                 ;4223
000242  f7fffffe          BL       mem_cpy
000246  2100              MOVS     r1,#0                 ;4225
000248  72e1              STRB     r1,[r4,#0xb]          ;4225
00024a  2002              MOVS     r0,#2                 ;4225
00024c  7320              STRB     r0,[r4,#0xc]          ;4225
00024e  7365              STRB     r5,[r4,#0xd]          ;4226
000250  f884900e          STRB     r9,[r4,#0xe]          ;4227
000254  ea4f2019          LSR      r0,r9,#8              ;4227
000258  73e0              STRB     r0,[r4,#0xf]          ;4227
00025a  2001              MOVS     r0,#1                 ;4228
00025c  7420              STRB     r0,[r4,#0x10]         ;4228
00025e  2e03              CMP      r6,#3                 ;4229
000260  d00b              BEQ      |L17.634|
000262  0240              LSLS     r0,r0,#9              ;4229
                  |L17.612|
000264  7460              STRB     r0,[r4,#0x11]         ;4230
000266  0a00              LSRS     r0,r0,#8              ;4230
000268  74a0              STRB     r0,[r4,#0x12]         ;4230
00026a  9807              LDR      r0,[sp,#0x1c]         ;4231
00026c  f5b03f80          CMP      r0,#0x10000           ;4231
000270  d205              BCS      |L17.638|
000272  74e0              STRB     r0,[r4,#0x13]         ;4232
000274  0a00              LSRS     r0,r0,#8              ;4232
000276  7520              STRB     r0,[r4,#0x14]         ;4232
000278  e00c              B        |L17.660|
                  |L17.634|
00027a  2000              MOVS     r0,#0                 ;4229
00027c  e7f2              B        |L17.612|
                  |L17.638|
00027e  f8840020          STRB     r0,[r4,#0x20]         ;4234
000282  0a02              LSRS     r2,r0,#8              ;4234
000284  f8842021          STRB     r2,[r4,#0x21]         ;4234
000288  0c02              LSRS     r2,r0,#16             ;4234
00028a  f8842022          STRB     r2,[r4,#0x22]         ;4234
00028e  0e00              LSRS     r0,r0,#24             ;4234
000290  f8840023          STRB     r0,[r4,#0x23]         ;4234
                  |L17.660|
000294  9802              LDR      r0,[sp,#8]            ;4236
000296  7560              STRB     r0,[r4,#0x15]         ;4236
000298  203f              MOVS     r0,#0x3f              ;4237
00029a  7620              STRB     r0,[r4,#0x18]         ;4237
00029c  2000              MOVS     r0,#0                 ;4237
00029e  7660              STRB     r0,[r4,#0x19]         ;4237
0002a0  f04f09ff          MOV      r9,#0xff              ;4238
0002a4  f884901a          STRB     r9,[r4,#0x1a]         ;4238
0002a8  76e0              STRB     r0,[r4,#0x1b]         ;4238
0002aa  f884801c          STRB     r8,[r4,#0x1c]         ;4239
0002ae  ea4f2018          LSR      r0,r8,#8              ;4239
0002b2  7760              STRB     r0,[r4,#0x1d]         ;4239
0002b4  ea4f4018          LSR      r0,r8,#16             ;4239
0002b8  77a0              STRB     r0,[r4,#0x1e]         ;4239
0002ba  ea4f6018          LSR      r0,r8,#24             ;4239
0002be  77e0              STRB     r0,[r4,#0x1f]         ;4239
0002c0  f7fffffe          BL       get_fattime
0002c4  2180              MOVS     r1,#0x80              ;4134
0002c6  2229              MOVS     r2,#0x29              ;4248
0002c8  9009              STR      r0,[sp,#0x24]         ;4241
0002ca  2e03              CMP      r6,#3                 ;4241
0002cc  d028              BEQ      |L17.800|
0002ce  f8840027          STRB     r0,[r4,#0x27]         ;4251
0002d2  0a03              LSRS     r3,r0,#8              ;4251
0002d4  f8843028          STRB     r3,[r4,#0x28]         ;4251
0002d8  0c03              LSRS     r3,r0,#16             ;4251
0002da  f8843029          STRB     r3,[r4,#0x29]         ;4251
0002de  0e00              LSRS     r0,r0,#24             ;4251
0002e0  f884002a          STRB     r0,[r4,#0x2a]         ;4251
0002e4  75a7              STRB     r7,[r4,#0x16]         ;4252
0002e6  0a38              LSRS     r0,r7,#8              ;4252
0002e8  75e0              STRB     r0,[r4,#0x17]         ;4252
0002ea  f8841024          STRB     r1,[r4,#0x24]         ;4253
0002ee  f8842026          STRB     r2,[r4,#0x26]         ;4254
0002f2  2213              MOVS     r2,#0x13              ;4255
0002f4  a14f              ADR      r1,|L17.1076|
0002f6  f104002b          ADD      r0,r4,#0x2b           ;4255
0002fa  bf00              NOP                            ;4255
                  |L17.764|
0002fc  f7fffffe          BL       mem_cpy
000300  2055              MOVS     r0,#0x55              ;4257
000302  f88401fe          STRB     r0,[r4,#0x1fe]        ;4257
000306  20aa              MOVS     r0,#0xaa              ;4257
000308  f88401ff          STRB     r0,[r4,#0x1ff]        ;4257
00030c  2301              MOVS     r3,#1                 ;4258
00030e  4642              MOV      r2,r8                 ;4258
000310  4621              MOV      r1,r4                 ;4258
000312  9803              LDR      r0,[sp,#0xc]          ;4258
000314  f7fffffe          BL       disk_write
000318  2800              CMP      r0,#0                 ;4258
00031a  d100              BNE      |L17.798|
00031c  e033              B        |L17.902|
                  |L17.798|
00031e  e0bd              B        |L17.1180|
                  |L17.800|
000320  f8840043          STRB     r0,[r4,#0x43]         ;4242
000324  0a03              LSRS     r3,r0,#8              ;4242
000326  f8843044          STRB     r3,[r4,#0x44]         ;4242
00032a  0c03              LSRS     r3,r0,#16             ;4242
00032c  f8843045          STRB     r3,[r4,#0x45]         ;4242
000330  0e00              LSRS     r0,r0,#24             ;4242
000332  f8840046          STRB     r0,[r4,#0x46]         ;4242
000336  f8847024          STRB     r7,[r4,#0x24]         ;4243
00033a  0a38              LSRS     r0,r7,#8              ;4243
00033c  f8840025          STRB     r0,[r4,#0x25]         ;4243
000340  0c38              LSRS     r0,r7,#16             ;4243
000342  f8840026          STRB     r0,[r4,#0x26]         ;4243
000346  0e38              LSRS     r0,r7,#24             ;4243
000348  f8840027          STRB     r0,[r4,#0x27]         ;4243
00034c  2002              MOVS     r0,#2                 ;4244
00034e  f884002c          STRB     r0,[r4,#0x2c]         ;4244
000352  2000              MOVS     r0,#0                 ;4244
000354  f884002d          STRB     r0,[r4,#0x2d]         ;4244
000358  f884002e          STRB     r0,[r4,#0x2e]         ;4244
00035c  f884002f          STRB     r0,[r4,#0x2f]         ;4244
000360  2301              MOVS     r3,#1                 ;4245
000362  f8843030          STRB     r3,[r4,#0x30]         ;4245
000366  f8840031          STRB     r0,[r4,#0x31]         ;4245
00036a  2306              MOVS     r3,#6                 ;4246
00036c  f8843032          STRB     r3,[r4,#0x32]         ;4246
000370  f8840033          STRB     r0,[r4,#0x33]         ;4246
000374  f8841040          STRB     r1,[r4,#0x40]         ;4247
000378  f8842042          STRB     r2,[r4,#0x42]         ;4248
00037c  2213              MOVS     r2,#0x13              ;4249
00037e  a132              ADR      r1,|L17.1096|
000380  f1040047          ADD      r0,r4,#0x47           ;4249
000384  e7ba              B        |L17.764|
                  |L17.902|
000386  2e03              CMP      r6,#3                 ;4260
000388  d106              BNE      |L17.920|
00038a  2301              MOVS     r3,#1                 ;4261
00038c  f1080206          ADD      r2,r8,#6              ;4261
000390  4621              MOV      r1,r4                 ;4261
000392  9803              LDR      r0,[sp,#0xc]          ;4261
000394  f7fffffe          BL       disk_write
                  |L17.920|
000398  f44f7200          MOV      r2,#0x200             ;4266
00039c  2100              MOVS     r1,#0                 ;4266
00039e  4620              MOV      r0,r4                 ;4266
0003a0  f7fffffe          BL       mem_set
0003a4  9802              LDR      r0,[sp,#8]            ;4267
0003a6  9009              STR      r0,[sp,#0x24]         ;4268
0003a8  2e03              CMP      r6,#3                 ;4268
0003aa  d012              BEQ      |L17.978|
0003ac  2e01              CMP      r6,#1                 ;4269
0003ae  d00e              BEQ      |L17.974|
0003b0  f06f01ff          MVN      r1,#0xff              ;4269
                  |L17.948|
0003b4  4301              ORRS     r1,r1,r0              ;4269
0003b6  9109              STR      r1,[sp,#0x24]         ;4270
0003b8  7021              STRB     r1,[r4,#0]            ;4270
0003ba  9809              LDR      r0,[sp,#0x24]         ;4270
0003bc  0a00              LSRS     r0,r0,#8              ;4270
0003be  7060              STRB     r0,[r4,#1]            ;4270
0003c0  9809              LDR      r0,[sp,#0x24]         ;4270
0003c2  0c00              LSRS     r0,r0,#16             ;4270
0003c4  70a0              STRB     r0,[r4,#2]            ;4270
0003c6  9809              LDR      r0,[sp,#0x24]         ;4270
0003c8  0e00              LSRS     r0,r0,#24             ;4270
0003ca  70e0              STRB     r0,[r4,#3]            ;4270
0003cc  e01e              B        |L17.1036|
                  |L17.974|
0003ce  4923              LDR      r1,|L17.1116|
0003d0  e7f0              B        |L17.948|
                  |L17.978|
0003d2  f06000ff          ORN      r0,r0,#0xff           ;4272
0003d6  9009              STR      r0,[sp,#0x24]         ;4273
0003d8  7020              STRB     r0,[r4,#0]            ;4273
0003da  9809              LDR      r0,[sp,#0x24]         ;4273
0003dc  0a00              LSRS     r0,r0,#8              ;4273
0003de  7060              STRB     r0,[r4,#1]            ;4273
0003e0  9809              LDR      r0,[sp,#0x24]         ;4273
0003e2  0c00              LSRS     r0,r0,#16             ;4273
0003e4  70a0              STRB     r0,[r4,#2]            ;4273
0003e6  9809              LDR      r0,[sp,#0x24]         ;4273
0003e8  0e00              LSRS     r0,r0,#24             ;4273
0003ea  70e0              STRB     r0,[r4,#3]            ;4273
0003ec  f8849004          STRB     r9,[r4,#4]            ;4274
0003f0  f8849005          STRB     r9,[r4,#5]            ;4274
0003f4  f8849006          STRB     r9,[r4,#6]            ;4274
0003f8  f8849007          STRB     r9,[r4,#7]            ;4274
0003fc  f8849008          STRB     r9,[r4,#8]            ;4275
000400  f8849009          STRB     r9,[r4,#9]            ;4275
000404  f884900a          STRB     r9,[r4,#0xa]          ;4275
000408  200f              MOVS     r0,#0xf               ;4275
00040a  72e0              STRB     r0,[r4,#0xb]          ;4275
                  |L17.1036|
00040c  4652              MOV      r2,r10                ;4277
00040e  f10a0901          ADD      r9,r10,#1             ;4277
000412  2301              MOVS     r3,#1                 ;4277
000414  4621              MOV      r1,r4                 ;4277
000416  9803              LDR      r0,[sp,#0xc]          ;4277
000418  f7fffffe          BL       disk_write
00041c  bbf0              CBNZ     r0,|L17.1180|
00041e  e01f              B        |L17.1120|
                  |L17.1056|
                          DCD      ||.data||+0x4
                  |L17.1060|
                          DCD      ||.constdata||+0x80
                  |L17.1064|
000428  ebfe904d          DCB      235,254,144,"MSDOS5.0",0
00042c  53444f53
000430  352e3000
                  |L17.1076|
000434  4e4f204e          DCB      "NO NAME    FAT     ",0
000438  414d4520
00043c  20202046
000440  41542020
000444  20202000
                  |L17.1096|
000448  4e4f204e          DCB      "NO NAME    FAT32   ",0
00044c  414d4520
000450  20202046
000454  41543332
000458  20202000
                  |L17.1116|
                          DCD      0x00ffff00
                  |L17.1120|
000460  f44f7200          MOV      r2,#0x200             ;4279
000464  2100              MOVS     r1,#0                 ;4279
000466  4620              MOV      r0,r4                 ;4279
000468  f7fffffe          BL       mem_set
00046c  2001              MOVS     r0,#1                 ;4281
00046e  e00a              B        |L17.1158|
                  |L17.1136|
000470  464a              MOV      r2,r9                 ;4282
000472  f1090901          ADD      r9,r9,#1              ;4282
000476  2301              MOVS     r3,#1                 ;4282
000478  4621              MOV      r1,r4                 ;4282
00047a  9803              LDR      r0,[sp,#0xc]          ;4282
00047c  f7fffffe          BL       disk_write
000480  b960              CBNZ     r0,|L17.1180|
000482  9809              LDR      r0,[sp,#0x24]         ;4281
000484  1c40              ADDS     r0,r0,#1              ;4281
                  |L17.1158|
000486  9009              STR      r0,[sp,#0x24]         ;4281
000488  42b8              CMP      r0,r7                 ;4281
00048a  d3f1              BCC      |L17.1136|
00048c  2e03              CMP      r6,#3                 ;4288
00048e  d000              BEQ      |L17.1170|
000490  465d              MOV      r5,r11                ;4288
                  |L17.1170|
000492  464a              MOV      r2,r9                 ;4292
000494  f1090901          ADD      r9,r9,#1              ;4292
000498  2301              MOVS     r3,#1                 ;4292
00049a  e000              B        |L17.1182|
                  |L17.1180|
00049c  e042              B        |L17.1316|
                  |L17.1182|
00049e  4621              MOV      r1,r4                 ;4292
0004a0  9803              LDR      r0,[sp,#0xc]          ;4292
0004a2  f7fffffe          BL       disk_write
0004a6  bbe8              CBNZ     r0,|L17.1316|
0004a8  1e6d              SUBS     r5,r5,#1              ;4292
0004aa  d1f2              BNE      |L17.1170|
0004ac  2e03              CMP      r6,#3                 ;4304
0004ae  d13c              BNE      |L17.1322|
0004b0  2052              MOVS     r0,#0x52              ;4305
0004b2  7020              STRB     r0,[r4,#0]            ;4305
0004b4  7060              STRB     r0,[r4,#1]            ;4305
0004b6  2061              MOVS     r0,#0x61              ;4305
0004b8  70a0              STRB     r0,[r4,#2]            ;4305
0004ba  2141              MOVS     r1,#0x41              ;4305
0004bc  70e1              STRB     r1,[r4,#3]            ;4305
0004be  2272              MOVS     r2,#0x72              ;4306
0004c0  f88421e4          STRB     r2,[r4,#0x1e4]        ;4306
0004c4  f88421e5          STRB     r2,[r4,#0x1e5]        ;4306
0004c8  f88411e6          STRB     r1,[r4,#0x1e6]        ;4306
0004cc  f88401e7          STRB     r0,[r4,#0x1e7]        ;4306
0004d0  980d              LDR      r0,[sp,#0x34]         ;4307
0004d2  2301              MOVS     r3,#1                 ;4310
0004d4  1e40              SUBS     r0,r0,#1              ;4307
0004d6  f88401e8          STRB     r0,[r4,#0x1e8]        ;4307
0004da  0a01              LSRS     r1,r0,#8              ;4307
0004dc  f88411e9          STRB     r1,[r4,#0x1e9]        ;4307
0004e0  0c01              LSRS     r1,r0,#16             ;4307
0004e2  f88411ea          STRB     r1,[r4,#0x1ea]        ;4307
0004e6  0e00              LSRS     r0,r0,#24             ;4307
0004e8  f88401eb          STRB     r0,[r4,#0x1eb]        ;4307
0004ec  2002              MOVS     r0,#2                 ;4308
0004ee  f88401ec          STRB     r0,[r4,#0x1ec]        ;4308
0004f2  2000              MOVS     r0,#0                 ;4308
0004f4  f88401ed          STRB     r0,[r4,#0x1ed]        ;4308
0004f8  f88401ee          STRB     r0,[r4,#0x1ee]        ;4308
0004fc  f88401ef          STRB     r0,[r4,#0x1ef]        ;4308
000500  2055              MOVS     r0,#0x55              ;4309
000502  f88401fe          STRB     r0,[r4,#0x1fe]        ;4309
000506  20aa              MOVS     r0,#0xaa              ;4309
000508  f88401ff          STRB     r0,[r4,#0x1ff]        ;4309
00050c  f1080201          ADD      r2,r8,#1              ;4310
000510  4621              MOV      r1,r4                 ;4310
000512  9803              LDR      r0,[sp,#0xc]          ;4310
000514  f7fffffe          BL       disk_write
000518  2301              MOVS     r3,#1                 ;4311
00051a  f1080207          ADD      r2,r8,#7              ;4311
00051e  4621              MOV      r1,r4                 ;4311
000520  9803              LDR      r0,[sp,#0xc]          ;4311
000522  e000              B        |L17.1318|
                  |L17.1316|
000524  e009              B        |L17.1338|
                  |L17.1318|
000526  f7fffffe          BL       disk_write
                  |L17.1322|
00052a  2200              MOVS     r2,#0                 ;4314
00052c  4611              MOV      r1,r2                 ;4314
00052e  9803              LDR      r0,[sp,#0xc]          ;4314
000530  f7fffffe          BL       disk_ioctl
000534  2800              CMP      r0,#0                 ;4314
000536  f43fad74          BEQ      |L17.34|
                  |L17.1338|
00053a  2001              MOVS     r0,#1                 ;4314
00053c  e568              B        |L17.16|
;;;4316   
                          ENDP


                          AREA ||i.f_mount||, CODE, READONLY, ALIGN=2

                  f_mount PROC
;;;2405   
;;;2406   FRESULT f_mount (
000000  b517              PUSH     {r0-r2,r4,lr}
;;;2407   	FATFS* fs,			/* Pointer to the file system object (NULL:unmount)*/
;;;2408   	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
;;;2409   	BYTE opt			/* 0:Do not mount (delayed mount), 1:Mount immediately */
;;;2410   )
;;;2411   {
000002  b081              SUB      sp,sp,#4
000004  4614              MOV      r4,r2
;;;2412   	FATFS *cfs;
;;;2413   	int vol;
;;;2414   	FRESULT res;
;;;2415   	const TCHAR *rp = path;
000006  9802              LDR      r0,[sp,#8]
;;;2416   
;;;2417   
;;;2418   	vol = get_ldnumber(&rp);
000008  9000              STR      r0,[sp,#0]
00000a  4668              MOV      r0,sp
00000c  f7fffffe          BL       get_ldnumber
;;;2419   	if (vol < 0) return FR_INVALID_DRIVE;
000010  2800              CMP      r0,#0
000012  da02              BGE      |L18.26|
000014  200b              MOVS     r0,#0xb
                  |L18.22|
;;;2420   	cfs = FatFs[vol];					/* Pointer to fs object */
;;;2421   
;;;2422   	if (cfs) {
;;;2423   #if _FS_LOCK
;;;2424   		clear_lock(cfs);
;;;2425   #endif
;;;2426   #if _FS_REENTRANT						/* Discard sync object of the current volume */
;;;2427   		if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
;;;2428   #endif
;;;2429   		cfs->fs_type = 0;				/* Clear old fs object */
;;;2430   	}
;;;2431   
;;;2432   	if (fs) {
;;;2433   		fs->fs_type = 0;				/* Clear new fs object */
;;;2434   #if _FS_REENTRANT						/* Create sync object for the new volume */
;;;2435   		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
;;;2436   #endif
;;;2437   	}
;;;2438   	FatFs[vol] = fs;					/* Register new fs object */
;;;2439   
;;;2440   	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
;;;2441   
;;;2442   	res = find_volume(&fs, &path, 0);	/* Force mounted the volume */
;;;2443   	LEAVE_FF(fs, res);
;;;2444   }
000016  b004              ADD      sp,sp,#0x10
000018  bd10              POP      {r4,pc}
                  |L18.26|
00001a  4a0b              LDR      r2,|L18.72|
00001c  2300              MOVS     r3,#0                 ;2420
00001e  f8521020          LDR      r1,[r2,r0,LSL #2]     ;2420
000022  b101              CBZ      r1,|L18.38|
000024  700b              STRB     r3,[r1,#0]            ;2429
                  |L18.38|
000026  9901              LDR      r1,[sp,#4]            ;2432
000028  2900              CMP      r1,#0                 ;2432
00002a  d000              BEQ      |L18.46|
00002c  700b              STRB     r3,[r1,#0]            ;2433
                  |L18.46|
00002e  f8421020          STR      r1,[r2,r0,LSL #2]     ;2438
000032  d001              BEQ      |L18.56|
000034  2c01              CMP      r4,#1                 ;2440
000036  d001              BEQ      |L18.60|
                  |L18.56|
000038  2000              MOVS     r0,#0                 ;2440
00003a  e7ec              B        |L18.22|
                  |L18.60|
00003c  2200              MOVS     r2,#0                 ;2442
00003e  a902              ADD      r1,sp,#8              ;2442
000040  a801              ADD      r0,sp,#4              ;2442
000042  f7fffffe          BL       find_volume
000046  e7e6              B        |L18.22|
;;;2445   
                          ENDP

                  |L18.72|
                          DCD      ||.data||+0x4

                          AREA ||i.f_open||, CODE, READONLY, ALIGN=1

                  f_open PROC
;;;2452   
;;;2453   FRESULT f_open (
000000  e92d47f7          PUSH     {r0-r2,r4-r10,lr}
;;;2454   	FIL* fp,			/* Pointer to the blank file object */
;;;2455   	const TCHAR* path,	/* Pointer to the file name */
;;;2456   	BYTE mode			/* Access mode and file open mode flags */
;;;2457   )
;;;2458   {
000004  b08b              SUB      sp,sp,#0x2c
000006  0006              MOVS     r6,r0
000008  d00e              BEQ      |L19.40|
;;;2459   	FRESULT res;
;;;2460   	DIR dj;
;;;2461   	BYTE *dir;
;;;2462   	DEFINE_NAMEBUF;
;;;2463   #if !_FS_READONLY
;;;2464   	DWORD dw, cl;
;;;2465   #endif
;;;2466   
;;;2467   
;;;2468   	if (!fp)
;;;2469       {
;;;2470   //        v1000_debug("fp = null \r\n");
;;;2471           return FR_INVALID_OBJECT;
;;;2472   	}
;;;2473   	fp->fs = 0;			/* Clear file object */
00000a  f04f0800          MOV      r8,#0
;;;2474   
;;;2475   	/* Get logical drive number */
;;;2476   #if !_FS_READONLY
;;;2477   	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
00000e  f002071f          AND      r7,r2,#0x1f
;;;2478   	res = find_volume(&dj.fs, &path, (BYTE)(mode & ~FA_READ));
000012  f0270201          BIC      r2,r7,#1
000016  a90c              ADD      r1,sp,#0x30
000018  4668              MOV      r0,sp
00001a  f8c68000          STR      r8,[r6,#0]
00001e  f7fffffe          BL       find_volume
000022  0005              MOVS     r5,r0
;;;2479   #else
;;;2480   	mode &= FA_READ;
;;;2481   	res = find_volume(&dj.fs, &path, 0);
;;;2482   #endif
;;;2483   	if (res == FR_OK) {
000024  d004              BEQ      |L19.48|
000026  e089              B        |L19.316|
                  |L19.40|
000028  2009              MOVS     r0,#9                 ;2471
                  |L19.42|
;;;2484   		INIT_BUF(dj);
;;;2485   		res = follow_path(&dj, path);	/* Follow the file path */
;;;2486   		dir = dj.dir;
;;;2487   #if !_FS_READONLY	/* R/W configuration */
;;;2488   		if (res == FR_OK) {
;;;2489   			if (!dir)	/* Default directory itself */
;;;2490   				res = FR_INVALID_NAME;
;;;2491   #if _FS_LOCK
;;;2492   			else
;;;2493   				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
;;;2494   #endif
;;;2495   		}
;;;2496   		/* Create or Open a file */
;;;2497   		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
;;;2498   			if (res != FR_OK) {					/* No file, create new */
;;;2499   				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
;;;2500   #if _FS_LOCK
;;;2501   					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
;;;2502   #else
;;;2503   					res = dir_register(&dj);
;;;2504   #endif
;;;2505   				mode |= FA_CREATE_ALWAYS;		/* File is created */
;;;2506   				dir = dj.dir;					/* New entry */
;;;2507   			}
;;;2508   			else {								/* Any object is already existing */
;;;2509   				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
;;;2510   					res = FR_DENIED;
;;;2511   				} else {
;;;2512   					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
;;;2513   						res = FR_EXIST;
;;;2514   				}
;;;2515   			}
;;;2516   			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
;;;2517   				dw = GET_FATTIME();
;;;2518   				ST_DWORD(dir + DIR_CrtTime, dw);/* Set created time */
;;;2519   				ST_DWORD(dir + DIR_WrtTime, dw);/* Set modified time */
;;;2520   				dir[DIR_Attr] = 0;				/* Reset attribute */
;;;2521   				ST_DWORD(dir + DIR_FileSize, 0);/* Reset file size */
;;;2522   				cl = ld_clust(dj.fs, dir);		/* Get cluster chain */
;;;2523   				st_clust(dir, 0);				/* Reset cluster */
;;;2524   				dj.fs->wflag = 1;
;;;2525   				if (cl) {						/* Remove the cluster chain if exist */
;;;2526   					dw = dj.fs->winsect;
;;;2527   					res = remove_chain(dj.fs, cl);
;;;2528   					if (res == FR_OK) {
;;;2529   						dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
;;;2530   						res = move_window(dj.fs, dw);
;;;2531   					}
;;;2532   				}
;;;2533   			}
;;;2534   		}
;;;2535   		else {	/* Open an existing file */
;;;2536   			if (res == FR_OK) {					/* Following succeeded */
;;;2537   				if (dir[DIR_Attr] & AM_DIR) {	/* It is a directory */
;;;2538   					res = FR_NO_FILE;
;;;2539   				} else {
;;;2540   					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
;;;2541   						res = FR_DENIED;
;;;2542   				}
;;;2543   			}
;;;2544   		}
;;;2545   		if (res == FR_OK) {
;;;2546   			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
;;;2547   				mode |= FA__WRITTEN;
;;;2548   			fp->dir_sect = dj.fs->winsect;		/* Pointer to the directory entry */
;;;2549   			fp->dir_ptr = dir;
;;;2550   #if _FS_LOCK
;;;2551   			fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
;;;2552   			if (!fp->lockid) res = FR_INT_ERR;
;;;2553   #endif
;;;2554   		}
;;;2555   
;;;2556   #else				/* R/O configuration */
;;;2557   		if (res == FR_OK) {					/* Follow succeeded */
;;;2558   			dir = dj.dir;
;;;2559   			if (!dir) {						/* Current directory itself */
;;;2560   				res = FR_INVALID_NAME;
;;;2561   			} else {
;;;2562   				if (dir[DIR_Attr] & AM_DIR)	/* It is a directory */
;;;2563   					res = FR_NO_FILE;
;;;2564   			}
;;;2565   		}
;;;2566   #endif
;;;2567   		FREE_BUF();
;;;2568   
;;;2569   		if (res == FR_OK) {
;;;2570   			fp->flag = mode;					/* File access mode */
;;;2571   			fp->err = 0;						/* Clear error flag */
;;;2572   			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
;;;2573   			fp->fsize = LD_DWORD(dir + DIR_FileSize);	/* File size */
;;;2574   			fp->fptr = 0;						/* File pointer */
;;;2575   			fp->dsect = 0;
;;;2576   #if _USE_FASTSEEK
;;;2577   			fp->cltbl = 0;						/* Normal seek mode */
;;;2578   #endif
;;;2579   			fp->fs = dj.fs;	 					/* Validate file object */
;;;2580   			fp->id = fp->fs->id;
;;;2581   		}
;;;2582   	}
;;;2583   
;;;2584   	LEAVE_FF(dj.fs, res);
;;;2585   }
00002a  b00e              ADD      sp,sp,#0x38
00002c  e8bd87f0          POP      {r4-r10,pc}
                  |L19.48|
000030  a807              ADD      r0,sp,#0x1c           ;2484
000032  9006              STR      r0,[sp,#0x18]         ;2485
000034  4668              MOV      r0,sp                 ;2485
000036  990c              LDR      r1,[sp,#0x30]         ;2485
000038  f7fffffe          BL       follow_path
00003c  9c05              LDR      r4,[sp,#0x14]         ;2488
00003e  0005              MOVS     r5,r0                 ;2485
000040  d101              BNE      |L19.70|
000042  b904              CBNZ     r4,|L19.70|
000044  2506              MOVS     r5,#6                 ;2490
                  |L19.70|
000046  f0170f1c          TST      r7,#0x1c              ;2497
00004a  d050              BEQ      |L19.238|
00004c  b155              CBZ      r5,|L19.100|
00004e  2d04              CMP      r5,#4                 ;2499
000050  d103              BNE      |L19.90|
000052  4668              MOV      r0,sp                 ;2503
000054  f7fffffe          BL       dir_register
000058  4605              MOV      r5,r0                 ;2503
                  |L19.90|
00005a  9c05              LDR      r4,[sp,#0x14]         ;2506
00005c  f0470708          ORR      r7,r7,#8              ;2505
000060  b155              CBZ      r5,|L19.120|
000062  e06b              B        |L19.316|
                  |L19.100|
000064  7ae0              LDRB     r0,[r4,#0xb]          ;2509
000066  f0100f11          TST      r0,#0x11              ;2509
00006a  d001              BEQ      |L19.112|
                  |L19.108|
00006c  2507              MOVS     r5,#7                 ;2510
00006e  e065              B        |L19.316|
                  |L19.112|
000070  0778              LSLS     r0,r7,#29             ;2512
000072  d501              BPL      |L19.120|
000074  2508              MOVS     r5,#8                 ;2513
000076  e061              B        |L19.316|
                  |L19.120|
000078  0738              LSLS     r0,r7,#28             ;2516
00007a  d546              BPL      |L19.266|
00007c  f7fffffe          BL       get_fattime
000080  73a0              STRB     r0,[r4,#0xe]          ;2518
000082  0a01              LSRS     r1,r0,#8              ;2518
000084  73e1              STRB     r1,[r4,#0xf]          ;2518
000086  0c02              LSRS     r2,r0,#16             ;2518
000088  7422              STRB     r2,[r4,#0x10]         ;2518
00008a  0e03              LSRS     r3,r0,#24             ;2518
00008c  7463              STRB     r3,[r4,#0x11]         ;2518
00008e  75a0              STRB     r0,[r4,#0x16]         ;2519
000090  75e1              STRB     r1,[r4,#0x17]         ;2519
000092  7622              STRB     r2,[r4,#0x18]         ;2519
000094  7663              STRB     r3,[r4,#0x19]         ;2519
000096  f884800b          STRB     r8,[r4,#0xb]          ;2520
00009a  f884801c          STRB     r8,[r4,#0x1c]         ;2521
00009e  f884801d          STRB     r8,[r4,#0x1d]         ;2521
0000a2  f884801e          STRB     r8,[r4,#0x1e]         ;2521
0000a6  f884801f          STRB     r8,[r4,#0x1f]         ;2521
0000aa  4621              MOV      r1,r4                 ;2522
0000ac  9800              LDR      r0,[sp,#0]            ;2522
0000ae  f7fffffe          BL       ld_clust
0000b2  4681              MOV      r9,r0                 ;2522
0000b4  2100              MOVS     r1,#0                 ;2523
0000b6  4620              MOV      r0,r4                 ;2523
0000b8  f7fffffe          BL       st_clust
0000bc  9900              LDR      r1,[sp,#0]            ;2524
0000be  2001              MOVS     r0,#1                 ;2524
0000c0  f1b90f00          CMP      r9,#0                 ;2525
0000c4  7108              STRB     r0,[r1,#4]            ;2524
0000c6  d01e              BEQ      |L19.262|
0000c8  9800              LDR      r0,[sp,#0]            ;2526
0000ca  4649              MOV      r1,r9                 ;2527
0000cc  f8d0a02c          LDR      r10,[r0,#0x2c]        ;2527
0000d0  f7fffffe          BL       remove_chain
0000d4  0005              MOVS     r5,r0                 ;2527
0000d6  d131              BNE      |L19.316|
0000d8  9900              LDR      r1,[sp,#0]            ;2529
0000da  f1a90001          SUB      r0,r9,#1              ;2529
0000de  60c8              STR      r0,[r1,#0xc]          ;2530
0000e0  4651              MOV      r1,r10                ;2530
0000e2  9800              LDR      r0,[sp,#0]            ;2530
0000e4  f7fffffe          BL       move_window
0000e8  0005              MOVS     r5,r0                 ;2530
0000ea  d00a              BEQ      |L19.258|
0000ec  e026              B        |L19.316|
                  |L19.238|
0000ee  bb2d              CBNZ     r5,|L19.316|
0000f0  7ae0              LDRB     r0,[r4,#0xb]          ;2537
0000f2  06c1              LSLS     r1,r0,#27             ;2537
0000f4  d501              BPL      |L19.250|
0000f6  2504              MOVS     r5,#4                 ;2538
0000f8  e020              B        |L19.316|
                  |L19.250|
0000fa  07b9              LSLS     r1,r7,#30             ;2540
0000fc  d501              BPL      |L19.258|
0000fe  07c0              LSLS     r0,r0,#31             ;2540
000100  d1b4              BNE      |L19.108|
                  |L19.258|
000102  0738              LSLS     r0,r7,#28             ;2546
000104  d501              BPL      |L19.266|
                  |L19.262|
000106  f0470720          ORR      r7,r7,#0x20           ;2547
                  |L19.266|
00010a  9800              LDR      r0,[sp,#0]            ;2548
00010c  4621              MOV      r1,r4                 ;2572
00010e  6ac0              LDR      r0,[r0,#0x2c]         ;2548
000110  e9c60407          STRD     r0,r4,[r6,#0x1c]      ;2548
000114  71b7              STRB     r7,[r6,#6]            ;2570
000116  f8868007          STRB     r8,[r6,#7]            ;2571
00011a  4647              MOV      r7,r8                 ;2571
00011c  9800              LDR      r0,[sp,#0]            ;2572
00011e  f7fffffe          BL       ld_clust
000122  6130              STR      r0,[r6,#0x10]         ;2573
000124  7f20              LDRB     r0,[r4,#0x1c]         ;2573
000126  f8d4101d          LDR      r1,[r4,#0x1d]         ;2573
00012a  ea402001          ORR      r0,r0,r1,LSL #8       ;2573
00012e  e9c67002          STRD     r7,r0,[r6,#8]         ;2573
000132  61b7              STR      r7,[r6,#0x18]         ;2579
000134  9800              LDR      r0,[sp,#0]            ;2579
000136  6030              STR      r0,[r6,#0]            ;2580
000138  88c0              LDRH     r0,[r0,#6]            ;2580
00013a  80b0              STRH     r0,[r6,#4]            ;2580
                  |L19.316|
00013c  4628              MOV      r0,r5                 ;2584
00013e  e774              B        |L19.42|
;;;2586   
                          ENDP


                          AREA ||i.f_opendir||, CODE, READONLY, ALIGN=1

                  f_opendir PROC
;;;3194   
;;;3195   FRESULT f_opendir (
000000  b513              PUSH     {r0,r1,r4,lr}
;;;3196   	DIR* dp,			/* Pointer to directory object to create */
;;;3197   	const TCHAR* path	/* Pointer to the directory path */
;;;3198   )
;;;3199   {
000002  b084              SUB      sp,sp,#0x10
000004  0004              MOVS     r4,r0
000006  d006              BEQ      |L20.22|
;;;3200   	FRESULT res;
;;;3201   	FATFS* fs;
;;;3202   	DEFINE_NAMEBUF;
;;;3203   
;;;3204   
;;;3205   	if (!dp) return FR_INVALID_OBJECT;
;;;3206   
;;;3207   	/* Get logical drive number */
;;;3208   	res = find_volume(&fs, &path, 0);
000008  2200              MOVS     r2,#0
00000a  a905              ADD      r1,sp,#0x14
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       find_volume
;;;3209   	if (res == FR_OK) {
000012  b118              CBZ      r0,|L20.28|
000014  e01f              B        |L20.86|
                  |L20.22|
000016  2009              MOVS     r0,#9                 ;3205
                  |L20.24|
;;;3210   		dp->fs = fs;
;;;3211   		INIT_BUF(*dp);
;;;3212   		res = follow_path(dp, path);			/* Follow the path to the directory */
;;;3213   		FREE_BUF();
;;;3214   		if (res == FR_OK) {						/* Follow completed */
;;;3215   			if (dp->dir) {						/* It is not the origin directory itself */
;;;3216   				if (dp->dir[DIR_Attr] & AM_DIR)	/* The object is a sub directory */
;;;3217   					dp->sclust = ld_clust(fs, dp->dir);
;;;3218   				else							/* The object is a file */
;;;3219   					res = FR_NO_PATH;
;;;3220   			}
;;;3221   			if (res == FR_OK) {
;;;3222   				dp->id = fs->id;
;;;3223   				res = dir_sdi(dp, 0);			/* Rewind directory */
;;;3224   #if _FS_LOCK
;;;3225   				if (res == FR_OK) {
;;;3226   					if (dp->sclust) {
;;;3227   						dp->lockid = inc_lock(dp, 0);	/* Lock the sub directory */
;;;3228   						if (!dp->lockid)
;;;3229   							res = FR_TOO_MANY_OPEN_FILES;
;;;3230   					} else {
;;;3231   						dp->lockid = 0;	/* Root directory need not to be locked */
;;;3232   					}
;;;3233   				}
;;;3234   #endif
;;;3235   			}
;;;3236   		}
;;;3237   		if (res == FR_NO_FILE) res = FR_NO_PATH;
;;;3238   	}
;;;3239   	if (res != FR_OK) dp->fs = 0;		/* Invalidate the directory object if function faild */
;;;3240   
;;;3241   	LEAVE_FF(fs, res);
;;;3242   }
000018  b006              ADD      sp,sp,#0x18
00001a  bd10              POP      {r4,pc}
                  |L20.28|
00001c  9800              LDR      r0,[sp,#0]            ;3210
00001e  6020              STR      r0,[r4,#0]            ;3211
000020  a801              ADD      r0,sp,#4              ;3211
000022  61a0              STR      r0,[r4,#0x18]         ;3212
000024  4620              MOV      r0,r4                 ;3212
000026  9905              LDR      r1,[sp,#0x14]         ;3212
000028  f7fffffe          BL       follow_path
00002c  b978              CBNZ     r0,|L20.78|
00002e  6961              LDR      r1,[r4,#0x14]         ;3215
000030  b131              CBZ      r1,|L20.64|
000032  7ac8              LDRB     r0,[r1,#0xb]          ;3216
000034  06c0              LSLS     r0,r0,#27             ;3216
000036  d511              BPL      |L20.92|
000038  9800              LDR      r0,[sp,#0]            ;3217
00003a  f7fffffe          BL       ld_clust
00003e  60a0              STR      r0,[r4,#8]            ;3217
                  |L20.64|
000040  9800              LDR      r0,[sp,#0]            ;3222
000042  2100              MOVS     r1,#0                 ;3223
000044  88c0              LDRH     r0,[r0,#6]            ;3222
000046  80a0              STRH     r0,[r4,#4]            ;3222
000048  4620              MOV      r0,r4                 ;3223
00004a  f7fffffe          BL       dir_sdi
                  |L20.78|
00004e  2804              CMP      r0,#4                 ;3237
000050  d004              BEQ      |L20.92|
000052  2800              CMP      r0,#0                 ;3239
000054  d0e0              BEQ      |L20.24|
                  |L20.86|
000056  2100              MOVS     r1,#0                 ;3239
000058  6021              STR      r1,[r4,#0]            ;3239
00005a  e7dd              B        |L20.24|
                  |L20.92|
00005c  2005              MOVS     r0,#5                 ;3237
00005e  e7fa              B        |L20.86|
;;;3243   
                          ENDP


                          AREA ||i.f_printf||, CODE, READONLY, ALIGN=2

                  f_printf PROC
;;;4593   
;;;4594   int f_printf (
000000  b40f              PUSH     {r0-r3}
;;;4595   	FIL* fp,			/* Pointer to the file object */
;;;4596   	const TCHAR* fmt,	/* Pointer to the format string */
;;;4597   	...					/* Optional arguments... */
;;;4598   )
;;;4599   {
000002  e92d47f0          PUSH     {r4-r10,lr}
000006  b09a              SUB      sp,sp,#0x68
;;;4600   	va_list arp;
;;;4601   	BYTE f, r;
;;;4602   	UINT nw, i, j, w;
;;;4603   	DWORD v;
;;;4604   	TCHAR c, d, s[16], *p;
;;;4605   	putbuff pb;
;;;4606   
;;;4607   
;;;4608   	pb.fp = fp;				/* Initialize output buffer */
;;;4609   	pb.nchr = pb.idx = 0;
;;;4610   
;;;4611   	va_start(arp, fmt);
000008  f10d0990          ADD      r9,sp,#0x90
00000c  9002              STR      r0,[sp,#8]            ;4609
00000e  2000              MOVS     r0,#0                 ;4609
000010  9003              STR      r0,[sp,#0xc]          ;4609
000012  f10d0854          ADD      r8,sp,#0x54           ;4604
000016  9004              STR      r0,[sp,#0x10]         ;4604
                  |L21.24|
;;;4612   
;;;4613   	for (;;) {
;;;4614   		c = *fmt++;
000018  9823              LDR      r0,[sp,#0x8c]
00001a  f8101b01          LDRB     r1,[r0],#1
;;;4615   		if (c == 0) break;			/* End of string */
00001e  9023              STR      r0,[sp,#0x8c]
000020  2900              CMP      r1,#0
000022  d076              BEQ      |L21.274|
;;;4616   		if (c != '%') {				/* Non escape character */
000024  2925              CMP      r1,#0x25
000026  d003              BEQ      |L21.48|
                  |L21.40|
;;;4617   			putc_bfd(&pb, c);
000028  a802              ADD      r0,sp,#8
00002a  f7fffffe          BL       putc_bfd
;;;4618   			continue;
00002e  e7f3              B        |L21.24|
                  |L21.48|
;;;4619   		}
;;;4620   		w = f = 0;
000030  2500              MOVS     r5,#0
;;;4621   		c = *fmt++;
000032  f8101b01          LDRB     r1,[r0],#1
000036  462e              MOV      r6,r5                 ;4620
;;;4622   		if (c == '0') {				/* Flag: '0' padding */
000038  9023              STR      r0,[sp,#0x8c]
00003a  2930              CMP      r1,#0x30
00003c  d002              BEQ      |L21.68|
;;;4623   			f = 1; c = *fmt++;
;;;4624   		} else {
;;;4625   			if (c == '-') {			/* Flag: left justified */
00003e  292d              CMP      r1,#0x2d
000040  d002              BEQ      |L21.72|
000042  e010              B        |L21.102|
                  |L21.68|
000044  2501              MOVS     r5,#1                 ;4623
000046  e000              B        |L21.74|
                  |L21.72|
;;;4626   				f = 2; c = *fmt++;
000048  2502              MOVS     r5,#2
                  |L21.74|
00004a  f8101b01          LDRB     r1,[r0],#1
00004e  9023              STR      r0,[sp,#0x8c]
000050  e009              B        |L21.102|
;;;4627   			}
;;;4628   		}
;;;4629   		while (IsDigit(c)) {		/* Precision */
;;;4630   			w = w * 10 + c - '0';
000052  bf00              NOP      
                  |L21.84|
000054  eb060086          ADD      r0,r6,r6,LSL #2
000058  eb010640          ADD      r6,r1,r0,LSL #1
;;;4631   			c = *fmt++;
00005c  9823              LDR      r0,[sp,#0x8c]
00005e  3e30              SUBS     r6,r6,#0x30
000060  f8101b01          LDRB     r1,[r0],#1
000064  9023              STR      r0,[sp,#0x8c]
                  |L21.102|
000066  f1a10030          SUB      r0,r1,#0x30           ;4629
00006a  2809              CMP      r0,#9                 ;4629
00006c  d9f2              BLS      |L21.84|
;;;4632   		}
;;;4633   		if (c == 'l' || c == 'L') {	/* Prefix: Size is long int */
00006e  296c              CMP      r1,#0x6c
000070  d001              BEQ      |L21.118|
000072  294c              CMP      r1,#0x4c
000074  d105              BNE      |L21.130|
                  |L21.118|
;;;4634   			f |= 4; c = *fmt++;
000076  9823              LDR      r0,[sp,#0x8c]
000078  f0450504          ORR      r5,r5,#4
00007c  f8101b01          LDRB     r1,[r0],#1
000080  9023              STR      r0,[sp,#0x8c]
                  |L21.130|
;;;4635   		}
;;;4636   		if (!c) break;
000082  2900              CMP      r1,#0
000084  d045              BEQ      |L21.274|
;;;4637   		d = c;
;;;4638   		if (IsLower(d)) d -= 0x20;
000086  f1a10061          SUB      r0,r1,#0x61
00008a  460a              MOV      r2,r1                 ;4637
00008c  2819              CMP      r0,#0x19
00008e  d801              BHI      |L21.148|
000090  3a20              SUBS     r2,r2,#0x20
000092  b2d2              UXTB     r2,r2
                  |L21.148|
;;;4639   		switch (d) {				/* Type is... */
000094  2a4f              CMP      r2,#0x4f
000096  d042              BEQ      |L21.286|
000098  dc06              BGT      |L21.168|
00009a  2a42              CMP      r2,#0x42
00009c  d03d              BEQ      |L21.282|
00009e  2a43              CMP      r2,#0x43
0000a0  d038              BEQ      |L21.276|
0000a2  2a44              CMP      r2,#0x44
0000a4  d1c0              BNE      |L21.40|
0000a6  e03c              B        |L21.290|
                  |L21.168|
0000a8  2a53              CMP      r2,#0x53
0000aa  d00d              BEQ      |L21.200|
0000ac  2a55              CMP      r2,#0x55
0000ae  d038              BEQ      |L21.290|
0000b0  2a58              CMP      r2,#0x58
0000b2  d1b9              BNE      |L21.40|
;;;4640   		case 'S' :					/* String */
;;;4641   			p = va_arg(arp, TCHAR*);
;;;4642   			for (j = 0; p[j]; j++) ;
;;;4643   			if (!(f & 2)) {
;;;4644   				while (j++ < w) putc_bfd(&pb, ' ');
;;;4645   			}
;;;4646   			while (*p) putc_bfd(&pb, *p++);
;;;4647   			while (j++ < w) putc_bfd(&pb, ' ');
;;;4648   			continue;
;;;4649   		case 'C' :					/* Character */
;;;4650   			putc_bfd(&pb, (TCHAR)va_arg(arp, int)); continue;
;;;4651   		case 'B' :					/* Binary */
;;;4652   			r = 2; break;
;;;4653   		case 'O' :					/* Octal */
;;;4654   			r = 8; break;
;;;4655   		case 'D' :					/* Signed decimal */
;;;4656   		case 'U' :					/* Unsigned decimal */
;;;4657   			r = 10; break;
;;;4658   		case 'X' :					/* Hexdecimal */
;;;4659   			r = 16; break;
0000b4  2310              MOVS     r3,#0x10
                  |L21.182|
;;;4660   		default:					/* Unknown type (pass-through) */
;;;4661   			putc_bfd(&pb, c); continue;
;;;4662   		}
;;;4663   
;;;4664   		/* Get an argument and put it in numeral */
;;;4665   		v = (f & 4) ? (DWORD)va_arg(arp, long) : ((d == 'D') ? (DWORD)(long)va_arg(arp, int) : (DWORD)va_arg(arp, unsigned int));
0000b6  0768              LSLS     r0,r5,#29
0000b8  d401              BMI      |L21.190|
0000ba  2a44              CMP      r2,#0x44
0000bc  d033              BEQ      |L21.294|
                  |L21.190|
0000be  f8590b04          LDR      r0,[r9],#4
;;;4666   		if (d == 'D' && (v & 0x80000000)) {
0000c2  2a44              CMP      r2,#0x44
0000c4  d031              BEQ      |L21.298|
0000c6  e035              B        |L21.308|
                  |L21.200|
0000c8  f8597b04          LDR      r7,[r9],#4            ;4641
0000cc  2400              MOVS     r4,#0                 ;4642
0000ce  e000              B        |L21.210|
                  |L21.208|
0000d0  1c64              ADDS     r4,r4,#1              ;4642
                  |L21.210|
0000d2  5d38              LDRB     r0,[r7,r4]            ;4642
0000d4  2800              CMP      r0,#0                 ;4642
0000d6  d1fb              BNE      |L21.208|
0000d8  07a8              LSLS     r0,r5,#30             ;4643
0000da  d504              BPL      |L21.230|
0000dc  e00c              B        |L21.248|
                  |L21.222|
0000de  2120              MOVS     r1,#0x20              ;4644
0000e0  a802              ADD      r0,sp,#8              ;4644
0000e2  f7fffffe          BL       putc_bfd
                  |L21.230|
0000e6  4620              MOV      r0,r4                 ;4644
0000e8  1c64              ADDS     r4,r4,#1              ;4644
0000ea  42b0              CMP      r0,r6                 ;4644
0000ec  d3f7              BCC      |L21.222|
0000ee  e003              B        |L21.248|
                  |L21.240|
0000f0  a802              ADD      r0,sp,#8              ;4646
0000f2  1c7f              ADDS     r7,r7,#1              ;4646
0000f4  f7fffffe          BL       putc_bfd
                  |L21.248|
0000f8  7839              LDRB     r1,[r7,#0]            ;4646
0000fa  2900              CMP      r1,#0                 ;4646
0000fc  d1f8              BNE      |L21.240|
0000fe  e003              B        |L21.264|
                  |L21.256|
000100  2120              MOVS     r1,#0x20              ;4647
000102  a802              ADD      r0,sp,#8              ;4647
000104  f7fffffe          BL       putc_bfd
                  |L21.264|
000108  4620              MOV      r0,r4                 ;4647
00010a  1c64              ADDS     r4,r4,#1              ;4647
00010c  42b0              CMP      r0,r6                 ;4647
                  |L21.270|
00010e  d283              BCS      |L21.24|
000110  e7f6              B        |L21.256|
                  |L21.274|
000112  e052              B        |L21.442|
                  |L21.276|
000114  f8191b04          LDRB     r1,[r9],#4            ;4650
000118  e786              B        |L21.40|
                  |L21.282|
00011a  2302              MOVS     r3,#2                 ;4652
00011c  e7cb              B        |L21.182|
                  |L21.286|
00011e  2308              MOVS     r3,#8                 ;4654
000120  e7c9              B        |L21.182|
                  |L21.290|
000122  230a              MOVS     r3,#0xa               ;4657
000124  e7c7              B        |L21.182|
                  |L21.294|
000126  f8590b04          LDR      r0,[r9],#4            ;4665
                  |L21.298|
00012a  2800              CMP      r0,#0
00012c  da02              BGE      |L21.308|
;;;4667   			v = 0 - v;
00012e  4240              RSBS     r0,r0,#0
;;;4668   			f |= 8;
000130  f0450508          ORR      r5,r5,#8
                  |L21.308|
;;;4669   		}
;;;4670   		i = 0;
000134  2400              MOVS     r4,#0
000136  4647              MOV      r7,r8                 ;4604
                  |L21.312|
;;;4671   		do {
;;;4672   			d = (TCHAR)(v % r); v /= r;
000138  4602              MOV      r2,r0
00013a  fbb0f0f3          UDIV     r0,r0,r3
00013e  fb032210          MLS      r2,r3,r0,r2
000142  b2d2              UXTB     r2,r2
;;;4673   			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
000144  2a09              CMP      r2,#9
000146  d905              BLS      |L21.340|
000148  2978              CMP      r1,#0x78
00014a  d014              BEQ      |L21.374|
00014c  f04f0c07          MOV      r12,#7
                  |L21.336|
000150  4462              ADD      r2,r2,r12
000152  b2d2              UXTB     r2,r2
                  |L21.340|
000154  3230              ADDS     r2,r2,#0x30
;;;4674   			s[i++] = d + '0';
000156  553a              STRB     r2,[r7,r4]
000158  1c64              ADDS     r4,r4,#1
;;;4675   		} while (v && i < sizeof s / sizeof s[0]);
00015a  b108              CBZ      r0,|L21.352|
00015c  2c10              CMP      r4,#0x10
00015e  d3eb              BCC      |L21.312|
                  |L21.352|
;;;4676   		if (f & 8) s[i++] = '-';
000160  0728              LSLS     r0,r5,#28
000162  d503              BPL      |L21.364|
000164  202d              MOVS     r0,#0x2d
000166  f8080004          STRB     r0,[r8,r4]
00016a  1c64              ADDS     r4,r4,#1
                  |L21.364|
;;;4677   		j = i; d = (f & 1) ? '0' : ' ';
00016c  4627              MOV      r7,r4
00016e  07e8              LSLS     r0,r5,#31
000170  d004              BEQ      |L21.380|
000172  2030              MOVS     r0,#0x30
000174  e003              B        |L21.382|
                  |L21.374|
000176  f04f0c27          MOV      r12,#0x27             ;4673
00017a  e7e9              B        |L21.336|
                  |L21.380|
00017c  2020              MOVS     r0,#0x20
                  |L21.382|
00017e  4682              MOV      r10,r0
;;;4678   		while (!(f & 2) && j++ < w) putc_bfd(&pb, d);
000180  e003              B        |L21.394|
                  |L21.386|
000182  4651              MOV      r1,r10
000184  a802              ADD      r0,sp,#8
000186  f7fffffe          BL       putc_bfd
                  |L21.394|
00018a  07a8              LSLS     r0,r5,#30
00018c  d403              BMI      |L21.406|
00018e  4638              MOV      r0,r7
000190  1c7f              ADDS     r7,r7,#1
000192  42b0              CMP      r0,r6
000194  d3f5              BCC      |L21.386|
                  |L21.406|
000196  4645              MOV      r5,r8                 ;4604
                  |L21.408|
000198  1e64              SUBS     r4,r4,#1              ;4604
;;;4679   		do putc_bfd(&pb, s[--i]); while (i);
00019a  a802              ADD      r0,sp,#8
00019c  5d29              LDRB     r1,[r5,r4]
00019e  f7fffffe          BL       putc_bfd
0001a2  2c00              CMP      r4,#0
0001a4  d1f8              BNE      |L21.408|
0001a6  e003              B        |L21.432|
                  |L21.424|
;;;4680   		while (j++ < w) putc_bfd(&pb, d);
0001a8  4651              MOV      r1,r10
0001aa  a802              ADD      r0,sp,#8
0001ac  f7fffffe          BL       putc_bfd
                  |L21.432|
0001b0  4638              MOV      r0,r7
0001b2  1c7f              ADDS     r7,r7,#1
0001b4  42b0              CMP      r0,r6
0001b6  d2aa              BCS      |L21.270|
0001b8  e7f6              B        |L21.424|
                  |L21.442|
;;;4681   	}
;;;4682   
;;;4683   	va_end(arp);
;;;4684   
;;;4685   	if (   pb.idx >= 0		/* Flush buffered characters to the file */
0001ba  9803              LDR      r0,[sp,#0xc]
0001bc  2800              CMP      r0,#0
0001be  db10              BLT      |L21.482|
;;;4686   		&& f_write(pb.fp, pb.buf, (UINT)pb.idx, &nw) == FR_OK
0001c0  4602              MOV      r2,r0
0001c2  ab01              ADD      r3,sp,#4
0001c4  a905              ADD      r1,sp,#0x14
0001c6  9802              LDR      r0,[sp,#8]
0001c8  f7fffffe          BL       f_write
0001cc  b948              CBNZ     r0,|L21.482|
;;;4687   		&& (UINT)pb.idx == nw) return pb.nchr;
0001ce  9901              LDR      r1,[sp,#4]
0001d0  9803              LDR      r0,[sp,#0xc]
0001d2  4288              CMP      r0,r1
0001d4  d105              BNE      |L21.482|
0001d6  9804              LDR      r0,[sp,#0x10]
                  |L21.472|
;;;4688   	return EOF;
;;;4689   }
0001d8  b01a              ADD      sp,sp,#0x68
0001da  e8bd07f0          POP      {r4-r10}
0001de  f85dfb14          LDR      pc,[sp],#0x14
                  |L21.482|
0001e2  f04f30ff          MOV      r0,#0xffffffff        ;4688
0001e6  e7f7              B        |L21.472|
;;;4690   
                          ENDP


                          AREA ||i.f_putc||, CODE, READONLY, ALIGN=1

                  f_putc PROC
;;;4538   
;;;4539   int f_putc (
000000  b500              PUSH     {lr}
;;;4540   	TCHAR c,	/* A character to be output */
;;;4541   	FIL* fp		/* Pointer to the file object */
;;;4542   )
;;;4543   {
000002  b095              SUB      sp,sp,#0x54
;;;4544   	putbuff pb;
;;;4545   	UINT nw;
;;;4546   
;;;4547   
;;;4548   	pb.fp = fp;			/* Initialize output buffer */
;;;4549   	pb.nchr = pb.idx = 0;
000004  9102              STR      r1,[sp,#8]
000006  2100              MOVS     r1,#0
000008  9103              STR      r1,[sp,#0xc]
;;;4550   
;;;4551   	putc_bfd(&pb, c);	/* Put a character */
00000a  9104              STR      r1,[sp,#0x10]
00000c  4601              MOV      r1,r0
00000e  a802              ADD      r0,sp,#8
000010  f7fffffe          BL       putc_bfd
;;;4552   
;;;4553   	if (   pb.idx >= 0	/* Flush buffered characters to the file */
000014  9803              LDR      r0,[sp,#0xc]
000016  2800              CMP      r0,#0
000018  db0d              BLT      |L22.54|
;;;4554   		&& f_write(pb.fp, pb.buf, (UINT)pb.idx, &nw) == FR_OK
00001a  4602              MOV      r2,r0
00001c  ab01              ADD      r3,sp,#4
00001e  a905              ADD      r1,sp,#0x14
000020  9802              LDR      r0,[sp,#8]
000022  f7fffffe          BL       f_write
000026  b930              CBNZ     r0,|L22.54|
;;;4555   		&& (UINT)pb.idx == nw) return pb.nchr;
000028  9901              LDR      r1,[sp,#4]
00002a  9803              LDR      r0,[sp,#0xc]
00002c  4288              CMP      r0,r1
00002e  d102              BNE      |L22.54|
000030  9804              LDR      r0,[sp,#0x10]
                  |L22.50|
;;;4556   	return EOF;
;;;4557   }
000032  b015              ADD      sp,sp,#0x54
000034  bd00              POP      {pc}
                  |L22.54|
000036  f04f30ff          MOV      r0,#0xffffffff        ;4556
00003a  e7fa              B        |L22.50|
;;;4558   
                          ENDP


                          AREA ||i.f_puts||, CODE, READONLY, ALIGN=1

                  f_puts PROC
;;;4565   
;;;4566   int f_puts (
000000  b510              PUSH     {r4,lr}
;;;4567   	const TCHAR* str,	/* Pointer to the string to be output */
;;;4568   	FIL* fp				/* Pointer to the file object */
;;;4569   )
;;;4570   {
000002  b096              SUB      sp,sp,#0x58
000004  4604              MOV      r4,r0
;;;4571   	putbuff pb;
;;;4572   	UINT nw;
;;;4573   
;;;4574   
;;;4575   	pb.fp = fp;				/* Initialize output buffer */
;;;4576   	pb.nchr = pb.idx = 0;
000006  2000              MOVS     r0,#0
000008  e9cd1002          STRD     r1,r0,[sp,#8]
00000c  9004              STR      r0,[sp,#0x10]         ;4570
00000e  e003              B        |L23.24|
                  |L23.16|
;;;4577   
;;;4578   	while (*str)			/* Put the string */
;;;4579   		putc_bfd(&pb, *str++);
000010  a802              ADD      r0,sp,#8
000012  1c64              ADDS     r4,r4,#1
000014  f7fffffe          BL       putc_bfd
                  |L23.24|
000018  7821              LDRB     r1,[r4,#0]            ;4578
00001a  2900              CMP      r1,#0                 ;4578
00001c  d1f8              BNE      |L23.16|
;;;4580   
;;;4581   	if (   pb.idx >= 0		/* Flush buffered characters to the file */
00001e  9803              LDR      r0,[sp,#0xc]
000020  2800              CMP      r0,#0
000022  db0d              BLT      |L23.64|
;;;4582   		&& f_write(pb.fp, pb.buf, (UINT)pb.idx, &nw) == FR_OK
000024  4602              MOV      r2,r0
000026  ab01              ADD      r3,sp,#4
000028  a905              ADD      r1,sp,#0x14
00002a  9802              LDR      r0,[sp,#8]
00002c  f7fffffe          BL       f_write
000030  b930              CBNZ     r0,|L23.64|
;;;4583   		&& (UINT)pb.idx == nw) return pb.nchr;
000032  9901              LDR      r1,[sp,#4]
000034  9803              LDR      r0,[sp,#0xc]
000036  4288              CMP      r0,r1
000038  d102              BNE      |L23.64|
00003a  9804              LDR      r0,[sp,#0x10]
                  |L23.60|
;;;4584   	return EOF;
;;;4585   }
00003c  b016              ADD      sp,sp,#0x58
00003e  bd10              POP      {r4,pc}
                  |L23.64|
000040  f04f30ff          MOV      r0,#0xffffffff        ;4584
000044  e7fa              B        |L23.60|
;;;4586   
                          ENDP


                          AREA ||i.f_read||, CODE, READONLY, ALIGN=1

                  f_read PROC
;;;2593   
;;;2594   FRESULT f_read (
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;2595   	FIL* fp, 		/* Pointer to the file object */
;;;2596   	void* buff,		/* Pointer to data buffer */
;;;2597   	UINT btr,		/* Number of bytes to read */
;;;2598   	UINT* br		/* Pointer to number of bytes read */
;;;2599   )
;;;2600   {
000004  4604              MOV      r4,r0
;;;2601   	FRESULT res;
;;;2602   	DWORD clst, sect, remain;
;;;2603   	UINT rcnt, cc;
;;;2604   	BYTE csect, *rbuff = (BYTE*)buff;
;;;2605   
;;;2606   
;;;2607   	*br = 0;	/* Clear read byte counter */
000006  2000              MOVS     r0,#0
;;;2608   
;;;2609   	res = validate(fp);							/* Check validity */
000008  6018              STR      r0,[r3,#0]
00000a  4699              MOV      r9,r3                 ;2600
00000c  4615              MOV      r5,r2                 ;2600
00000e  4688              MOV      r8,r1                 ;2604
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       validate
;;;2610   	if (res != FR_OK) LEAVE_FF(fp->fs, res);
000016  2800              CMP      r0,#0
000018  d112              BNE      |L24.64|
;;;2611   	if (fp->err)								/* Check error */
00001a  79e0              LDRB     r0,[r4,#7]
00001c  2800              CMP      r0,#0
00001e  d10f              BNE      |L24.64|
;;;2612   		LEAVE_FF(fp->fs, (FRESULT)fp->err);
;;;2613   	if (!(fp->flag & FA_READ)) 					/* Check access mode */
000020  79a0              LDRB     r0,[r4,#6]
000022  07c0              LSLS     r0,r0,#31
000024  d00b              BEQ      |L24.62|
000026  e9d41002          LDRD     r1,r0,[r4,#8]
;;;2614   		LEAVE_FF(fp->fs, FR_DENIED);
;;;2615   	remain = fp->fsize - fp->fptr;
00002a  1a40              SUBS     r0,r0,r1
;;;2616   	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
;;;2617   
;;;2618   	for ( ;  btr;								/* Repeat until all data read */
;;;2619   		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
;;;2620   		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
;;;2621   			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
;;;2622   			if (!csect) {						/* On the cluster boundary? */
;;;2623   				if (fp->fptr == 0) {			/* On the top of the file? */
;;;2624   					clst = fp->sclust;			/* Follow from the origin */
;;;2625   				} else {						/* Middle or end of the file */
;;;2626   #if _USE_FASTSEEK
;;;2627   					if (fp->cltbl)
;;;2628   						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
;;;2629   					else
;;;2630   #endif
;;;2631   						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
;;;2632   				}
;;;2633   				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
;;;2634   				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
00002c  2701              MOVS     r7,#1
00002e  f04f0a02          MOV      r10,#2                ;2633
;;;2635   				fp->clust = clst;				/* Update current cluster */
;;;2636   			}
;;;2637   			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
;;;2638   			if (!sect) ABORT(fp->fs, FR_INT_ERR);
;;;2639   			sect += csect;
;;;2640   			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
;;;2641   			if (cc) {							/* Read maximum contiguous sectors directly */
;;;2642   				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
;;;2643   					cc = fp->fs->csize - csect;
;;;2644   				if (disk_read(fp->fs->drv, rbuff, sect, cc) != RES_OK)
;;;2645   					ABORT(fp->fs, FR_DISK_ERR);
;;;2646   #if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
;;;2647   #if _FS_TINY
;;;2648   				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
;;;2649   					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
;;;2650   #else
;;;2651   				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
;;;2652   					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
000032  f1040b24          ADD      r11,r4,#0x24
000036  4285              CMP      r5,r0                 ;2616
000038  d900              BLS      |L24.60|
00003a  4605              MOV      r5,r0                 ;2616
                  |L24.60|
00003c  e080              B        |L24.320|
                  |L24.62|
00003e  2007              MOVS     r0,#7                 ;2614
                  |L24.64|
;;;2653   #endif
;;;2654   #endif
;;;2655   				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
;;;2656   				continue;
;;;2657   			}
;;;2658   #if !_FS_TINY
;;;2659   			if (fp->dsect != sect) {			/* Load data sector if not in cache */
;;;2660   #if !_FS_READONLY
;;;2661   				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
;;;2662   					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
;;;2663   						ABORT(fp->fs, FR_DISK_ERR);
;;;2664   					fp->flag &= ~FA__DIRTY;
;;;2665   				}
;;;2666   #endif
;;;2667   				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
;;;2668   					ABORT(fp->fs, FR_DISK_ERR);
;;;2669   			}
;;;2670   #endif
;;;2671   			fp->dsect = sect;
;;;2672   		}
;;;2673   		rcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
;;;2674   		if (rcnt > btr) rcnt = btr;
;;;2675   #if _FS_TINY
;;;2676   		if (move_window(fp->fs, fp->dsect) != FR_OK)		/* Move sector window */
;;;2677   			ABORT(fp->fs, FR_DISK_ERR);
;;;2678   		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
;;;2679   #else
;;;2680   		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
;;;2681   #endif
;;;2682   	}
;;;2683   
;;;2684   	LEAVE_FF(fp->fs, FR_OK);
;;;2685   }
000040  e8bd9ffc          POP      {r2-r12,pc}
                  |L24.68|
000044  68a0              LDR      r0,[r4,#8]            ;2620
000046  05c1              LSLS     r1,r0,#23             ;2620
000048  d162              BNE      |L24.272|
00004a  6822              LDR      r2,[r4,#0]            ;2621
00004c  7891              LDRB     r1,[r2,#2]            ;2621
00004e  1e49              SUBS     r1,r1,#1              ;2621
000050  ea012150          AND      r1,r1,r0,LSR #9       ;2621
000054  f01106ff          ANDS     r6,r1,#0xff           ;2621
000058  d109              BNE      |L24.110|
00005a  b308              CBZ      r0,|L24.160|
00005c  4610              MOV      r0,r2                 ;2631
00005e  6961              LDR      r1,[r4,#0x14]         ;2631
000060  f7fffffe          BL       get_fat
                  |L24.100|
000064  2802              CMP      r0,#2                 ;2633
000066  d31d              BCC      |L24.164|
000068  1c41              ADDS     r1,r0,#1              ;2634
00006a  d04c              BEQ      |L24.262|
00006c  6160              STR      r0,[r4,#0x14]         ;2635
                  |L24.110|
00006e  6961              LDR      r1,[r4,#0x14]         ;2637
000070  6820              LDR      r0,[r4,#0]            ;2637
000072  f7fffffe          BL       clust2sect
000076  b1a8              CBZ      r0,|L24.164|
000078  4430              ADD      r0,r0,r6              ;2639
00007a  9001              STR      r0,[sp,#4]            ;2640
00007c  0a68              LSRS     r0,r5,#9              ;2640
00007e  9000              STR      r0,[sp,#0]            ;2641
000080  d027              BEQ      |L24.210|
000082  1832              ADDS     r2,r6,r0              ;2642
000084  6820              LDR      r0,[r4,#0]            ;2642
000086  7881              LDRB     r1,[r0,#2]            ;2642
000088  428a              CMP      r2,r1                 ;2642
00008a  d901              BLS      |L24.144|
00008c  1b89              SUBS     r1,r1,r6              ;2643
00008e  9100              STR      r1,[sp,#0]            ;2643
                  |L24.144|
000090  e9dd3200          LDRD     r3,r2,[sp,#0]         ;2644
000094  7840              LDRB     r0,[r0,#1]            ;2644
000096  4641              MOV      r1,r8                 ;2644
000098  f7fffffe          BL       disk_read
00009c  bb98              CBNZ     r0,|L24.262|
00009e  e005              B        |L24.172|
                  |L24.160|
0000a0  6920              LDR      r0,[r4,#0x10]         ;2624
0000a2  e7df              B        |L24.100|
                  |L24.164|
0000a4  f884a007          STRB     r10,[r4,#7]           ;2638
0000a8  2002              MOVS     r0,#2                 ;2638
0000aa  e7c9              B        |L24.64|
                  |L24.172|
0000ac  79a0              LDRB     r0,[r4,#6]            ;2651
0000ae  0640              LSLS     r0,r0,#25             ;2651
0000b0  d50c              BPL      |L24.204|
0000b2  69a1              LDR      r1,[r4,#0x18]         ;2651
0000b4  9801              LDR      r0,[sp,#4]            ;2651
0000b6  1a08              SUBS     r0,r1,r0              ;2651
0000b8  9900              LDR      r1,[sp,#0]            ;2651
0000ba  4288              CMP      r0,r1                 ;2651
0000bc  d206              BCS      |L24.204|
0000be  eb082040          ADD      r0,r8,r0,LSL #9       ;2652
0000c2  f44f7200          MOV      r2,#0x200             ;2652
0000c6  4659              MOV      r1,r11                ;2652
0000c8  f7fffffe          BL       mem_cpy
                  |L24.204|
0000cc  9800              LDR      r0,[sp,#0]            ;2655
0000ce  0246              LSLS     r6,r0,#9              ;2655
0000d0  e02c              B        |L24.300|
                  |L24.210|
0000d2  69a2              LDR      r2,[r4,#0x18]         ;2659
0000d4  9801              LDR      r0,[sp,#4]            ;2659
0000d6  4282              CMP      r2,r0                 ;2659
0000d8  d018              BEQ      |L24.268|
0000da  79a0              LDRB     r0,[r4,#6]            ;2661
0000dc  0640              LSLS     r0,r0,#25             ;2661
0000de  d50a              BPL      |L24.246|
0000e0  6820              LDR      r0,[r4,#0]            ;2662
0000e2  2301              MOVS     r3,#1                 ;2662
0000e4  4659              MOV      r1,r11                ;2662
0000e6  7840              LDRB     r0,[r0,#1]            ;2662
0000e8  f7fffffe          BL       disk_write
0000ec  b958              CBNZ     r0,|L24.262|
0000ee  79a0              LDRB     r0,[r4,#6]            ;2664
0000f0  f0200040          BIC      r0,r0,#0x40           ;2664
0000f4  71a0              STRB     r0,[r4,#6]            ;2664
                  |L24.246|
0000f6  6820              LDR      r0,[r4,#0]            ;2667
0000f8  2301              MOVS     r3,#1                 ;2667
0000fa  4659              MOV      r1,r11                ;2667
0000fc  7840              LDRB     r0,[r0,#1]            ;2667
0000fe  9a01              LDR      r2,[sp,#4]            ;2667
000100  f7fffffe          BL       disk_read
000104  b110              CBZ      r0,|L24.268|
                  |L24.262|
000106  71e7              STRB     r7,[r4,#7]            ;2668
000108  2001              MOVS     r0,#1                 ;2668
00010a  e799              B        |L24.64|
                  |L24.268|
00010c  9801              LDR      r0,[sp,#4]            ;2671
00010e  61a0              STR      r0,[r4,#0x18]         ;2671
                  |L24.272|
000110  8920              LDRH     r0,[r4,#8]            ;2673
000112  f3c00008          UBFX     r0,r0,#0,#9           ;2673
000116  f5c07600          RSB      r6,r0,#0x200          ;2673
00011a  42ae              CMP      r6,r5                 ;2674
00011c  d900              BLS      |L24.288|
00011e  462e              MOV      r6,r5                 ;2674
                  |L24.288|
000120  1901              ADDS     r1,r0,r4              ;2680
000122  4632              MOV      r2,r6                 ;2680
000124  4640              MOV      r0,r8                 ;2680
000126  3124              ADDS     r1,r1,#0x24           ;2680
000128  f7fffffe          BL       mem_cpy
                  |L24.300|
00012c  68a0              LDR      r0,[r4,#8]            ;2619
00012e  44b0              ADD      r8,r8,r6              ;2619
000130  4430              ADD      r0,r0,r6              ;2619
000132  60a0              STR      r0,[r4,#8]            ;2619
000134  f8d90000          LDR      r0,[r9,#0]            ;2619
000138  1981              ADDS     r1,r0,r6              ;2619
00013a  1bad              SUBS     r5,r5,r6              ;2619
00013c  f8c91000          STR      r1,[r9,#0]            ;2619
                  |L24.320|
000140  2d00              CMP      r5,#0                 ;2618
000142  f47faf7f          BNE      |L24.68|
000146  2000              MOVS     r0,#0                 ;2684
000148  e77a              B        |L24.64|
;;;2686   
                          ENDP


                          AREA ||i.f_readdir||, CODE, READONLY, ALIGN=1

                  f_readdir PROC
;;;3282   
;;;3283   FRESULT f_readdir (
000000  b5fe              PUSH     {r1-r7,lr}
;;;3284   	DIR* dp,			/* Pointer to the open directory object */
;;;3285   	FILINFO* fno		/* Pointer to file information to return */
;;;3286   )
;;;3287   {
000002  460e              MOV      r6,r1
000004  4604              MOV      r4,r0
;;;3288   	FRESULT res;
;;;3289   	DEFINE_NAMEBUF;
;;;3290   
;;;3291   
;;;3292   	res = validate(dp);						/* Check validity of the object */
000006  f7fffffe          BL       validate
;;;3293   	if (res == FR_OK) {
00000a  2800              CMP      r0,#0
00000c  d117              BNE      |L25.62|
;;;3294   		if (!fno) {
00000e  b1be              CBZ      r6,|L25.64|
;;;3295   			res = dir_sdi(dp, 0);			/* Rewind the directory object */
;;;3296   		} else {
;;;3297   			INIT_BUF(*dp);
000010  f8c4d018          STR      sp,[r4,#0x18]
;;;3298   			res = dir_read(dp, 0);			/* Read an item */
000014  2100              MOVS     r1,#0
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       dir_read
00001c  2500              MOVS     r5,#0
;;;3299   			if (res == FR_NO_FILE) {		/* Reached end of directory */
00001e  2804              CMP      r0,#4
000020  d013              BEQ      |L25.74|
;;;3300   				dp->sect = 0;
;;;3301   				res = FR_OK;
;;;3302   			}
;;;3303   			if (res == FR_OK) {				/* A valid entry is found */
000022  2800              CMP      r0,#0
000024  d10b              BNE      |L25.62|
                  |L25.38|
;;;3304   				get_fileinfo(dp, fno);		/* Get the object information */
000026  4631              MOV      r1,r6
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       get_fileinfo
;;;3305   				res = dir_next(dp, 0);		/* Increment index for next */
00002e  2100              MOVS     r1,#0
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       dir_next
;;;3306   				if (res == FR_NO_FILE) {
000036  2804              CMP      r0,#4
000038  d101              BNE      |L25.62|
;;;3307   					dp->sect = 0;
;;;3308   					res = FR_OK;
00003a  2000              MOVS     r0,#0
00003c  6125              STR      r5,[r4,#0x10]
                  |L25.62|
;;;3309   				}
;;;3310   			}
;;;3311   			FREE_BUF();
;;;3312   		}
;;;3313   	}
;;;3314   
;;;3315   	LEAVE_FF(dp->fs, res);
;;;3316   }
00003e  bdfe              POP      {r1-r7,pc}
                  |L25.64|
000040  2100              MOVS     r1,#0                 ;3295
000042  4620              MOV      r0,r4                 ;3295
000044  f7fffffe          BL       dir_sdi
000048  bdfe              POP      {r1-r7,pc}
                  |L25.74|
00004a  6125              STR      r5,[r4,#0x10]         ;3301
00004c  e7eb              B        |L25.38|
;;;3317   
                          ENDP


                          AREA ||i.f_rename||, CODE, READONLY, ALIGN=1

                  f_rename PROC
;;;3718   
;;;3719   FRESULT f_rename (
000000  b533              PUSH     {r0,r1,r4,r5,lr}
;;;3720   	const TCHAR* path_old,	/* Pointer to the object to be renamed */
;;;3721   	const TCHAR* path_new	/* Pointer to the new name */
;;;3722   )
;;;3723   {
000002  b099              SUB      sp,sp,#0x64
;;;3724   	FRESULT res;
;;;3725   	DIR djo, djn;
;;;3726   	BYTE buf[21], *dir;
;;;3727   	DWORD dw;
;;;3728   	DEFINE_NAMEBUF;
;;;3729   
;;;3730   
;;;3731   	/* Get logical drive number of the source object */
;;;3732   	res = find_volume(&djo.fs, &path_old, 1);
000004  2201              MOVS     r2,#1
000006  a919              ADD      r1,sp,#0x64
000008  a80e              ADD      r0,sp,#0x38
00000a  f7fffffe          BL       find_volume
;;;3733   	if (res == FR_OK) {
00000e  2800              CMP      r0,#0
000010  d157              BNE      |L26.194|
;;;3734   		djn.fs = djo.fs;
000012  980e              LDR      r0,[sp,#0x38]
;;;3735   		INIT_BUF(djo);
000014  9001              STR      r0,[sp,#4]
000016  a815              ADD      r0,sp,#0x54
;;;3736   		res = follow_path(&djo, path_old);		/* Check old object */
000018  9014              STR      r0,[sp,#0x50]
00001a  a80e              ADD      r0,sp,#0x38
00001c  9919              LDR      r1,[sp,#0x64]
00001e  f7fffffe          BL       follow_path
;;;3737   		if (_FS_RPATH && res == FR_OK && (djo.fn[NSFLAG] & NS_DOT))
;;;3738   			res = FR_INVALID_NAME;
;;;3739   #if _FS_LOCK
;;;3740   		if (res == FR_OK) res = chk_lock(&djo, 2);
;;;3741   #endif
;;;3742   		if (res == FR_OK) {						/* Old object is found */
000022  2800              CMP      r0,#0
000024  d14d              BNE      |L26.194|
;;;3743   			if (!djo.dir) {						/* Is root dir? */
000026  9813              LDR      r0,[sp,#0x4c]
000028  b3f0              CBZ      r0,|L26.168|
;;;3744   				res = FR_NO_FILE;
;;;3745   			} else {
;;;3746   				mem_cpy(buf, djo.dir + DIR_Attr, 21);	/* Save information about object except name */
00002a  f100010b          ADD      r1,r0,#0xb
00002e  2215              MOVS     r2,#0x15
000030  a808              ADD      r0,sp,#0x20
000032  f7fffffe          BL       mem_cpy
;;;3747   				mem_cpy(&djn, &djo, sizeof (DIR));		/* Duplicate the directory object */
000036  221c              MOVS     r2,#0x1c
000038  a90e              ADD      r1,sp,#0x38
00003a  a801              ADD      r0,sp,#4
00003c  f7fffffe          BL       mem_cpy
;;;3748   				if (get_ldnumber(&path_new) >= 0)		/* Snip drive number off and ignore it */
000040  a81a              ADD      r0,sp,#0x68
000042  f7fffffe          BL       get_ldnumber
000046  2800              CMP      r0,#0
000048  db3d              BLT      |L26.198|
;;;3749   					res = follow_path(&djn, path_new);	/* and make sure if new object name is not conflicting */
00004a  a801              ADD      r0,sp,#4
00004c  991a              LDR      r1,[sp,#0x68]
00004e  f7fffffe          BL       follow_path
000052  b350              CBZ      r0,|L26.170|
;;;3750   				else
;;;3751   					res = FR_INVALID_DRIVE;
;;;3752   				if (res == FR_OK) res = FR_EXIST;		/* The new object name is already existing */
;;;3753   				if (res == FR_NO_FILE) { 				/* It is a valid path and no name collision */
000054  2804              CMP      r0,#4
000056  d134              BNE      |L26.194|
;;;3754   					res = dir_register(&djn);			/* Register the new entry */
000058  a801              ADD      r0,sp,#4
00005a  f7fffffe          BL       dir_register
;;;3755   					if (res == FR_OK) {
00005e  2800              CMP      r0,#0
000060  d12f              BNE      |L26.194|
;;;3756   /* Start of critical section where any interruption can cause a cross-link */
;;;3757   						dir = djn.dir;					/* Copy information about object except name */
;;;3758   						mem_cpy(dir + 13, buf + 2, 19);
000062  9c06              LDR      r4,[sp,#0x18]
000064  2213              MOVS     r2,#0x13
000066  f10d0122          ADD      r1,sp,#0x22
00006a  f104000d          ADD      r0,r4,#0xd
00006e  f7fffffe          BL       mem_cpy
;;;3759   						dir[DIR_Attr] = buf[0] | AM_ARC;
000072  f89d0020          LDRB     r0,[sp,#0x20]
;;;3760   						djo.fs->wflag = 1;
000076  2501              MOVS     r5,#1
000078  f0400020          ORR      r0,r0,#0x20           ;3759
00007c  72e0              STRB     r0,[r4,#0xb]          ;3759
00007e  980e              LDR      r0,[sp,#0x38]
000080  7105              STRB     r5,[r0,#4]
;;;3761   						if ((dir[DIR_Attr] & AM_DIR) && djo.sclust != djn.sclust) {	/* Update .. entry in the sub-directory if needed */
000082  7ae0              LDRB     r0,[r4,#0xb]
000084  06c0              LSLS     r0,r0,#27
000086  d52a              BPL      |L26.222|
000088  9903              LDR      r1,[sp,#0xc]
00008a  9810              LDR      r0,[sp,#0x40]
00008c  4288              CMP      r0,r1
00008e  d026              BEQ      |L26.222|
;;;3762   							dw = clust2sect(djo.fs, ld_clust(djo.fs, dir));
000090  4621              MOV      r1,r4
000092  980e              LDR      r0,[sp,#0x38]
000094  f7fffffe          BL       ld_clust
000098  4601              MOV      r1,r0
00009a  980e              LDR      r0,[sp,#0x38]
00009c  f7fffffe          BL       clust2sect
0000a0  0001              MOVS     r1,r0
;;;3763   							if (!dw) {
0000a2  d014              BEQ      |L26.206|
;;;3764   								res = FR_INT_ERR;
;;;3765   							} else {
;;;3766   								res = move_window(djo.fs, dw);
0000a4  980e              LDR      r0,[sp,#0x38]
0000a6  e001              B        |L26.172|
                  |L26.168|
0000a8  e00a              B        |L26.192|
                  |L26.170|
0000aa  e00e              B        |L26.202|
                  |L26.172|
0000ac  f7fffffe          BL       move_window
;;;3767   								dir = djo.fs->win + SZ_DIRE * 1;	/* Ptr to .. entry */
0000b0  9a0e              LDR      r2,[sp,#0x38]
0000b2  3250              ADDS     r2,r2,#0x50
;;;3768   								if (res == FR_OK && dir[1] == '.') {
0000b4  2800              CMP      r0,#0
0000b6  d104              BNE      |L26.194|
0000b8  7850              LDRB     r0,[r2,#1]
0000ba  282e              CMP      r0,#0x2e
0000bc  d009              BEQ      |L26.210|
0000be  e00e              B        |L26.222|
                  |L26.192|
0000c0  2004              MOVS     r0,#4                 ;3744
                  |L26.194|
;;;3769   									st_clust(dir, djn.sclust);
;;;3770   									djo.fs->wflag = 1;
;;;3771   								}
;;;3772   							}
;;;3773   						}
;;;3774   						if (res == FR_OK) {
;;;3775   							res = dir_remove(&djo);		/* Remove old entry */
;;;3776   							if (res == FR_OK)
;;;3777   								res = sync_fs(djo.fs);
;;;3778   						}
;;;3779   /* End of critical section */
;;;3780   					}
;;;3781   				}
;;;3782   			}
;;;3783   		}
;;;3784   		FREE_BUF();
;;;3785   	}
;;;3786   
;;;3787   	LEAVE_FF(djo.fs, res);
;;;3788   }
0000c2  b01b              ADD      sp,sp,#0x6c
0000c4  bd30              POP      {r4,r5,pc}
                  |L26.198|
0000c6  200b              MOVS     r0,#0xb               ;3751
0000c8  e7fb              B        |L26.194|
                  |L26.202|
0000ca  2008              MOVS     r0,#8                 ;3752
0000cc  e7f9              B        |L26.194|
                  |L26.206|
0000ce  2002              MOVS     r0,#2                 ;3764
0000d0  e7f7              B        |L26.194|
                  |L26.210|
0000d2  4610              MOV      r0,r2                 ;3769
0000d4  9903              LDR      r1,[sp,#0xc]          ;3769
0000d6  f7fffffe          BL       st_clust
0000da  980e              LDR      r0,[sp,#0x38]         ;3770
0000dc  7105              STRB     r5,[r0,#4]            ;3770
                  |L26.222|
0000de  a80e              ADD      r0,sp,#0x38           ;3775
0000e0  f7fffffe          BL       dir_remove
0000e4  2800              CMP      r0,#0                 ;3776
0000e6  d1ec              BNE      |L26.194|
0000e8  980e              LDR      r0,[sp,#0x38]         ;3777
0000ea  f7fffffe          BL       sync_fs
0000ee  e7e8              B        |L26.194|
;;;3789   
                          ENDP


                          AREA ||i.f_stat||, CODE, READONLY, ALIGN=1

                  f_stat PROC
;;;3376   
;;;3377   FRESULT f_stat (
000000  b533              PUSH     {r0,r1,r4,r5,lr}
;;;3378   	const TCHAR* path,	/* Pointer to the file path */
;;;3379   	FILINFO* fno		/* Pointer to file information to return */
;;;3380   )
;;;3381   {
000002  b08b              SUB      sp,sp,#0x2c
000004  460d              MOV      r5,r1
;;;3382   	FRESULT res;
;;;3383   	DIR dj;
;;;3384   	DEFINE_NAMEBUF;
;;;3385   
;;;3386   
;;;3387   	/* Get logical drive number */
;;;3388   	res = find_volume(&dj.fs, &path, 0);
000006  2200              MOVS     r2,#0
000008  a90b              ADD      r1,sp,#0x2c
00000a  4668              MOV      r0,sp
00000c  f7fffffe          BL       find_volume
000010  0004              MOVS     r4,r0
;;;3389   	if (res == FR_OK) {
000012  d110              BNE      |L27.54|
;;;3390   		INIT_BUF(dj);
000014  a807              ADD      r0,sp,#0x1c
;;;3391   		res = follow_path(&dj, path);	/* Follow the file path */
000016  9006              STR      r0,[sp,#0x18]
000018  4668              MOV      r0,sp
00001a  990b              LDR      r1,[sp,#0x2c]
00001c  f7fffffe          BL       follow_path
000020  0004              MOVS     r4,r0
;;;3392   		if (res == FR_OK) {				/* Follow completed */
000022  d108              BNE      |L27.54|
;;;3393   			if (dj.dir) {		/* Found an object */
000024  9805              LDR      r0,[sp,#0x14]
000026  b128              CBZ      r0,|L27.52|
;;;3394   				if (fno) get_fileinfo(&dj, fno);
000028  b12d              CBZ      r5,|L27.54|
00002a  4629              MOV      r1,r5
00002c  4668              MOV      r0,sp
00002e  f7fffffe          BL       get_fileinfo
000032  e000              B        |L27.54|
                  |L27.52|
;;;3395   			} else {			/* It is root directory */
;;;3396   				res = FR_INVALID_NAME;
000034  2406              MOVS     r4,#6
                  |L27.54|
;;;3397   			}
;;;3398   		}
;;;3399   		FREE_BUF();
;;;3400   	}
;;;3401   
;;;3402   	LEAVE_FF(dj.fs, res);
;;;3403   }
000036  b00d              ADD      sp,sp,#0x34
000038  4620              MOV      r0,r4                 ;3402
00003a  bd30              POP      {r4,r5,pc}
;;;3404   
                          ENDP


                          AREA ||i.f_sync||, CODE, READONLY, ALIGN=1

                  f_sync PROC
;;;2816   
;;;2817   FRESULT f_sync (
000000  b570              PUSH     {r4-r6,lr}
;;;2818   	FIL* fp		/* Pointer to the file object */
;;;2819   )
;;;2820   {
000002  4604              MOV      r4,r0
;;;2821   	FRESULT res;
;;;2822   	DWORD tm;
;;;2823   	BYTE *dir;
;;;2824   
;;;2825   
;;;2826   	res = validate(fp);					/* Check validity of the object */
000004  f7fffffe          BL       validate
;;;2827   	if (res == FR_OK) {
000008  2800              CMP      r0,#0
00000a  d10e              BNE      |L28.42|
;;;2828   		if (fp->flag & FA__WRITTEN) {	/* Is there any change to the file? */
00000c  79a1              LDRB     r1,[r4,#6]
00000e  068a              LSLS     r2,r1,#26
000010  d50b              BPL      |L28.42|
;;;2829   #if !_FS_TINY
;;;2830   			if (fp->flag & FA__DIRTY) {	/* Write-back cached data if needed */
000012  0648              LSLS     r0,r1,#25
000014  d50e              BPL      |L28.52|
;;;2831   				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
000016  6820              LDR      r0,[r4,#0]
000018  2301              MOVS     r3,#1
00001a  f1040124          ADD      r1,r4,#0x24
00001e  7840              LDRB     r0,[r0,#1]
000020  69a2              LDR      r2,[r4,#0x18]
000022  f7fffffe          BL       disk_write
000026  b108              CBZ      r0,|L28.44|
;;;2832   					LEAVE_FF(fp->fs, FR_DISK_ERR);
000028  2001              MOVS     r0,#1
                  |L28.42|
;;;2833   				fp->flag &= ~FA__DIRTY;
;;;2834   			}
;;;2835   #endif
;;;2836   			/* Update the directory entry */
;;;2837   			res = move_window(fp->fs, fp->dir_sect);
;;;2838   			if (res == FR_OK) {
;;;2839   				dir = fp->dir_ptr;
;;;2840   				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
;;;2841   				ST_DWORD(dir + DIR_FileSize, fp->fsize);	/* Update file size */
;;;2842   				st_clust(dir, fp->sclust);					/* Update start cluster */
;;;2843   				tm = GET_FATTIME();							/* Update modified time */
;;;2844   				ST_DWORD(dir + DIR_WrtTime, tm);
;;;2845   				ST_WORD(dir + DIR_LstAccDate, 0);
;;;2846   				fp->flag &= ~FA__WRITTEN;
;;;2847   				fp->fs->wflag = 1;
;;;2848   				res = sync_fs(fp->fs);
;;;2849   			}
;;;2850   		}
;;;2851   	}
;;;2852   
;;;2853   	LEAVE_FF(fp->fs, res);
;;;2854   }
00002a  bd70              POP      {r4-r6,pc}
                  |L28.44|
00002c  79a0              LDRB     r0,[r4,#6]            ;2833
00002e  f0200040          BIC      r0,r0,#0x40           ;2833
000032  71a0              STRB     r0,[r4,#6]            ;2833
                  |L28.52|
000034  69e1              LDR      r1,[r4,#0x1c]         ;2837
000036  6820              LDR      r0,[r4,#0]            ;2837
000038  f7fffffe          BL       move_window
00003c  2800              CMP      r0,#0                 ;2838
00003e  d1f4              BNE      |L28.42|
000040  6a25              LDR      r5,[r4,#0x20]         ;2840
000042  7ae8              LDRB     r0,[r5,#0xb]          ;2840
000044  f0400020          ORR      r0,r0,#0x20           ;2840
000048  72e8              STRB     r0,[r5,#0xb]          ;2840
00004a  7b20              LDRB     r0,[r4,#0xc]          ;2841
00004c  7728              STRB     r0,[r5,#0x1c]         ;2841
00004e  89a0              LDRH     r0,[r4,#0xc]          ;2841
000050  0a00              LSRS     r0,r0,#8              ;2841
000052  7768              STRB     r0,[r5,#0x1d]         ;2841
000054  68e0              LDR      r0,[r4,#0xc]          ;2841
000056  0c00              LSRS     r0,r0,#16             ;2841
000058  77a8              STRB     r0,[r5,#0x1e]         ;2841
00005a  68e0              LDR      r0,[r4,#0xc]          ;2841
00005c  0e00              LSRS     r0,r0,#24             ;2841
00005e  77e8              STRB     r0,[r5,#0x1f]         ;2841
000060  4628              MOV      r0,r5                 ;2842
000062  6921              LDR      r1,[r4,#0x10]         ;2842
000064  f7fffffe          BL       st_clust
000068  f7fffffe          BL       get_fattime
00006c  75a8              STRB     r0,[r5,#0x16]         ;2844
00006e  0a01              LSRS     r1,r0,#8              ;2844
000070  75e9              STRB     r1,[r5,#0x17]         ;2844
000072  0c01              LSRS     r1,r0,#16             ;2844
000074  7629              STRB     r1,[r5,#0x18]         ;2844
000076  0e00              LSRS     r0,r0,#24             ;2844
000078  7668              STRB     r0,[r5,#0x19]         ;2844
00007a  2000              MOVS     r0,#0                 ;2845
00007c  74a8              STRB     r0,[r5,#0x12]         ;2845
00007e  74e8              STRB     r0,[r5,#0x13]         ;2845
000080  79a0              LDRB     r0,[r4,#6]            ;2846
000082  f0200020          BIC      r0,r0,#0x20           ;2846
000086  71a0              STRB     r0,[r4,#6]            ;2846
000088  6821              LDR      r1,[r4,#0]            ;2847
00008a  2001              MOVS     r0,#1                 ;2847
00008c  7108              STRB     r0,[r1,#4]            ;2847
00008e  6820              LDR      r0,[r4,#0]            ;2848
000090  e8bd4070          POP      {r4-r6,lr}            ;2848
000094  f7ffbffe          B.W      sync_fs
;;;2855   
                          ENDP


                          AREA ||i.f_truncate||, CODE, READONLY, ALIGN=1

                  f_truncate PROC
;;;3477   
;;;3478   FRESULT f_truncate (
000000  b570              PUSH     {r4-r6,lr}
;;;3479   	FIL* fp		/* Pointer to the file object */
;;;3480   )
;;;3481   {
000002  4604              MOV      r4,r0
;;;3482   	FRESULT res;
;;;3483   	DWORD ncl;
;;;3484   
;;;3485   
;;;3486   	res = validate(fp);						/* Check validity of the object */
000004  f7fffffe          BL       validate
000008  0005              MOVS     r5,r0
;;;3487   	if (res == FR_OK) {
00000a  d13d              BNE      |L29.136|
;;;3488   		if (fp->err) {						/* Check error */
00000c  79e0              LDRB     r0,[r4,#7]
00000e  b118              CBZ      r0,|L29.24|
;;;3489   			res = (FRESULT)fp->err;
000010  4605              MOV      r5,r0
;;;3490   		} else {
;;;3491   			if (!(fp->flag & FA_WRITE))		/* Check access mode */
;;;3492   				res = FR_DENIED;
;;;3493   		}
;;;3494   	}
;;;3495   	if (res == FR_OK) {
000012  0028              MOVS     r0,r5
000014  d005              BEQ      |L29.34|
000016  e037              B        |L29.136|
                  |L29.24|
000018  79a0              LDRB     r0,[r4,#6]            ;3491
00001a  0780              LSLS     r0,r0,#30             ;3491
00001c  d401              BMI      |L29.34|
00001e  2507              MOVS     r5,#7                 ;3492
000020  e032              B        |L29.136|
                  |L29.34|
000022  e9d40102          LDRD     r0,r1,[r4,#8]         ;3492
;;;3496   		if (fp->fsize > fp->fptr) {
000026  4281              CMP      r1,r0
000028  d92e              BLS      |L29.136|
;;;3497   			fp->fsize = fp->fptr;	/* Set file size to current R/W point */
;;;3498   			fp->flag |= FA__WRITTEN;
00002a  60e0              STR      r0,[r4,#0xc]
00002c  79a1              LDRB     r1,[r4,#6]
00002e  f0410120          ORR      r1,r1,#0x20
000032  71a1              STRB     r1,[r4,#6]
;;;3499   			if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
000034  b150              CBZ      r0,|L29.76|
;;;3500   				res = remove_chain(fp->fs, fp->sclust);
;;;3501   				fp->sclust = 0;
;;;3502   			} else {				/* When truncate a part of the file, remove remaining clusters */
;;;3503   				ncl = get_fat(fp->fs, fp->clust);
000036  6961              LDR      r1,[r4,#0x14]
000038  6820              LDR      r0,[r4,#0]
00003a  f7fffffe          BL       get_fat
00003e  4606              MOV      r6,r0
;;;3504   				res = FR_OK;
;;;3505   				if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
000040  1c40              ADDS     r0,r0,#1
000042  d00b              BEQ      |L29.92|
;;;3506   				if (ncl == 1) res = FR_INT_ERR;
000044  2e01              CMP      r6,#1
000046  d00b              BEQ      |L29.96|
;;;3507   				if (res == FR_OK && ncl < fp->fs->n_fatent) {
000048  b165              CBZ      r5,|L29.100|
00004a  e01c              B        |L29.134|
                  |L29.76|
00004c  6921              LDR      r1,[r4,#0x10]         ;3500
00004e  6820              LDR      r0,[r4,#0]            ;3500
000050  f7fffffe          BL       remove_chain
000054  4605              MOV      r5,r0                 ;3500
000056  2000              MOVS     r0,#0                 ;3501
000058  6120              STR      r0,[r4,#0x10]         ;3501
00005a  e013              B        |L29.132|
                  |L29.92|
00005c  2501              MOVS     r5,#1                 ;3505
00005e  e012              B        |L29.134|
                  |L29.96|
000060  2502              MOVS     r5,#2                 ;3506
000062  e010              B        |L29.134|
                  |L29.100|
000064  6820              LDR      r0,[r4,#0]
000066  6941              LDR      r1,[r0,#0x14]
000068  42b1              CMP      r1,r6
00006a  d90f              BLS      |L29.140|
;;;3508   					res = put_fat(fp->fs, fp->clust, 0x0FFFFFFF);
00006c  f06f4270          MVN      r2,#0xf0000000
000070  6961              LDR      r1,[r4,#0x14]
000072  f7fffffe          BL       put_fat
000076  0005              MOVS     r5,r0
;;;3509   					if (res == FR_OK) res = remove_chain(fp->fs, ncl);
000078  d105              BNE      |L29.134|
00007a  4631              MOV      r1,r6
00007c  6820              LDR      r0,[r4,#0]
00007e  f7fffffe          BL       remove_chain
000082  4605              MOV      r5,r0
                  |L29.132|
;;;3510   				}
;;;3511   			}
;;;3512   #if !_FS_TINY
;;;3513   			if (res == FR_OK && (fp->flag & FA__DIRTY)) {
000084  b115              CBZ      r5,|L29.140|
                  |L29.134|
;;;3514   				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
;;;3515   					res = FR_DISK_ERR;
;;;3516   				else
;;;3517   					fp->flag &= ~FA__DIRTY;
;;;3518   			}
;;;3519   #endif
;;;3520   		}
;;;3521   		if (res != FR_OK) fp->err = (FRESULT)res;
000086  71e5              STRB     r5,[r4,#7]
                  |L29.136|
;;;3522   	}
;;;3523   
;;;3524   	LEAVE_FF(fp->fs, res);
000088  4628              MOV      r0,r5
;;;3525   }
00008a  bd70              POP      {r4-r6,pc}
                  |L29.140|
00008c  79a0              LDRB     r0,[r4,#6]            ;3513
00008e  0640              LSLS     r0,r0,#25             ;3513
000090  d5fa              BPL      |L29.136|
000092  6820              LDR      r0,[r4,#0]            ;3514
000094  2301              MOVS     r3,#1                 ;3514
000096  f1040124          ADD      r1,r4,#0x24           ;3514
00009a  7840              LDRB     r0,[r0,#1]            ;3514
00009c  69a2              LDR      r2,[r4,#0x18]         ;3514
00009e  f7fffffe          BL       disk_write
0000a2  2800              CMP      r0,#0                 ;3514
0000a4  d1da              BNE      |L29.92|
0000a6  79a0              LDRB     r0,[r4,#6]            ;3517
0000a8  f0200040          BIC      r0,r0,#0x40           ;3517
0000ac  71a0              STRB     r0,[r4,#6]            ;3517
0000ae  e7eb              B        |L29.136|
;;;3526   
                          ENDP


                          AREA ||i.f_unlink||, CODE, READONLY, ALIGN=1

                  f_unlink PROC
;;;3533   
;;;3534   FRESULT f_unlink (
000000  b531              PUSH     {r0,r4,r5,lr}
;;;3535   	const TCHAR* path		/* Pointer to the file or directory path */
;;;3536   )
;;;3537   {
000002  b092              SUB      sp,sp,#0x48
;;;3538   	FRESULT res;
;;;3539   	DIR dj, sdj;
;;;3540   	BYTE *dir;
;;;3541   	DWORD dclst = 0;
;;;3542   	DEFINE_NAMEBUF;
;;;3543   
;;;3544   
;;;3545   	/* Get logical drive number */
;;;3546   	res = find_volume(&dj.fs, &path, 1);
000004  2201              MOVS     r2,#1
000006  a912              ADD      r1,sp,#0x48
000008  4668              MOV      r0,sp
00000a  f7fffffe          BL       find_volume
;;;3547   	if (res == FR_OK) {
00000e  2800              CMP      r0,#0
000010  d10d              BNE      |L30.46|
;;;3548   		INIT_BUF(dj);
000012  a80e              ADD      r0,sp,#0x38
;;;3549   		res = follow_path(&dj, path);		/* Follow the file path */
000014  9006              STR      r0,[sp,#0x18]
000016  4668              MOV      r0,sp
000018  9912              LDR      r1,[sp,#0x48]
00001a  f7fffffe          BL       follow_path
;;;3550   		if (_FS_RPATH && res == FR_OK && (dj.fn[NSFLAG] & NS_DOT))
;;;3551   			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
;;;3552   #if _FS_LOCK
;;;3553   		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Cannot remove open object */
;;;3554   #endif
;;;3555   		if (res == FR_OK) {					/* The object is accessible */
00001e  2800              CMP      r0,#0
000020  d105              BNE      |L30.46|
;;;3556   			dir = dj.dir;
;;;3557   			if (!dir) {
000022  9d05              LDR      r5,[sp,#0x14]
000024  b12d              CBZ      r5,|L30.50|
;;;3558   				res = FR_INVALID_NAME;		/* Cannot remove the origin directory */
;;;3559   			} else {
;;;3560   				if (dir[DIR_Attr] & AM_RDO)
000026  7ae8              LDRB     r0,[r5,#0xb]
000028  07c0              LSLS     r0,r0,#31
00002a  d004              BEQ      |L30.54|
                  |L30.44|
;;;3561   					res = FR_DENIED;		/* Cannot remove R/O object */
00002c  2007              MOVS     r0,#7
                  |L30.46|
;;;3562   			}
;;;3563   			if (res == FR_OK) {
;;;3564   				dclst = ld_clust(dj.fs, dir);
;;;3565   				if (dclst && (dir[DIR_Attr] & AM_DIR)) {	/* Is it a sub-directory ? */
;;;3566   #if _FS_RPATH
;;;3567   					if (dclst == dj.fs->cdir) {		 		/* Is it the current directory? */
;;;3568   						res = FR_DENIED;
;;;3569   					} else
;;;3570   #endif
;;;3571   					{
;;;3572   						mem_cpy(&sdj, &dj, sizeof (DIR));	/* Open the sub-directory */
;;;3573   						sdj.sclust = dclst;
;;;3574   						res = dir_sdi(&sdj, 2);
;;;3575   						if (res == FR_OK) {
;;;3576   							res = dir_read(&sdj, 0);			/* Read an item (excluding dot entries) */
;;;3577   							if (res == FR_OK) res = FR_DENIED;	/* Not empty? (cannot remove) */
;;;3578   							if (res == FR_NO_FILE) res = FR_OK;	/* Empty? (can remove) */
;;;3579   						}
;;;3580   					}
;;;3581   				}
;;;3582   			}
;;;3583   			if (res == FR_OK) {
;;;3584   				res = dir_remove(&dj);		/* Remove the directory entry */
;;;3585   				if (res == FR_OK && dclst)	/* Remove the cluster chain if exist */
;;;3586   					res = remove_chain(dj.fs, dclst);
;;;3587   				if (res == FR_OK) res = sync_fs(dj.fs);
;;;3588   			}
;;;3589   		}
;;;3590   		FREE_BUF();
;;;3591   	}
;;;3592   
;;;3593   	LEAVE_FF(dj.fs, res);
;;;3594   }
00002e  b013              ADD      sp,sp,#0x4c
000030  bd30              POP      {r4,r5,pc}
                  |L30.50|
000032  2006              MOVS     r0,#6                 ;3558
000034  e7fb              B        |L30.46|
                  |L30.54|
000036  4629              MOV      r1,r5                 ;3564
000038  9800              LDR      r0,[sp,#0]            ;3564
00003a  f7fffffe          BL       ld_clust
00003e  0004              MOVS     r4,r0                 ;3564
000040  d016              BEQ      |L30.112|
000042  7ae8              LDRB     r0,[r5,#0xb]          ;3565
000044  06c0              LSLS     r0,r0,#27             ;3565
000046  d513              BPL      |L30.112|
000048  221c              MOVS     r2,#0x1c              ;3572
00004a  4669              MOV      r1,sp                 ;3572
00004c  a807              ADD      r0,sp,#0x1c           ;3572
00004e  f7fffffe          BL       mem_cpy
000052  2102              MOVS     r1,#2                 ;3574
000054  a807              ADD      r0,sp,#0x1c           ;3574
000056  9409              STR      r4,[sp,#0x24]         ;3574
000058  f7fffffe          BL       dir_sdi
00005c  2800              CMP      r0,#0                 ;3575
00005e  d1e6              BNE      |L30.46|
000060  2100              MOVS     r1,#0                 ;3576
000062  a807              ADD      r0,sp,#0x1c           ;3576
000064  f7fffffe          BL       dir_read
000068  2800              CMP      r0,#0                 ;3577
00006a  d0df              BEQ      |L30.44|
00006c  2804              CMP      r0,#4                 ;3578
00006e  d1de              BNE      |L30.46|
                  |L30.112|
000070  4668              MOV      r0,sp                 ;3584
000072  f7fffffe          BL       dir_remove
000076  2800              CMP      r0,#0                 ;3585
000078  d1d9              BNE      |L30.46|
00007a  b12c              CBZ      r4,|L30.136|
00007c  4621              MOV      r1,r4                 ;3586
00007e  9800              LDR      r0,[sp,#0]            ;3586
000080  f7fffffe          BL       remove_chain
000084  2800              CMP      r0,#0                 ;3586
000086  d1d2              BNE      |L30.46|
                  |L30.136|
000088  9800              LDR      r0,[sp,#0]            ;3587
00008a  f7fffffe          BL       sync_fs
00008e  e7ce              B        |L30.46|
;;;3595   
                          ENDP


                          AREA ||i.f_utime||, CODE, READONLY, ALIGN=1

                  f_utime PROC
;;;3796   
;;;3797   FRESULT f_utime (
000000  b513              PUSH     {r0,r1,r4,lr}
;;;3798   	const TCHAR* path,	/* Pointer to the file/directory name */
;;;3799   	const FILINFO* fno	/* Pointer to the time stamp to be set */
;;;3800   )
;;;3801   {
000002  b08a              SUB      sp,sp,#0x28
000004  460c              MOV      r4,r1
;;;3802   	FRESULT res;
;;;3803   	DIR dj;
;;;3804   	BYTE *dir;
;;;3805   	DEFINE_NAMEBUF;
;;;3806   
;;;3807   
;;;3808   	/* Get logical drive number */
;;;3809   	res = find_volume(&dj.fs, &path, 1);
000006  2201              MOVS     r2,#1
000008  a90a              ADD      r1,sp,#0x28
00000a  4668              MOV      r0,sp
00000c  f7fffffe          BL       find_volume
;;;3810   	if (res == FR_OK) {
000010  2800              CMP      r0,#0
000012  d119              BNE      |L31.72|
;;;3811   		INIT_BUF(dj);
000014  a807              ADD      r0,sp,#0x1c
;;;3812   		res = follow_path(&dj, path);	/* Follow the file path */
000016  9006              STR      r0,[sp,#0x18]
000018  4668              MOV      r0,sp
00001a  990a              LDR      r1,[sp,#0x28]
00001c  f7fffffe          BL       follow_path
;;;3813   		FREE_BUF();
;;;3814   		if (_FS_RPATH && res == FR_OK && (dj.fn[NSFLAG] & NS_DOT))
;;;3815   			res = FR_INVALID_NAME;
;;;3816   		if (res == FR_OK) {
000020  2800              CMP      r0,#0
000022  d111              BNE      |L31.72|
;;;3817   			dir = dj.dir;
;;;3818   			if (!dir) {					/* Root directory */
000024  9805              LDR      r0,[sp,#0x14]
000026  b188              CBZ      r0,|L31.76|
;;;3819   				res = FR_INVALID_NAME;
;;;3820   			} else {					/* File or sub-directory */
;;;3821   				ST_WORD(dir + DIR_WrtTime, fno->ftime);
000028  79a1              LDRB     r1,[r4,#6]
00002a  7581              STRB     r1,[r0,#0x16]
00002c  88e1              LDRH     r1,[r4,#6]
00002e  0a09              LSRS     r1,r1,#8
000030  75c1              STRB     r1,[r0,#0x17]
;;;3822   				ST_WORD(dir + DIR_WrtDate, fno->fdate);
000032  7921              LDRB     r1,[r4,#4]
000034  7601              STRB     r1,[r0,#0x18]
000036  88a1              LDRH     r1,[r4,#4]
000038  0a09              LSRS     r1,r1,#8
00003a  7641              STRB     r1,[r0,#0x19]
;;;3823   				dj.fs->wflag = 1;
00003c  9900              LDR      r1,[sp,#0]
00003e  2001              MOVS     r0,#1
000040  7108              STRB     r0,[r1,#4]
;;;3824   				res = sync_fs(dj.fs);
000042  9800              LDR      r0,[sp,#0]
000044  f7fffffe          BL       sync_fs
                  |L31.72|
;;;3825   			}
;;;3826   		}
;;;3827   	}
;;;3828   
;;;3829   	LEAVE_FF(dj.fs, res);
;;;3830   }
000048  b00c              ADD      sp,sp,#0x30
00004a  bd10              POP      {r4,pc}
                  |L31.76|
00004c  2006              MOVS     r0,#6                 ;3819
00004e  e7fb              B        |L31.72|
;;;3831   
                          ENDP


                          AREA ||i.f_write||, CODE, READONLY, ALIGN=1

                  f_write PROC
;;;2694   
;;;2695   FRESULT f_write (
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;2696   	FIL* fp,			/* Pointer to the file object */
;;;2697   	const void *buff,	/* Pointer to the data to be written */
;;;2698   	UINT btw,			/* Number of bytes to write */
;;;2699   	UINT* bw			/* Pointer to number of bytes written */
;;;2700   )
;;;2701   {
;;;2702   	FRESULT res;
;;;2703   	DWORD clst, sect;
;;;2704   	UINT wcnt, cc;
;;;2705   	const BYTE *wbuff = (const BYTE*)buff;
000004  4688              MOV      r8,r1
;;;2706   	BYTE csect;
;;;2707   
;;;2708   
;;;2709   	*bw = 0;	/* Clear write byte counter */
000006  2100              MOVS     r1,#0
000008  4699              MOV      r9,r3                 ;2701
00000a  4615              MOV      r5,r2                 ;2701
00000c  4604              MOV      r4,r0                 ;2701
;;;2710   
;;;2711   	res = validate(fp);						/* Check validity */
00000e  6019              STR      r1,[r3,#0]
000010  f7fffffe          BL       validate
;;;2712   	if (res != FR_OK) LEAVE_FF(fp->fs, res);
000014  2800              CMP      r0,#0
000016  d106              BNE      |L32.38|
;;;2713   	if (fp->err)							/* Check error */
000018  79e0              LDRB     r0,[r4,#7]
00001a  2800              CMP      r0,#0
00001c  d103              BNE      |L32.38|
;;;2714   		LEAVE_FF(fp->fs, (FRESULT)fp->err);
;;;2715   	if (!(fp->flag & FA_WRITE))				/* Check access mode */
00001e  79a0              LDRB     r0,[r4,#6]
000020  0780              LSLS     r0,r0,#30
000022  d402              BMI      |L32.42|
;;;2716   		LEAVE_FF(fp->fs, FR_DENIED);
000024  2007              MOVS     r0,#7
                  |L32.38|
;;;2717   	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */
;;;2718   
;;;2719   	for ( ;  btw;							/* Repeat until all data written */
;;;2720   		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
;;;2721   		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
;;;2722   			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
;;;2723   			if (!csect) {					/* On the cluster boundary? */
;;;2724   				if (fp->fptr == 0) {		/* On the top of the file? */
;;;2725   					clst = fp->sclust;		/* Follow from the origin */
;;;2726   					if (clst == 0)			/* When no cluster is allocated, */
;;;2727   						clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
;;;2728   				} else {					/* Middle or end of the file */
;;;2729   #if _USE_FASTSEEK
;;;2730   					if (fp->cltbl)
;;;2731   						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
;;;2732   					else
;;;2733   #endif
;;;2734   						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
;;;2735   				}
;;;2736   				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
;;;2737   				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
;;;2738   				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
;;;2739   				fp->clust = clst;			/* Update current cluster */
;;;2740   				if (fp->sclust == 0) fp->sclust = clst;	/* Set start cluster if the first write */
;;;2741   			}
;;;2742   #if _FS_TINY
;;;2743   			if (fp->fs->winsect == fp->dsect && sync_window(fp->fs))	/* Write-back sector cache */
;;;2744   				ABORT(fp->fs, FR_DISK_ERR);
;;;2745   #else
;;;2746   			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
;;;2747   				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
;;;2748   					ABORT(fp->fs, FR_DISK_ERR);
;;;2749   				fp->flag &= ~FA__DIRTY;
;;;2750   			}
;;;2751   #endif
;;;2752   			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
;;;2753   			if (!sect) ABORT(fp->fs, FR_INT_ERR);
;;;2754   			sect += csect;
;;;2755   			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
;;;2756   			if (cc) {						/* Write maximum contiguous sectors directly */
;;;2757   				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
;;;2758   					cc = fp->fs->csize - csect;
;;;2759   				if (disk_write(fp->fs->drv, wbuff, sect, cc) != RES_OK)
;;;2760   					ABORT(fp->fs, FR_DISK_ERR);
;;;2761   #if _FS_MINIMIZE <= 2
;;;2762   #if _FS_TINY
;;;2763   				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
;;;2764   					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
;;;2765   					fp->fs->wflag = 0;
;;;2766   				}
;;;2767   #else
;;;2768   				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
;;;2769   					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
;;;2770   					fp->flag &= ~FA__DIRTY;
;;;2771   				}
;;;2772   #endif
;;;2773   #endif
;;;2774   				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
;;;2775   				continue;
;;;2776   			}
;;;2777   #if _FS_TINY
;;;2778   			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
;;;2779   				if (sync_window(fp->fs)) ABORT(fp->fs, FR_DISK_ERR);
;;;2780   				fp->fs->winsect = sect;
;;;2781   			}
;;;2782   #else
;;;2783   			if (fp->dsect != sect) {		/* Fill sector cache with file data */
;;;2784   				if (fp->fptr < fp->fsize &&
;;;2785   					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
;;;2786   						ABORT(fp->fs, FR_DISK_ERR);
;;;2787   			}
;;;2788   #endif
;;;2789   			fp->dsect = sect;
;;;2790   		}
;;;2791   		wcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
;;;2792   		if (wcnt > btw) wcnt = btw;
;;;2793   #if _FS_TINY
;;;2794   		if (move_window(fp->fs, fp->dsect) != FR_OK)	/* Move sector window */
;;;2795   			ABORT(fp->fs, FR_DISK_ERR);
;;;2796   		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
;;;2797   		fp->fs->wflag = 1;
;;;2798   #else
;;;2799   		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
;;;2800   		fp->flag |= FA__DIRTY;
;;;2801   #endif
;;;2802   	}
;;;2803   
;;;2804   	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
;;;2805   	fp->flag |= FA__WRITTEN;						/* Set file change flag */
;;;2806   
;;;2807   	LEAVE_FF(fp->fs, FR_OK);
;;;2808   }
000026  e8bd9ffc          POP      {r2-r12,pc}
                  |L32.42|
00002a  68a0              LDR      r0,[r4,#8]            ;2717
00002c  2701              MOVS     r7,#1                 ;2703
00002e  1942              ADDS     r2,r0,r5              ;2717
000030  f04f0a02          MOV      r10,#2                ;2737
000034  f1040b24          ADD      r11,r4,#0x24          ;2747
000038  4282              CMP      r2,r0                 ;2717
00003a  d372              BCC      |L32.290|
00003c  e091              B        |L32.354|
                  |L32.62|
00003e  68a0              LDR      r0,[r4,#8]            ;2721
000040  05c1              LSLS     r1,r0,#23             ;2721
000042  d172              BNE      |L32.298|
000044  6822              LDR      r2,[r4,#0]            ;2722
000046  7891              LDRB     r1,[r2,#2]            ;2722
000048  1e49              SUBS     r1,r1,#1              ;2722
00004a  ea012150          AND      r1,r1,r0,LSR #9       ;2722
00004e  f01106ff          ANDS     r6,r1,#0xff           ;2722
000052  d112              BNE      |L32.122|
000054  b108              CBZ      r0,|L32.90|
000056  6961              LDR      r1,[r4,#0x14]         ;2734
000058  e002              B        |L32.96|
                  |L32.90|
00005a  6920              LDR      r0,[r4,#0x10]         ;2726
00005c  b928              CBNZ     r0,|L32.106|
00005e  2100              MOVS     r1,#0                 ;2727
                  |L32.96|
000060  4610              MOV      r0,r2                 ;2727
000062  f7fffffe          BL       create_chain
000066  2800              CMP      r0,#0                 ;2736
000068  d07e              BEQ      |L32.360|
                  |L32.106|
00006a  2801              CMP      r0,#1                 ;2737
00006c  d02d              BEQ      |L32.202|
00006e  1c41              ADDS     r1,r0,#1              ;2738
000070  d054              BEQ      |L32.284|
000072  6160              STR      r0,[r4,#0x14]         ;2740
000074  6921              LDR      r1,[r4,#0x10]         ;2740
000076  b901              CBNZ     r1,|L32.122|
000078  6120              STR      r0,[r4,#0x10]         ;2740
                  |L32.122|
00007a  79a0              LDRB     r0,[r4,#6]            ;2746
00007c  0640              LSLS     r0,r0,#25             ;2746
00007e  d50b              BPL      |L32.152|
000080  6820              LDR      r0,[r4,#0]            ;2747
000082  2301              MOVS     r3,#1                 ;2747
000084  4659              MOV      r1,r11                ;2747
000086  7840              LDRB     r0,[r0,#1]            ;2747
000088  69a2              LDR      r2,[r4,#0x18]         ;2747
00008a  f7fffffe          BL       disk_write
00008e  bba0              CBNZ     r0,|L32.250|
000090  79a0              LDRB     r0,[r4,#6]            ;2749
000092  f0200040          BIC      r0,r0,#0x40           ;2749
000096  71a0              STRB     r0,[r4,#6]            ;2749
                  |L32.152|
000098  6961              LDR      r1,[r4,#0x14]         ;2752
00009a  6820              LDR      r0,[r4,#0]            ;2752
00009c  f7fffffe          BL       clust2sect
0000a0  b198              CBZ      r0,|L32.202|
0000a2  4430              ADD      r0,r0,r6              ;2754
0000a4  9001              STR      r0,[sp,#4]            ;2755
0000a6  0a68              LSRS     r0,r5,#9              ;2755
0000a8  9000              STR      r0,[sp,#0]            ;2756
0000aa  d027              BEQ      |L32.252|
0000ac  1832              ADDS     r2,r6,r0              ;2757
0000ae  6820              LDR      r0,[r4,#0]            ;2757
0000b0  7881              LDRB     r1,[r0,#2]            ;2757
0000b2  428a              CMP      r2,r1                 ;2757
0000b4  d901              BLS      |L32.186|
0000b6  1b89              SUBS     r1,r1,r6              ;2758
0000b8  9100              STR      r1,[sp,#0]            ;2758
                  |L32.186|
0000ba  e9dd3200          LDRD     r3,r2,[sp,#0]         ;2759
0000be  7840              LDRB     r0,[r0,#1]            ;2759
0000c0  4641              MOV      r1,r8                 ;2759
0000c2  f7fffffe          BL       disk_write
0000c6  b9c0              CBNZ     r0,|L32.250|
0000c8  e003              B        |L32.210|
                  |L32.202|
0000ca  f884a007          STRB     r10,[r4,#7]           ;2753
0000ce  2002              MOVS     r0,#2                 ;2753
0000d0  e7a9              B        |L32.38|
                  |L32.210|
0000d2  69a1              LDR      r1,[r4,#0x18]         ;2768
0000d4  9801              LDR      r0,[sp,#4]            ;2768
0000d6  1a08              SUBS     r0,r1,r0              ;2768
0000d8  9900              LDR      r1,[sp,#0]            ;2768
0000da  4288              CMP      r0,r1                 ;2768
0000dc  d20a              BCS      |L32.244|
0000de  eb082140          ADD      r1,r8,r0,LSL #9       ;2769
0000e2  f44f7200          MOV      r2,#0x200             ;2769
0000e6  4658              MOV      r0,r11                ;2769
0000e8  f7fffffe          BL       mem_cpy
0000ec  79a0              LDRB     r0,[r4,#6]            ;2770
0000ee  f0200040          BIC      r0,r0,#0x40           ;2770
0000f2  71a0              STRB     r0,[r4,#6]            ;2770
                  |L32.244|
0000f4  9800              LDR      r0,[sp,#0]            ;2774
0000f6  0246              LSLS     r6,r0,#9              ;2774
0000f8  e029              B        |L32.334|
                  |L32.250|
0000fa  e00f              B        |L32.284|
                  |L32.252|
0000fc  69a1              LDR      r1,[r4,#0x18]         ;2783
0000fe  9801              LDR      r0,[sp,#4]            ;2783
000100  4281              CMP      r1,r0                 ;2783
000102  d010              BEQ      |L32.294|
000104  e9d40102          LDRD     r0,r1,[r4,#8]         ;2783
000108  4288              CMP      r0,r1                 ;2784
00010a  d20c              BCS      |L32.294|
00010c  6820              LDR      r0,[r4,#0]            ;2785
00010e  2301              MOVS     r3,#1                 ;2785
000110  4659              MOV      r1,r11                ;2785
000112  7840              LDRB     r0,[r0,#1]            ;2785
000114  9a01              LDR      r2,[sp,#4]            ;2785
000116  f7fffffe          BL       disk_read
00011a  b120              CBZ      r0,|L32.294|
                  |L32.284|
00011c  71e7              STRB     r7,[r4,#7]            ;2786
00011e  2001              MOVS     r0,#1                 ;2786
000120  e781              B        |L32.38|
                  |L32.290|
000122  e021              B        |L32.360|
000124  e001              B        |L32.298|
                  |L32.294|
000126  9801              LDR      r0,[sp,#4]            ;2789
000128  61a0              STR      r0,[r4,#0x18]         ;2789
                  |L32.298|
00012a  8920              LDRH     r0,[r4,#8]            ;2791
00012c  f3c00008          UBFX     r0,r0,#0,#9           ;2791
000130  f5c07600          RSB      r6,r0,#0x200          ;2791
000134  42ae              CMP      r6,r5                 ;2792
000136  d900              BLS      |L32.314|
000138  462e              MOV      r6,r5                 ;2792
                  |L32.314|
00013a  4420              ADD      r0,r0,r4              ;2799
00013c  4632              MOV      r2,r6                 ;2799
00013e  4641              MOV      r1,r8                 ;2799
000140  3024              ADDS     r0,r0,#0x24           ;2799
000142  f7fffffe          BL       mem_cpy
000146  79a0              LDRB     r0,[r4,#6]            ;2800
000148  f0400040          ORR      r0,r0,#0x40           ;2800
00014c  71a0              STRB     r0,[r4,#6]            ;2800
                  |L32.334|
00014e  68a0              LDR      r0,[r4,#8]            ;2720
000150  44b0              ADD      r8,r8,r6              ;2720
000152  4430              ADD      r0,r0,r6              ;2720
000154  60a0              STR      r0,[r4,#8]            ;2720
000156  f8d90000          LDR      r0,[r9,#0]            ;2720
00015a  1981              ADDS     r1,r0,r6              ;2720
00015c  1bad              SUBS     r5,r5,r6              ;2720
00015e  f8c91000          STR      r1,[r9,#0]            ;2720
                  |L32.354|
000162  2d00              CMP      r5,#0                 ;2719
000164  f47faf6b          BNE      |L32.62|
                  |L32.360|
000168  e9d40102          LDRD     r0,r1,[r4,#8]         ;2719
00016c  4288              CMP      r0,r1                 ;2804
00016e  d900              BLS      |L32.370|
000170  60e0              STR      r0,[r4,#0xc]          ;2804
                  |L32.370|
000172  79a0              LDRB     r0,[r4,#6]            ;2805
000174  f0400020          ORR      r0,r0,#0x20           ;2805
000178  71a0              STRB     r0,[r4,#6]            ;2805
00017a  2000              MOVS     r0,#0                 ;2807
00017c  e753              B        |L32.38|
;;;2809   
                          ENDP


                          AREA ||i.find_volume||, CODE, READONLY, ALIGN=2

                  find_volume PROC
;;;2203   static
;;;2204   FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
000000  e92d47ff          PUSH     {r0-r10,lr}
;;;2205   	FATFS** rfs,		/* Pointer to pointer to the found file system object */
;;;2206   	const TCHAR** path,	/* Pointer to pointer to the path name (drive number) */
;;;2207   	BYTE wmode			/* !=0: Check write protection for write access */
;;;2208   )
;;;2209   {
;;;2210   	BYTE fmt, *pt;
;;;2211   	int vol;
;;;2212   	DSTATUS stat;
;;;2213   	DWORD bsect, fasize, tsect, sysect, nclst, szbfat, br[4];
;;;2214   	WORD nrsv;
;;;2215   	FATFS *fs;
;;;2216   	UINT i;
;;;2217   
;;;2218   
;;;2219   	/* Get logical drive number from the path name */
;;;2220   	*rfs = 0;
000004  f04f0900          MOV      r9,#0
000008  4607              MOV      r7,r0                 ;2209
;;;2221   	vol = get_ldnumber(path);
00000a  f8c09000          STR      r9,[r0,#0]
00000e  4616              MOV      r6,r2                 ;2209
000010  4608              MOV      r0,r1
000012  f7fffffe          BL       get_ldnumber
000016  0005              MOVS     r5,r0
;;;2222   	if (vol < 0) return FR_INVALID_DRIVE;
000018  d503              BPL      |L33.34|
00001a  200b              MOVS     r0,#0xb
                  |L33.28|
;;;2223   
;;;2224   	/* Check if the file system object is valid or not */
;;;2225   	fs = FatFs[vol];					/* Get pointer to the file system object */
;;;2226   	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
;;;2227   
;;;2228   	ENTER_FF(fs);						/* Lock the volume */
;;;2229   	*rfs = fs;							/* Return pointer to the file system object */
;;;2230   
;;;2231   	if (fs->fs_type) {					/* If the volume has been mounted */
;;;2232   		stat = disk_status(fs->drv);
;;;2233   		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
;;;2234   			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
;;;2235   				return FR_WRITE_PROTECTED;
;;;2236   			return FR_OK;				/* The file system object is valid */
;;;2237   		}
;;;2238   	}
;;;2239   
;;;2240   	/* The file system object is not valid. */
;;;2241   	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */
;;;2242   
;;;2243   	fs->fs_type = 0;					/* Clear the file system object */
;;;2244   	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
;;;2245   	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
;;;2246   	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
;;;2247   		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
;;;2248   	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
;;;2249   		return FR_WRITE_PROTECTED;
;;;2250   #if _MAX_SS != _MIN_SS						/* Get sector size (multiple sector size cfg only) */
;;;2251   	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK
;;;2252   		|| SS(fs) < _MIN_SS || SS(fs) > _MAX_SS) return FR_DISK_ERR;
;;;2253   #endif
;;;2254   	/* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
;;;2255   	bsect = 0;
;;;2256   	fmt = check_fs(fs, bsect);					/* Load sector 0 and check if it is an FAT boot sector as SFD */
;;;2257   //    v1000_debug("f open fmt :%d \r\n",fmt);
;;;2258   	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
;;;2259   		for (i = 0; i < 4; i++) {			/* Get partition offset */
;;;2260   			pt = fs->win + MBR_Table + i * SZ_PTE;
;;;2261   			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
;;;2262   		}
;;;2263   		i = LD2PT(vol);						/* Partition number: 0:auto, 1-4:forced */
;;;2264   		if (i) i--;
;;;2265   		do {								/* Find an FAT volume */
;;;2266   			bsect = br[i];
;;;2267   			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
;;;2268   		} while (!LD2PT(vol) && fmt && ++i < 4);
;;;2269   	}
;;;2270   	if (fmt == 3) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
;;;2271   	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
;;;2272   
;;;2273   	/* An FAT volume is found. Following code initializes the file system object */
;;;2274   
;;;2275   	if (LD_WORD(fs->win + BPB_BytsPerSec) != SS(fs))	/* (BPB_BytsPerSec must be equal to the physical sector size) */
;;;2276   		return FR_NO_FILESYSTEM;
;;;2277   
;;;2278   	fasize = LD_WORD(fs->win + BPB_FATSz16);			/* Number of sectors per FAT */
;;;2279   	if (!fasize) fasize = LD_DWORD(fs->win + BPB_FATSz32);
;;;2280   	fs->fsize = fasize;
;;;2281   
;;;2282   	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
;;;2283   	if (fs->n_fats != 1 && fs->n_fats != 2)				/* (Must be 1 or 2) */
;;;2284   		return FR_NO_FILESYSTEM;
;;;2285   	fasize *= fs->n_fats;								/* Number of sectors for FAT area */
;;;2286   
;;;2287   	fs->csize = fs->win[BPB_SecPerClus];				/* Number of sectors per cluster */
;;;2288   	if (!fs->csize || (fs->csize & (fs->csize - 1)))	/* (Must be power of 2) */
;;;2289   		return FR_NO_FILESYSTEM;
;;;2290   
;;;2291   	fs->n_rootdir = LD_WORD(fs->win + BPB_RootEntCnt);	/* Number of root directory entries */
;;;2292   	if (fs->n_rootdir % (SS(fs) / SZ_DIRE))				/* (Must be sector aligned) */
;;;2293   		return FR_NO_FILESYSTEM;
;;;2294   
;;;2295   	tsect = LD_WORD(fs->win + BPB_TotSec16);			/* Number of sectors on the volume */
;;;2296   	if (!tsect) tsect = LD_DWORD(fs->win + BPB_TotSec32);
;;;2297   
;;;2298   	nrsv = LD_WORD(fs->win + BPB_RsvdSecCnt);			/* Number of reserved sectors */
;;;2299   	if (!nrsv) return FR_NO_FILESYSTEM;					/* (Must not be 0) */
;;;2300   
;;;2301   	/* Determine the FAT sub type */
;;;2302   	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIRE);	/* RSV + FAT + DIR */
;;;2303   	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
;;;2304   	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
;;;2305   	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
;;;2306   	fmt = FS_FAT12;
;;;2307   	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
;;;2308   	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
;;;2309   
;;;2310   	/* Boundaries and Limits */
;;;2311   	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
;;;2312   	fs->volbase = bsect;								/* Volume start sector */
;;;2313   	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
;;;2314   	fs->database = bsect + sysect;						/* Data start sector */
;;;2315   	if (fmt == FS_FAT32) {
;;;2316   		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
;;;2317   		fs->dirbase = LD_DWORD(fs->win + BPB_RootClus);	/* Root directory start cluster */
;;;2318   		szbfat = fs->n_fatent * 4;						/* (Needed FAT size) */
;;;2319   	} else {
;;;2320   		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
;;;2321   		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
;;;2322   		szbfat = (fmt == FS_FAT16) ?					/* (Needed FAT size) */
;;;2323   			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
;;;2324   	}
;;;2325   	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than the size needed) */
;;;2326   		return FR_NO_FILESYSTEM;
;;;2327   
;;;2328   #if !_FS_READONLY
;;;2329   	/* Initialize cluster allocation information */
;;;2330   	fs->last_clust = fs->free_clust = 0xFFFFFFFF;
;;;2331   
;;;2332   	/* Get fsinfo if available */
;;;2333   	fs->fsi_flag = 0x80;
;;;2334   #if (_FS_NOFSINFO & 3) != 3
;;;2335   	if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo == 1 */
;;;2336   		&& LD_WORD(fs->win + BPB_FSInfo) == 1
;;;2337   		&& move_window(fs, bsect + 1) == FR_OK)
;;;2338   	{
;;;2339   		fs->fsi_flag = 0;
;;;2340   		if (LD_WORD(fs->win + BS_55AA) == 0xAA55	/* Load FSINFO data if available */
;;;2341   			&& LD_DWORD(fs->win + FSI_LeadSig) == 0x41615252
;;;2342   			&& LD_DWORD(fs->win + FSI_StrucSig) == 0x61417272)
;;;2343   		{
;;;2344   #if (_FS_NOFSINFO & 1) == 0
;;;2345   			fs->free_clust = LD_DWORD(fs->win + FSI_Free_Count);
;;;2346   #endif
;;;2347   #if (_FS_NOFSINFO & 2) == 0
;;;2348   			fs->last_clust = LD_DWORD(fs->win + FSI_Nxt_Free);
;;;2349   #endif
;;;2350   		}
;;;2351   	}
;;;2352   #endif
;;;2353   #endif
;;;2354   	fs->fs_type = fmt;	/* FAT sub-type */
;;;2355   	fs->id = ++Fsid;	/* File system mount ID */
;;;2356   #if _FS_RPATH
;;;2357   	fs->cdir = 0;		/* Set current directory to root */
;;;2358   #endif
;;;2359   #if _FS_LOCK			/* Clear file lock semaphores */
;;;2360   	clear_lock(fs);
;;;2361   #endif
;;;2362   
;;;2363   	return FR_OK;
;;;2364   }
00001c  b004              ADD      sp,sp,#0x10
00001e  e8bd87f0          POP      {r4-r10,pc}
                  |L33.34|
000022  4882              LDR      r0,|L33.556|
000024  f8504025          LDR      r4,[r0,r5,LSL #2]     ;2225
000028  b18c              CBZ      r4,|L33.78|
00002a  603c              STR      r4,[r7,#0]            ;2231
00002c  7820              LDRB     r0,[r4,#0]            ;2231
00002e  b120              CBZ      r0,|L33.58|
000030  7860              LDRB     r0,[r4,#1]            ;2232
000032  f7fffffe          BL       disk_status
000036  07c1              LSLS     r1,r0,#31             ;2233
000038  d00b              BEQ      |L33.82|
                  |L33.58|
00003a  f8849000          STRB     r9,[r4,#0]            ;2243
00003e  b2e8              UXTB     r0,r5                 ;2244
000040  7060              STRB     r0,[r4,#1]            ;2244
000042  f7fffffe          BL       disk_initialize
000046  07c1              LSLS     r1,r0,#31             ;2246
000048  d008              BEQ      |L33.92|
00004a  2003              MOVS     r0,#3                 ;2247
00004c  e7e6              B        |L33.28|
                  |L33.78|
00004e  200c              MOVS     r0,#0xc               ;2226
000050  e7e4              B        |L33.28|
                  |L33.82|
000052  b10e              CBZ      r6,|L33.88|
000054  0740              LSLS     r0,r0,#29             ;2234
000056  d404              BMI      |L33.98|
                  |L33.88|
000058  2000              MOVS     r0,#0                 ;2236
00005a  e7df              B        |L33.28|
                  |L33.92|
00005c  b11e              CBZ      r6,|L33.102|
00005e  0740              LSLS     r0,r0,#29             ;2248
000060  d501              BPL      |L33.102|
                  |L33.98|
000062  200a              MOVS     r0,#0xa               ;2249
000064  e7da              B        |L33.28|
                  |L33.102|
000066  2500              MOVS     r5,#0                 ;2255
000068  4629              MOV      r1,r5                 ;2256
00006a  4620              MOV      r0,r4                 ;2256
00006c  f7fffffe          BL       check_fs
000070  2801              CMP      r0,#1                 ;2258
000072  d122              BNE      |L33.186|
000074  2000              MOVS     r0,#0                 ;2259
000076  466f              MOV      r7,sp                 ;2213
                  |L33.120|
000078  eb041100          ADD      r1,r4,r0,LSL #4       ;2260
00007c  f89121f2          LDRB     r2,[r1,#0x1f2]        ;2261
000080  f50171f7          ADD      r1,r1,#0x1ee          ;2261
000084  b12a              CBZ      r2,|L33.146|
000086  7a0a              LDRB     r2,[r1,#8]            ;2261
000088  f8d11009          LDR      r1,[r1,#9]            ;2261
00008c  ea422101          ORR      r1,r2,r1,LSL #8       ;2261
000090  e000              B        |L33.148|
                  |L33.146|
000092  2100              MOVS     r1,#0                 ;2261
                  |L33.148|
000094  f8471020          STR      r1,[r7,r0,LSL #2]     ;2261
000098  1c40              ADDS     r0,r0,#1              ;2261
00009a  2804              CMP      r0,#4                 ;2259
00009c  d3ec              BCC      |L33.120|
00009e  2600              MOVS     r6,#0                 ;2263
                  |L33.160|
0000a0  f8575026          LDR      r5,[r7,r6,LSL #2]     ;2266
0000a4  b12d              CBZ      r5,|L33.178|
0000a6  4629              MOV      r1,r5                 ;2267
0000a8  4620              MOV      r0,r4                 ;2267
0000aa  f7fffffe          BL       check_fs
0000ae  b908              CBNZ     r0,|L33.180|
0000b0  e009              B        |L33.198|
                  |L33.178|
0000b2  2002              MOVS     r0,#2                 ;2267
                  |L33.180|
0000b4  1c76              ADDS     r6,r6,#1              ;2267
0000b6  2e04              CMP      r6,#4                 ;2268
0000b8  d3f2              BCC      |L33.160|
                  |L33.186|
0000ba  2803              CMP      r0,#3                 ;2270
0000bc  d001              BEQ      |L33.194|
0000be  bbe8              CBNZ     r0,|L33.316|
0000c0  e001              B        |L33.198|
                  |L33.194|
0000c2  2001              MOVS     r0,#1                 ;2270
0000c4  e7aa              B        |L33.28|
                  |L33.198|
0000c6  f8b4003b          LDRH     r0,[r4,#0x3b]         ;2275
0000ca  f5b07f00          CMP      r0,#0x200             ;2275
0000ce  d15c              BNE      |L33.394|
0000d0  f8b42046          LDRH     r2,[r4,#0x46]         ;2278
0000d4  b92a              CBNZ     r2,|L33.226|
0000d6  f8940054          LDRB     r0,[r4,#0x54]         ;2279
0000da  f8d41055          LDR      r1,[r4,#0x55]         ;2279
0000de  ea402201          ORR      r2,r0,r1,LSL #8       ;2279
                  |L33.226|
0000e2  61a2              STR      r2,[r4,#0x18]         ;2282
0000e4  f8941040          LDRB     r1,[r4,#0x40]         ;2282
0000e8  70e1              STRB     r1,[r4,#3]            ;2282
0000ea  2901              CMP      r1,#1                 ;2283
0000ec  d001              BEQ      |L33.242|
0000ee  2902              CMP      r1,#2                 ;2283
0000f0  d14b              BNE      |L33.394|
                  |L33.242|
0000f2  f894003d          LDRB     r0,[r4,#0x3d]         ;2287
0000f6  4351              MULS     r1,r2,r1              ;2285
0000f8  70a0              STRB     r0,[r4,#2]            ;2287
0000fa  b1f8              CBZ      r0,|L33.316|
0000fc  1e43              SUBS     r3,r0,#1              ;2288
0000fe  4218              TST      r0,r3                 ;2288
000100  d143              BNE      |L33.394|
000102  f8b43041          LDRH     r3,[r4,#0x41]         ;2291
000106  8123              STRH     r3,[r4,#8]            ;2291
000108  071e              LSLS     r6,r3,#28             ;2292
00010a  d13e              BNE      |L33.394|
00010c  f8b46043          LDRH     r6,[r4,#0x43]         ;2295
000110  b92e              CBNZ     r6,|L33.286|
000112  f8946050          LDRB     r6,[r4,#0x50]         ;2296
000116  f8d47051          LDR      r7,[r4,#0x51]         ;2296
00011a  ea462607          ORR      r6,r6,r7,LSL #8       ;2296
                  |L33.286|
00011e  f8b4c03e          LDRH     r12,[r4,#0x3e]        ;2298
000122  f1bc0f00          CMP      r12,#0                ;2299
000126  d030              BEQ      |L33.394|
000128  eb0c0701          ADD      r7,r12,r1             ;2302
00012c  eb071713          ADD      r7,r7,r3,LSR #4       ;2302
000130  42be              CMP      r6,r7                 ;2303
000132  d32a              BCC      |L33.394|
000134  1bf6              SUBS     r6,r6,r7              ;2304
000136  fbb6f0f0          UDIV     r0,r6,r0              ;2304
00013a  e000              B        |L33.318|
                  |L33.316|
00013c  e025              B        |L33.394|
                  |L33.318|
00013e  b320              CBZ      r0,|L33.394|
000140  2601              MOVS     r6,#1                 ;2306
000142  f64078f6          MOV      r8,#0xff6             ;2307
000146  4540              CMP      r0,r8                 ;2307
000148  d300              BCC      |L33.332|
00014a  2602              MOVS     r6,#2                 ;2307
                  |L33.332|
00014c  f64f78f6          MOV      r8,#0xfff6            ;2308
000150  4540              CMP      r0,r8                 ;2308
000152  d300              BCC      |L33.342|
000154  2603              MOVS     r6,#3                 ;2308
                  |L33.342|
000156  1c80              ADDS     r0,r0,#2              ;2308
000158  442f              ADD      r7,r7,r5              ;2314
00015a  62a7              STR      r7,[r4,#0x28]         ;2315
00015c  44ac              ADD      r12,r12,r5            ;2313
00015e  6160              STR      r0,[r4,#0x14]         ;2315
000160  e9c45c07          STRD     r5,r12,[r4,#0x1c]     ;2315
000164  2e03              CMP      r6,#3                 ;2315
000166  d012              BEQ      |L33.398|
000168  b17b              CBZ      r3,|L33.394|
00016a  4461              ADD      r1,r1,r12             ;2321
00016c  6261              STR      r1,[r4,#0x24]         ;2322
00016e  2e02              CMP      r6,#2                 ;2322
000170  d018              BEQ      |L33.420|
000172  f0000101          AND      r1,r0,#1              ;2323
000176  eb000040          ADD      r0,r0,r0,LSL #1       ;2323
00017a  eb010050          ADD      r0,r1,r0,LSR #1       ;2323
00017e  bf00              NOP                            ;2323
                  |L33.384|
000180  f20010ff          ADD      r0,r0,#0x1ff          ;2323
000184  ebb22f50          CMP      r2,r0,LSR #9          ;2325
000188  d20e              BCS      |L33.424|
                  |L33.394|
00018a  200d              MOVS     r0,#0xd               ;2326
00018c  e746              B        |L33.28|
                  |L33.398|
00018e  2b00              CMP      r3,#0                 ;2316
000190  d1fb              BNE      |L33.394|
000192  f894105c          LDRB     r1,[r4,#0x5c]         ;2317
000196  f8d4305d          LDR      r3,[r4,#0x5d]         ;2317
00019a  0080              LSLS     r0,r0,#2              ;2318
00019c  ea412103          ORR      r1,r1,r3,LSL #8       ;2317
0001a0  6261              STR      r1,[r4,#0x24]         ;2318
0001a2  e7ed              B        |L33.384|
                  |L33.420|
0001a4  0040              LSLS     r0,r0,#1              ;2323
0001a6  e7eb              B        |L33.384|
                  |L33.424|
0001a8  f04f30ff          MOV      r0,#0xffffffff        ;2330
0001ac  6120              STR      r0,[r4,#0x10]         ;2330
0001ae  60e0              STR      r0,[r4,#0xc]          ;2333
0001b0  2080              MOVS     r0,#0x80              ;2333
0001b2  7160              STRB     r0,[r4,#5]            ;2333
0001b4  2e03              CMP      r6,#3                 ;2335
0001b6  d130              BNE      |L33.538|
0001b8  f8b40060          LDRH     r0,[r4,#0x60]         ;2336
0001bc  2801              CMP      r0,#1                 ;2336
0001be  d12c              BNE      |L33.538|
0001c0  4620              MOV      r0,r4                 ;2337
0001c2  1c69              ADDS     r1,r5,#1              ;2337
0001c4  f7fffffe          BL       move_window
0001c8  bb38              CBNZ     r0,|L33.538|
0001ca  f8849005          STRB     r9,[r4,#5]            ;2339
0001ce  f8b4022e          LDRH     r0,[r4,#0x22e]        ;2340
0001d2  f5a0412a          SUB      r1,r0,#0xaa00         ;2340
0001d6  3955              SUBS     r1,r1,#0x55           ;2340
0001d8  d11f              BNE      |L33.538|
0001da  f8940030          LDRB     r0,[r4,#0x30]         ;2341
0001de  f8d41031          LDR      r1,[r4,#0x31]         ;2341
0001e2  ea402001          ORR      r0,r0,r1,LSL #8       ;2341
0001e6  4912              LDR      r1,|L33.560|
0001e8  4288              CMP      r0,r1                 ;2341
0001ea  d116              BNE      |L33.538|
0001ec  f8940214          LDRB     r0,[r4,#0x214]        ;2342
0001f0  f8d41215          LDR      r1,[r4,#0x215]        ;2342
0001f4  ea402001          ORR      r0,r0,r1,LSL #8       ;2342
0001f8  490e              LDR      r1,|L33.564|
0001fa  4288              CMP      r0,r1                 ;2342
0001fc  d10d              BNE      |L33.538|
0001fe  f8940218          LDRB     r0,[r4,#0x218]        ;2345
000202  f8d41219          LDR      r1,[r4,#0x219]        ;2345
000206  ea402001          ORR      r0,r0,r1,LSL #8       ;2345
00020a  6120              STR      r0,[r4,#0x10]         ;2348
00020c  f894021c          LDRB     r0,[r4,#0x21c]        ;2348
000210  f8d4121d          LDR      r1,[r4,#0x21d]        ;2348
000214  ea402001          ORR      r0,r0,r1,LSL #8       ;2348
000218  60e0              STR      r0,[r4,#0xc]          ;2348
                  |L33.538|
00021a  4904              LDR      r1,|L33.556|
00021c  7026              STRB     r6,[r4,#0]            ;2354
00021e  1f09              SUBS     r1,r1,#4              ;2355
000220  8808              LDRH     r0,[r1,#0]            ;2355  ; Fsid
000222  1c40              ADDS     r0,r0,#1              ;2355
000224  8008              STRH     r0,[r1,#0]            ;2355
000226  80e0              STRH     r0,[r4,#6]            ;2355
000228  e716              B        |L33.88|
;;;2365   
                          ENDP

00022a  0000              DCW      0x0000
                  |L33.556|
                          DCD      ||.data||+0x4
                  |L33.560|
                          DCD      0x41615252
                  |L33.564|
                          DCD      0x61417272

                          AREA ||i.follow_path||, CODE, READONLY, ALIGN=1

                  follow_path PROC
;;;2052   static
;;;2053   FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
000000  b573              PUSH     {r0,r1,r4-r6,lr}
;;;2054   	DIR* dp,			/* Directory object to return last directory and found object */
;;;2055   	const TCHAR* path	/* Full-path string to find a file or directory */
;;;2056   )
;;;2057   {
000002  4604              MOV      r4,r0
;;;2058   	FRESULT res;
;;;2059   	BYTE *dir, ns;
;;;2060   
;;;2061   
;;;2062   #if _FS_RPATH
;;;2063   	if (*path == '/' || *path == '\\') {	/* There is a heading separator */
;;;2064   		path++;	dp->sclust = 0;				/* Strip it and start from the root directory */
;;;2065   	} else {								/* No heading separator */
;;;2066   		dp->sclust = dp->fs->cdir;			/* Start from the current directory */
;;;2067   	}
;;;2068   #else
;;;2069   	if (*path == '/' || *path == '\\')		/* Strip heading separator if exist */
000004  9901              LDR      r1,[sp,#4]
000006  7808              LDRB     r0,[r1,#0]
000008  282f              CMP      r0,#0x2f
00000a  d001              BEQ      |L34.16|
00000c  285c              CMP      r0,#0x5c
00000e  d101              BNE      |L34.20|
                  |L34.16|
000010  1c49              ADDS     r1,r1,#1
;;;2070   		path++;
000012  9101              STR      r1,[sp,#4]
                  |L34.20|
;;;2071   	dp->sclust = 0;							/* Always start from the root directory */
000014  2500              MOVS     r5,#0
;;;2072   #endif
;;;2073   
;;;2074   	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
000016  60a5              STR      r5,[r4,#8]
000018  9801              LDR      r0,[sp,#4]
00001a  7800              LDRB     r0,[r0,#0]
00001c  2820              CMP      r0,#0x20
00001e  d205              BCS      |L34.44|
;;;2075   		res = dir_sdi(dp, 0);
000020  2100              MOVS     r1,#0
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       dir_sdi
;;;2076   		dp->dir = 0;
000028  6165              STR      r5,[r4,#0x14]
                  |L34.42|
;;;2077   	} else {								/* Follow path */
;;;2078   		for (;;) {
;;;2079   			res = create_name(dp, &path);	/* Get a segment name of the path */
;;;2080   			if (res != FR_OK) break;
;;;2081   			res = dir_find(dp);				/* Find an object with the sagment name */
;;;2082   			ns = dp->fn[NSFLAG];
;;;2083   			if (res != FR_OK) {				/* Failed to find the object */
;;;2084   				if (res == FR_NO_FILE) {	/* Object is not found */
;;;2085   					if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exist, */
;;;2086   						dp->sclust = 0; dp->dir = 0;	/* it is the root directory and stay there */
;;;2087   						if (!(ns & NS_LAST)) continue;	/* Continue to follow if not last segment */
;;;2088   						res = FR_OK;					/* Ended at the root directroy. Function completed. */
;;;2089   					} else {							/* Could not find the object */
;;;2090   						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
;;;2091   					}
;;;2092   				}
;;;2093   				break;
;;;2094   			}
;;;2095   			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
;;;2096   			dir = dp->dir;						/* Follow the sub-directory */
;;;2097   			if (!(dir[DIR_Attr] & AM_DIR)) {	/* It is not a sub-directory and cannot follow */
;;;2098   				res = FR_NO_PATH; break;
;;;2099   			}
;;;2100   			dp->sclust = ld_clust(dp->fs, dir);
;;;2101   		}
;;;2102   	}
;;;2103   
;;;2104   	return res;
;;;2105   }
00002a  bd7c              POP      {r2-r6,pc}
                  |L34.44|
00002c  a901              ADD      r1,sp,#4              ;2079
00002e  4620              MOV      r0,r4                 ;2079
000030  f7fffffe          BL       create_name
000034  2800              CMP      r0,#0                 ;2080
000036  d1f8              BNE      |L34.42|
000038  2100              MOVS     r1,#0                 ;2080
00003a  4620              MOV      r0,r4                 ;2080
00003c  f7fffffe          BL       dir_sdi
000040  b9f8              CBNZ     r0,|L34.130|
                  |L34.66|
000042  6921              LDR      r1,[r4,#0x10]         ;2080
000044  6820              LDR      r0,[r4,#0]            ;2080
000046  f7fffffe          BL       move_window
00004a  b9d0              CBNZ     r0,|L34.130|
00004c  6961              LDR      r1,[r4,#0x14]         ;2080
00004e  780a              LDRB     r2,[r1,#0]            ;2080
000050  b12a              CBZ      r2,|L34.94|
000052  7aca              LDRB     r2,[r1,#0xb]          ;2080
000054  0712              LSLS     r2,r2,#28             ;2080
000056  d40e              BMI      |L34.118|
000058  230a              MOVS     r3,#0xa
00005a  69a2              LDR      r2,[r4,#0x18]
00005c  e003              B        |L34.102|
                  |L34.94|
00005e  2004              MOVS     r0,#4
000060  e00f              B        |L34.130|
                  |L34.98|
000062  1e5b              SUBS     r3,r3,#1
000064  d306              BCC      |L34.116|
                  |L34.102|
000066  f8115b01          LDRB     r5,[r1],#1
00006a  f8126b01          LDRB     r6,[r2],#1
00006e  1bad              SUBS     r5,r5,r6
000070  d0f7              BEQ      |L34.98|
000072  e000              B        |L34.118|
                  |L34.116|
000074  b12d              CBZ      r5,|L34.130|
                  |L34.118|
000076  2100              MOVS     r1,#0
000078  4620              MOV      r0,r4
00007a  f7fffffe          BL       dir_next
00007e  2800              CMP      r0,#0
000080  d0df              BEQ      |L34.66|
                  |L34.130|
000082  69a1              LDR      r1,[r4,#0x18]         ;2082
000084  7ac9              LDRB     r1,[r1,#0xb]          ;2082
000086  b128              CBZ      r0,|L34.148|
000088  2804              CMP      r0,#4                 ;2084
00008a  d1ce              BNE      |L34.42|
00008c  0749              LSLS     r1,r1,#29             ;2090
00008e  d4cc              BMI      |L34.42|
                  |L34.144|
000090  2005              MOVS     r0,#5                 ;2090
                  |L34.146|
000092  bd7c              POP      {r2-r6,pc}
                  |L34.148|
000094  0749              LSLS     r1,r1,#29             ;2095
000096  d4fc              BMI      |L34.146|
000098  6961              LDR      r1,[r4,#0x14]         ;2097
00009a  7ac8              LDRB     r0,[r1,#0xb]          ;2097
00009c  06c0              LSLS     r0,r0,#27             ;2097
00009e  d5f7              BPL      |L34.144|
0000a0  6820              LDR      r0,[r4,#0]            ;2100
0000a2  f7fffffe          BL       ld_clust
0000a6  60a0              STR      r0,[r4,#8]            ;2087
0000a8  e7c0              B        |L34.44|
;;;2106   
                          ENDP


                          AREA ||i.get_fat||, CODE, READONLY, ALIGN=1

                  get_fat PROC
;;;818    
;;;819    DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, 2..0x0FFFFFFF:Cluster status */
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;820    	FATFS* fs,	/* File system object */
;;;821    	DWORD clst	/* FAT index number (cluster number) to get the value */
;;;822    )
;;;823    {
000004  460d              MOV      r5,r1
000006  4604              MOV      r4,r0
;;;824    	UINT wc, bc;
;;;825    	BYTE *p;
;;;826    	DWORD val;
;;;827    
;;;828    
;;;829    	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
000008  2902              CMP      r1,#2
00000a  d30b              BCC      |L35.36|
00000c  6960              LDR      r0,[r4,#0x14]
00000e  42a8              CMP      r0,r5
000010  d908              BLS      |L35.36|
;;;830    		val = 1;	/* Internal error */
;;;831    
;;;832    	} else {
;;;833    		val = 0xFFFFFFFF;	/* Default value falls on disk error */
;;;834    
;;;835    		switch (fs->fs_type) {
000012  7820              LDRB     r0,[r4,#0]
000014  f04f36ff          MOV      r6,#0xffffffff        ;833
000018  2801              CMP      r0,#1
00001a  d007              BEQ      |L35.44|
00001c  2802              CMP      r0,#2
00001e  d02b              BEQ      |L35.120|
000020  2803              CMP      r0,#3
000022  d036              BEQ      |L35.146|
                  |L35.36|
;;;836    		case FS_FAT12 :
;;;837    			bc = (UINT)clst; bc += bc / 2;
;;;838    			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
;;;839    			wc = fs->win[bc++ % SS(fs)];
;;;840    			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
;;;841    			wc |= fs->win[bc % SS(fs)] << 8;
;;;842    			val = clst & 1 ? wc >> 4 : (wc & 0xFFF);
;;;843    			break;
;;;844    
;;;845    		case FS_FAT16 :
;;;846    			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
;;;847    			p = &fs->win[clst * 2 % SS(fs)];
;;;848    			val = LD_WORD(p);
;;;849    			break;
;;;850    
;;;851    		case FS_FAT32 :
;;;852    			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
;;;853    			p = &fs->win[clst * 4 % SS(fs)];
;;;854    			val = LD_DWORD(p) & 0x0FFFFFFF;
;;;855    			break;
;;;856    
;;;857    		default:
;;;858    			val = 1;	/* Internal error */
000024  2601              MOVS     r6,#1
                  |L35.38|
;;;859    		}
;;;860    	}
;;;861    
;;;862    	return val;
000026  4630              MOV      r0,r6
;;;863    }
000028  e8bd81f0          POP      {r4-r8,pc}
                  |L35.44|
00002c  6a20              LDR      r0,[r4,#0x20]         ;838
00002e  eb050755          ADD      r7,r5,r5,LSR #1       ;837
000032  eb002157          ADD      r1,r0,r7,LSR #9       ;838
000036  4620              MOV      r0,r4                 ;838
000038  f7fffffe          BL       move_window
00003c  2800              CMP      r0,#0                 ;838
00003e  d1f2              BNE      |L35.38|
000040  f3c70008          UBFX     r0,r7,#0,#9           ;839
000044  4420              ADD      r0,r0,r4              ;839
000046  1c7f              ADDS     r7,r7,#1              ;840
000048  f8908030          LDRB     r8,[r0,#0x30]         ;839
00004c  6a20              LDR      r0,[r4,#0x20]         ;840
00004e  eb002157          ADD      r1,r0,r7,LSR #9       ;840
000052  4620              MOV      r0,r4                 ;840
000054  f7fffffe          BL       move_window
000058  2800              CMP      r0,#0                 ;840
00005a  d1e4              BNE      |L35.38|
00005c  f3c70008          UBFX     r0,r7,#0,#9           ;841
000060  4420              ADD      r0,r0,r4              ;841
000062  f8901030          LDRB     r1,[r0,#0x30]         ;841
000066  ea482001          ORR      r0,r8,r1,LSL #8       ;841
00006a  07e9              LSLS     r1,r5,#31             ;842
00006c  d001              BEQ      |L35.114|
00006e  0906              LSRS     r6,r0,#4              ;842
000070  e7d9              B        |L35.38|
                  |L35.114|
000072  f3c0060b          UBFX     r6,r0,#0,#12          ;842
000076  e7d6              B        |L35.38|
                  |L35.120|
000078  6a20              LDR      r0,[r4,#0x20]         ;846
00007a  eb002115          ADD      r1,r0,r5,LSR #8       ;846
00007e  4620              MOV      r0,r4                 ;846
000080  f7fffffe          BL       move_window
000084  2800              CMP      r0,#0                 ;846
000086  d1ce              BNE      |L35.38|
000088  b2e8              UXTB     r0,r5                 ;847
00008a  eb040040          ADD      r0,r4,r0,LSL #1       ;847
00008e  8e06              LDRH     r6,[r0,#0x30]         ;848
000090  e7c9              B        |L35.38|
                  |L35.146|
000092  6a20              LDR      r0,[r4,#0x20]         ;852
000094  eb0011d5          ADD      r1,r0,r5,LSR #7       ;852
000098  4620              MOV      r0,r4                 ;852
00009a  f7fffffe          BL       move_window
00009e  2800              CMP      r0,#0                 ;852
0000a0  d1c1              BNE      |L35.38|
0000a2  f24010ff          MOV      r0,#0x1ff             ;853
0000a6  ea000085          AND      r0,r0,r5,LSL #2       ;853
0000aa  4420              ADD      r0,r0,r4              ;853
0000ac  f8901030          LDRB     r1,[r0,#0x30]         ;854
0000b0  f8d00031          LDR      r0,[r0,#0x31]         ;854
0000b4  ea412000          ORR      r0,r1,r0,LSL #8       ;854
0000b8  f0204670          BIC      r6,r0,#0xf0000000     ;854
0000bc  e7b3              B        |L35.38|
;;;864    
                          ENDP


                          AREA ||i.get_fileinfo||, CODE, READONLY, ALIGN=1

                  get_fileinfo PROC
;;;1703   static
;;;1704   void get_fileinfo (		/* No return code */
000000  b530              PUSH     {r4,r5,lr}
;;;1705   	DIR* dp,			/* Pointer to the directory object */
;;;1706   	FILINFO* fno	 	/* Pointer to the file information to be filled */
;;;1707   )
;;;1708   {
000002  6903              LDR      r3,[r0,#0x10]
;;;1709   	UINT i;
;;;1710   	TCHAR *p, c;
;;;1711   	BYTE *dir;
;;;1712   #if _USE_LFN
;;;1713   	WCHAR w, *lfn;
;;;1714   #endif
;;;1715   
;;;1716   	p = fno->fname;
000004  f1010209          ADD      r2,r1,#9
000008  b1eb              CBZ      r3,|L36.70|
;;;1717   	if (dp->sect) {		/* Get SFN */
;;;1718   		dir = dp->dir;
00000a  6940              LDR      r0,[r0,#0x14]
;;;1719   		i = 0;
00000c  2300              MOVS     r3,#0
;;;1720   		while (i < 11) {		/* Copy name body and extension */
;;;1721   			c = (TCHAR)dir[i++];
;;;1722   			if (c == ' ') continue;				/* Skip padding spaces */
;;;1723   			if (c == RDDEM) c = (TCHAR)DDEM;	/* Restore replaced DDEM character */
;;;1724   			if (i == 9) *p++ = '.';				/* Insert a . if extension is exist */
00000e  252e              MOVS     r5,#0x2e
                  |L36.16|
000010  5cc4              LDRB     r4,[r0,r3]            ;1721
000012  1c5b              ADDS     r3,r3,#1              ;1721
000014  2c20              CMP      r4,#0x20              ;1722
000016  d008              BEQ      |L36.42|
000018  2c05              CMP      r4,#5                 ;1723
00001a  d100              BNE      |L36.30|
00001c  24e5              MOVS     r4,#0xe5              ;1723
                  |L36.30|
00001e  2b09              CMP      r3,#9
000020  d101              BNE      |L36.38|
000022  f8025b01          STRB     r5,[r2],#1
                  |L36.38|
;;;1725   #if _USE_LFN
;;;1726   			if (IsUpper(c) && (dir[DIR_NTres] & (i >= 9 ? NS_EXT : NS_BODY)))
;;;1727   				c += 0x20;			/* To lower */
;;;1728   #if _LFN_UNICODE
;;;1729   			if (IsDBCS1(c) && i != 8 && i != 11 && IsDBCS2(dir[i]))
;;;1730   				c = c << 8 | dir[i++];
;;;1731   			c = ff_convert(c, 1);	/* OEM -> Unicode */
;;;1732   			if (!c) c = '?';
;;;1733   #endif
;;;1734   #endif
;;;1735   			*p++ = c;
000026  f8024b01          STRB     r4,[r2],#1
                  |L36.42|
00002a  2b0b              CMP      r3,#0xb               ;1720
00002c  d3f0              BCC      |L36.16|
;;;1736   		}
;;;1737   		fno->fattrib = dir[DIR_Attr];				/* Attribute */
00002e  7ac3              LDRB     r3,[r0,#0xb]
000030  720b              STRB     r3,[r1,#8]
;;;1738   		fno->fsize = LD_DWORD(dir + DIR_FileSize);	/* Size */
000032  7f03              LDRB     r3,[r0,#0x1c]
000034  f8d0401d          LDR      r4,[r0,#0x1d]
000038  ea432304          ORR      r3,r3,r4,LSL #8
;;;1739   		fno->fdate = LD_WORD(dir + DIR_WrtDate);	/* Date */
00003c  600b              STR      r3,[r1,#0]
00003e  8b03              LDRH     r3,[r0,#0x18]
000040  808b              STRH     r3,[r1,#4]
;;;1740   		fno->ftime = LD_WORD(dir + DIR_WrtTime);	/* Time */
000042  8ac0              LDRH     r0,[r0,#0x16]
000044  80c8              STRH     r0,[r1,#6]
                  |L36.70|
;;;1741   	}
;;;1742   	*p = 0;		/* Terminate SFN string by a \0 */
000046  2000              MOVS     r0,#0
000048  7010              STRB     r0,[r2,#0]
;;;1743   
;;;1744   #if _USE_LFN
;;;1745   	if (fno->lfname) {
;;;1746   		i = 0; p = fno->lfname;
;;;1747   		if (dp->sect && fno->lfsize && dp->lfn_idx != 0xFFFF) {	/* Get LFN if available */
;;;1748   			lfn = dp->lfn;
;;;1749   			while ((w = *lfn++) != 0) {		/* Get an LFN character */
;;;1750   #if !_LFN_UNICODE
;;;1751   				w = ff_convert(w, 0);		/* Unicode -> OEM */
;;;1752   				if (!w) { i = 0; break; }	/* No LFN if it could not be converted */
;;;1753   				if (_DF1S && w >= 0x100)	/* Put 1st byte if it is a DBC (always false on SBCS cfg) */
;;;1754   					p[i++] = (TCHAR)(w >> 8);
;;;1755   #endif
;;;1756   				if (i >= fno->lfsize - 1) { i = 0; break; }	/* No LFN if buffer overflow */
;;;1757   				p[i++] = (TCHAR)w;
;;;1758   			}
;;;1759   		}
;;;1760   		p[i] = 0;	/* Terminate LFN string by a \0 */
;;;1761   	}
;;;1762   #endif
;;;1763   }
00004a  bd30              POP      {r4,r5,pc}
;;;1764   #endif /* _FS_MINIMIZE <= 1 || _FS_RPATH >= 2 */
                          ENDP


                          AREA ||i.get_ldnumber||, CODE, READONLY, ALIGN=1

                  get_ldnumber PROC
;;;2114   static
;;;2115   int get_ldnumber (		/* Returns logical drive number (-1:invalid drive) */
000000  b510              PUSH     {r4,lr}
;;;2116   	const TCHAR** path	/* Pointer to pointer to the path name */
;;;2117   )
;;;2118   {
000002  4604              MOV      r4,r0
;;;2119   	const TCHAR *tp, *tt;
;;;2120   	UINT i;
;;;2121   	int vol = -1;
000004  f04f30ff          MOV      r0,#0xffffffff
000008  6822              LDR      r2,[r4,#0]            ;2118
00000a  2a00              CMP      r2,#0                 ;2118
00000c  d013              BEQ      |L37.54|
00000e  4611              MOV      r1,r2                 ;2118
;;;2122   #if _STR_VOLUME_ID		/* Find string drive id */
;;;2123   	static const char* const str[] = {_VOLUME_STRS};
;;;2124   	const char *sp;
;;;2125   	char c;
;;;2126   	TCHAR tc;
;;;2127   #endif
;;;2128   
;;;2129   
;;;2130   	if (*path) {	/* If the pointer is not a null */
;;;2131   		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
000010  e000              B        |L37.20|
                  |L37.18|
000012  1c49              ADDS     r1,r1,#1
                  |L37.20|
000014  780b              LDRB     r3,[r1,#0]
000016  2b21              CMP      r3,#0x21
000018  d30e              BCC      |L37.56|
00001a  2b3a              CMP      r3,#0x3a
00001c  d1f9              BNE      |L37.18|
;;;2132   		if (*tt == ':') {	/* If a ':' is exist in the path name */
;;;2133   			tp = *path;
;;;2134   			i = *tp++ - '0'; 
00001e  f8123b01          LDRB     r3,[r2],#1
000022  3b30              SUBS     r3,r3,#0x30
;;;2135   			if (i < 10 && tp == tt) {	/* Is there a numeric drive id? */
000024  2b0a              CMP      r3,#0xa
000026  d206              BCS      |L37.54|
000028  428a              CMP      r2,r1
00002a  d104              BNE      |L37.54|
;;;2136   				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
00002c  2b00              CMP      r3,#0
00002e  d102              BNE      |L37.54|
;;;2137   					vol = (int)i;
000030  1c49              ADDS     r1,r1,#1
000032  4618              MOV      r0,r3
;;;2138   					*path = ++tt;
000034  6021              STR      r1,[r4,#0]
                  |L37.54|
;;;2139   				}
;;;2140   			}
;;;2141   #if _STR_VOLUME_ID
;;;2142   			 else {	/* No numeric drive number, find string drive id */
;;;2143   				i = 0; tt++;
;;;2144   				do {
;;;2145   					sp = str[i]; tp = *path;
;;;2146   					do {	/* Compare a string drive id with path name */
;;;2147   						c = *sp++; tc = *tp++;
;;;2148   						if (IsLower(tc)) tc -= 0x20;
;;;2149   					} while (c && (TCHAR)c == tc);
;;;2150   				} while ((c || tp != tt) && ++i < _VOLUMES);	/* Repeat for each id until pattern match */
;;;2151   				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
;;;2152   					vol = (int)i;
;;;2153   					*path = tt;
;;;2154   				}
;;;2155   			}
;;;2156   #endif
;;;2157   			return vol;
;;;2158   		}
;;;2159   #if _FS_RPATH && _VOLUMES >= 2
;;;2160   		vol = CurrVol;	/* Current drive */
;;;2161   #else
;;;2162   		vol = 0;		/* Drive 0 */
;;;2163   #endif
;;;2164   	}
;;;2165   	return vol;
;;;2166   }
000036  bd10              POP      {r4,pc}
                  |L37.56|
000038  2000              MOVS     r0,#0                 ;2162
00003a  bd10              POP      {r4,pc}
;;;2167   
                          ENDP


                          AREA ||i.ld_clust||, CODE, READONLY, ALIGN=1

                  ld_clust PROC
;;;1235   static
;;;1236   DWORD ld_clust (	/* Returns the top cluster value of the SFN entry */
000000  4602              MOV      r2,r0
;;;1237   	FATFS* fs,		/* Pointer to the fs object */
;;;1238   	const BYTE* dir	/* Pointer to the SFN entry */
;;;1239   )
;;;1240   {
;;;1241   	DWORD cl;
;;;1242   
;;;1243   	cl = LD_WORD(dir + DIR_FstClusLO);
000002  8b48              LDRH     r0,[r1,#0x1a]
;;;1244   	if (fs->fs_type == FS_FAT32)
000004  7812              LDRB     r2,[r2,#0]
000006  2a03              CMP      r2,#3
000008  d102              BNE      |L38.16|
;;;1245   		cl |= (DWORD)LD_WORD(dir + DIR_FstClusHI) << 16;
00000a  8a89              LDRH     r1,[r1,#0x14]
00000c  ea404001          ORR      r0,r0,r1,LSL #16
                  |L38.16|
;;;1246   
;;;1247   	return cl;
;;;1248   }
000010  4770              BX       lr
;;;1249   
                          ENDP


                          AREA ||i.mem_cpy||, CODE, READONLY, ALIGN=2

                  mem_cpy PROC
;;;507    static
;;;508    void mem_cpy (void* dst, const void* src, UINT cnt) {
000000  e004              B        |L39.12|
;;;509    	BYTE *d = (BYTE*)dst;
;;;510    	const BYTE *s = (const BYTE*)src;
;;;511    
;;;512    #if _WORD_ACCESS == 1
;;;513    	while (cnt >= sizeof (int)) {
;;;514    		*(int*)d = *(int*)s;
;;;515    		d += sizeof (int); s += sizeof (int);
;;;516    		cnt -= sizeof (int);
;;;517    	}
;;;518    #endif
;;;519    	while (cnt--)
;;;520    		*d++ = *s++;
000002  bf00              NOP      
                  |L39.4|
000004  f8113b01          LDRB     r3,[r1],#1
000008  f8003b01          STRB     r3,[r0],#1
                  |L39.12|
00000c  1e52              SUBS     r2,r2,#1
00000e  d2f9              BCS      |L39.4|
;;;521    }
000010  4770              BX       lr
;;;522    
                          ENDP


                          AREA ||i.mem_set||, CODE, READONLY, ALIGN=1

                  mem_set PROC
;;;524    static
;;;525    void mem_set (void* dst, int val, UINT cnt) {
000000  b2c9              UXTB     r1,r1
000002  e001              B        |L40.8|
                  |L40.4|
;;;526    	BYTE *d = (BYTE*)dst;
;;;527    
;;;528    	while (cnt--)
;;;529    		*d++ = (BYTE)val;
000004  f8001b01          STRB     r1,[r0],#1
                  |L40.8|
000008  1e52              SUBS     r2,r2,#1
00000a  d2fb              BCS      |L40.4|
;;;530    }
00000c  4770              BX       lr
;;;531    
                          ENDP


                          AREA ||i.move_window||, CODE, READONLY, ALIGN=1

                  move_window PROC
;;;729    static
;;;730    FRESULT move_window (	/* FR_OK(0):succeeded, !=0:error */
000000  b570              PUSH     {r4-r6,lr}
;;;731    	FATFS* fs,		/* File system object */
;;;732    	DWORD sector	/* Sector number to make appearance in the fs->win[] */
;;;733    )
;;;734    {
000002  4604              MOV      r4,r0
;;;735    	FRESULT res = FR_OK;
;;;736    
;;;737    
;;;738    	if (sector != fs->winsect) {	/* Window offset changed? */
000004  6ac0              LDR      r0,[r0,#0x2c]
000006  460d              MOV      r5,r1                 ;734
000008  2600              MOVS     r6,#0                 ;735
00000a  42a8              CMP      r0,r5
00000c  d00f              BEQ      |L41.46|
;;;739    #if !_FS_READONLY
;;;740    		res = sync_window(fs);		/* Write-back changes */
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       sync_window
000014  0006              MOVS     r6,r0
;;;741    #endif
;;;742    		if (res == FR_OK) {			/* Fill sector window with new data */
000016  d10a              BNE      |L41.46|
;;;743    			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
000018  7860              LDRB     r0,[r4,#1]
00001a  2301              MOVS     r3,#1
00001c  462a              MOV      r2,r5
00001e  f1040130          ADD      r1,r4,#0x30
000022  f7fffffe          BL       disk_read
000026  b108              CBZ      r0,|L41.44|
;;;744    				sector = 0xFFFFFFFF;	/* Invalidate window if data is not reliable */
000028  1e75              SUBS     r5,r6,#1
;;;745    				res = FR_DISK_ERR;
00002a  2601              MOVS     r6,#1
                  |L41.44|
;;;746    			}
;;;747    			fs->winsect = sector;
00002c  62e5              STR      r5,[r4,#0x2c]
                  |L41.46|
;;;748    		}
;;;749    	}
;;;750    	return res;
00002e  4630              MOV      r0,r6
;;;751    }
000030  bd70              POP      {r4-r6,pc}
;;;752    
                          ENDP


                          AREA ||i.put_fat||, CODE, READONLY, ALIGN=1

                  put_fat PROC
;;;873    #if !_FS_READONLY
;;;874    FRESULT put_fat (	/* FR_OK(0):succeeded, !=0:error */
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;875    	FATFS* fs,		/* File system object */
;;;876    	DWORD clst,		/* FAT index number (cluster number) to be changed */
;;;877    	DWORD val		/* New value to be set to the entry */
;;;878    )
;;;879    {
000004  4617              MOV      r7,r2
000006  460d              MOV      r5,r1
000008  4604              MOV      r4,r0
;;;880    	UINT bc;
;;;881    	BYTE *p;
;;;882    	FRESULT res;
;;;883    
;;;884    
;;;885    	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
00000a  2902              CMP      r1,#2
00000c  d302              BCC      |L42.20|
00000e  6960              LDR      r0,[r4,#0x14]
000010  42a8              CMP      r0,r5
000012  d802              BHI      |L42.26|
                  |L42.20|
;;;886    		res = FR_INT_ERR;
000014  2002              MOVS     r0,#2
                  |L42.22|
;;;887    
;;;888    	} else {
;;;889    		switch (fs->fs_type) {
;;;890    		case FS_FAT12 :
;;;891    			bc = (UINT)clst; bc += bc / 2;
;;;892    			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
;;;893    			if (res != FR_OK) break;
;;;894    			p = &fs->win[bc++ % SS(fs)];
;;;895    			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
;;;896    			fs->wflag = 1;
;;;897    			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
;;;898    			if (res != FR_OK) break;
;;;899    			p = &fs->win[bc % SS(fs)];
;;;900    			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
;;;901    			fs->wflag = 1;
;;;902    			break;
;;;903    
;;;904    		case FS_FAT16 :
;;;905    			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
;;;906    			if (res != FR_OK) break;
;;;907    			p = &fs->win[clst * 2 % SS(fs)];
;;;908    			ST_WORD(p, (WORD)val);
;;;909    			fs->wflag = 1;
;;;910    			break;
;;;911    
;;;912    		case FS_FAT32 :
;;;913    			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
;;;914    			if (res != FR_OK) break;
;;;915    			p = &fs->win[clst * 4 % SS(fs)];
;;;916    			val |= LD_DWORD(p) & 0xF0000000;
;;;917    			ST_DWORD(p, val);
;;;918    			fs->wflag = 1;
;;;919    			break;
;;;920    
;;;921    		default :
;;;922    			res = FR_INT_ERR;
;;;923    		}
;;;924    	}
;;;925    
;;;926    	return res;
;;;927    }
000016  e8bd87f0          POP      {r4-r10,pc}
                  |L42.26|
00001a  7821              LDRB     r1,[r4,#0]            ;889
00001c  f00708ff          AND      r8,r7,#0xff           ;895
000020  f04f0901          MOV      r9,#1                 ;889
000024  2901              CMP      r1,#1                 ;889
000026  d020              BEQ      |L42.106|
000028  2902              CMP      r1,#2                 ;889
00002a  d050              BEQ      |L42.206|
00002c  2903              CMP      r1,#3                 ;889
00002e  d1f1              BNE      |L42.20|
000030  6a20              LDR      r0,[r4,#0x20]         ;913
000032  eb0011d5          ADD      r1,r0,r5,LSR #7       ;913
000036  4620              MOV      r0,r4                 ;913
000038  f7fffffe          BL       move_window
00003c  2800              CMP      r0,#0                 ;914
00003e  d1ea              BNE      |L42.22|
000040  f24011ff          MOV      r1,#0x1ff             ;915
000044  ea010185          AND      r1,r1,r5,LSL #2       ;915
000048  190a              ADDS     r2,r1,r4              ;915
00004a  f04f4370          MOV      r3,#0xf0000000        ;916
00004e  f8d21031          LDR      r1,[r2,#0x31]         ;916
000052  ea032101          AND      r1,r3,r1,LSL #8       ;916
000056  4339              ORRS     r1,r1,r7              ;916
000058  f8021f30          STRB     r1,[r2,#0x30]!        ;917
00005c  0a0b              LSRS     r3,r1,#8              ;917
00005e  7053              STRB     r3,[r2,#1]            ;917
000060  0c0b              LSRS     r3,r1,#16             ;917
000062  7093              STRB     r3,[r2,#2]            ;917
000064  0e09              LSRS     r1,r1,#24             ;917
000066  70d1              STRB     r1,[r2,#3]            ;917
000068  e041              B        |L42.238|
                  |L42.106|
00006a  6a20              LDR      r0,[r4,#0x20]         ;892
00006c  eb050655          ADD      r6,r5,r5,LSR #1       ;891
000070  eb002156          ADD      r1,r0,r6,LSR #9       ;892
000074  4620              MOV      r0,r4                 ;892
000076  f7fffffe          BL       move_window
00007a  2800              CMP      r0,#0                 ;893
00007c  d1cb              BNE      |L42.22|
00007e  f3c60008          UBFX     r0,r6,#0,#9           ;894
000082  4420              ADD      r0,r0,r4              ;894
000084  3030              ADDS     r0,r0,#0x30           ;894
000086  1c76              ADDS     r6,r6,#1              ;894
000088  07e9              LSLS     r1,r5,#31             ;895
00008a  d003              BEQ      |L42.148|
00008c  7801              LDRB     r1,[r0,#0]            ;895
00008e  f368111f          BFI      r1,r8,#4,#28          ;895
000092  e000              B        |L42.150|
                  |L42.148|
000094  4639              MOV      r1,r7                 ;895
                  |L42.150|
000096  7001              STRB     r1,[r0,#0]            ;895
000098  f8849004          STRB     r9,[r4,#4]            ;896
00009c  6a20              LDR      r0,[r4,#0x20]         ;897
00009e  eb002156          ADD      r1,r0,r6,LSR #9       ;897
0000a2  4620              MOV      r0,r4                 ;897
0000a4  f7fffffe          BL       move_window
0000a8  2800              CMP      r0,#0                 ;898
0000aa  d1b4              BNE      |L42.22|
0000ac  f3c60108          UBFX     r1,r6,#0,#9           ;899
0000b0  4421              ADD      r1,r1,r4              ;899
0000b2  3130              ADDS     r1,r1,#0x30           ;899
0000b4  07ea              LSLS     r2,r5,#31             ;900
0000b6  d002              BEQ      |L42.190|
0000b8  f3c71207          UBFX     r2,r7,#4,#8           ;900
0000bc  e005              B        |L42.202|
                  |L42.190|
0000be  780a              LDRB     r2,[r1,#0]            ;900
0000c0  f3c72303          UBFX     r3,r7,#8,#4           ;900
0000c4  f00202f0          AND      r2,r2,#0xf0           ;900
0000c8  431a              ORRS     r2,r2,r3              ;900
                  |L42.202|
0000ca  700a              STRB     r2,[r1,#0]            ;900
0000cc  e00f              B        |L42.238|
                  |L42.206|
0000ce  6a20              LDR      r0,[r4,#0x20]         ;905
0000d0  eb002115          ADD      r1,r0,r5,LSR #8       ;905
0000d4  4620              MOV      r0,r4                 ;905
0000d6  f7fffffe          BL       move_window
0000da  2800              CMP      r0,#0                 ;906
0000dc  d19b              BNE      |L42.22|
0000de  b2e9              UXTB     r1,r5                 ;907
0000e0  eb040141          ADD      r1,r4,r1,LSL #1       ;907
0000e4  0a3a              LSRS     r2,r7,#8              ;908
0000e6  f8818030          STRB     r8,[r1,#0x30]         ;908
0000ea  f8812031          STRB     r2,[r1,#0x31]         ;908
                  |L42.238|
0000ee  f8849004          STRB     r9,[r4,#4]            ;901
0000f2  e790              B        |L42.22|
;;;928    #endif /* !_FS_READONLY */
                          ENDP


                          AREA ||i.putc_bfd||, CODE, READONLY, ALIGN=1

                  putc_bfd PROC
;;;4483   static
;;;4484   void putc_bfd (
000000  b5f8              PUSH     {r3-r7,lr}
;;;4485   	putbuff* pb,
;;;4486   	TCHAR c
;;;4487   )
;;;4488   {
000002  460e              MOV      r6,r1
000004  4604              MOV      r4,r0
;;;4489   	UINT bw;
;;;4490   	int i;
;;;4491   
;;;4492   
;;;4493   	if (_USE_STRFUNC == 2 && c == '\n')	 /* LF -> CRLF conversion */
000006  290a              CMP      r1,#0xa
000008  d102              BNE      |L43.16|
;;;4494   		putc_bfd(pb, '\r');
00000a  210d              MOVS     r1,#0xd
00000c  f7fffffe          BL       putc_bfd
                  |L43.16|
;;;4495   
;;;4496   	i = pb->idx;	/* Buffer write index (-1:error) */
;;;4497   	if (i < 0) return;
000010  6865              LDR      r5,[r4,#4]
000012  2d00              CMP      r5,#0
000014  db16              BLT      |L43.68|
;;;4498   
;;;4499   #if _USE_LFN && _LFN_UNICODE
;;;4500   #if _STRF_ENCODE == 3			/* Write a character in UTF-8 */
;;;4501   	if (c < 0x80) {				/* 7-bit */
;;;4502   		pb->buf[i++] = (BYTE)c;
;;;4503   	} else {
;;;4504   		if (c < 0x800) {		/* 11-bit */
;;;4505   			pb->buf[i++] = (BYTE)(0xC0 | c >> 6);
;;;4506   		} else {				/* 16-bit */
;;;4507   			pb->buf[i++] = (BYTE)(0xE0 | c >> 12);
;;;4508   			pb->buf[i++] = (BYTE)(0x80 | (c >> 6 & 0x3F));
;;;4509   		}
;;;4510   		pb->buf[i++] = (BYTE)(0x80 | (c & 0x3F));
;;;4511   	}
;;;4512   #elif _STRF_ENCODE == 2			/* Write a character in UTF-16BE */
;;;4513   	pb->buf[i++] = (BYTE)(c >> 8);
;;;4514   	pb->buf[i++] = (BYTE)c;
;;;4515   #elif _STRF_ENCODE == 1			/* Write a character in UTF-16LE */
;;;4516   	pb->buf[i++] = (BYTE)c;
;;;4517   	pb->buf[i++] = (BYTE)(c >> 8);
;;;4518   #else							/* Write a character in ANSI/OEM */
;;;4519   	c = ff_convert(c, 0);	/* Unicode -> OEM */
;;;4520   	if (!c) c = '?';
;;;4521   	if (c >= 0x100)
;;;4522   		pb->buf[i++] = (BYTE)(c >> 8);
;;;4523   	pb->buf[i++] = (BYTE)c;
;;;4524   #endif
;;;4525   #else							/* Write a character without conversion */
;;;4526   	pb->buf[i++] = (BYTE)c;
000016  1960              ADDS     r0,r4,r5
000018  1c6d              ADDS     r5,r5,#1
00001a  7306              STRB     r6,[r0,#0xc]
;;;4527   #endif
;;;4528   
;;;4529   	if (i >= (int)(sizeof pb->buf) - 3) {	/* Write buffered characters to the file */
00001c  2d3d              CMP      r5,#0x3d
00001e  db0d              BLT      |L43.60|
;;;4530   		f_write(pb->fp, pb->buf, (UINT)i, &bw);
000020  466b              MOV      r3,sp
000022  462a              MOV      r2,r5
000024  f104010c          ADD      r1,r4,#0xc
000028  6820              LDR      r0,[r4,#0]
00002a  f7fffffe          BL       f_write
;;;4531   		i = (bw == (UINT)i) ? 0 : -1;
00002e  9800              LDR      r0,[sp,#0]
000030  42a8              CMP      r0,r5
000032  d101              BNE      |L43.56|
000034  2500              MOVS     r5,#0
000036  e001              B        |L43.60|
                  |L43.56|
000038  f04f35ff          MOV      r5,#0xffffffff
                  |L43.60|
;;;4532   	}
;;;4533   	pb->idx = i;
;;;4534   	pb->nchr++;
00003c  6065              STR      r5,[r4,#4]
00003e  68a0              LDR      r0,[r4,#8]
000040  1c40              ADDS     r0,r0,#1
000042  60a0              STR      r0,[r4,#8]
                  |L43.68|
;;;4535   }
000044  bdf8              POP      {r3-r7,pc}
;;;4536   
                          ENDP


                          AREA ||i.remove_chain||, CODE, READONLY, ALIGN=1

                  remove_chain PROC
;;;937    static
;;;938    FRESULT remove_chain (	/* FR_OK(0):succeeded, !=0:error */
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;939    	FATFS* fs,			/* File system object */
;;;940    	DWORD clst			/* Cluster# to remove a chain from */
;;;941    )
;;;942    {
000004  460f              MOV      r7,r1
000006  4606              MOV      r6,r0
;;;943    	FRESULT res;
;;;944    	DWORD nxt;
;;;945    #if _USE_TRIM
;;;946    	DWORD scl = clst, ecl = clst, rt[2];
;;;947    #endif
;;;948    
;;;949    	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
000008  2902              CMP      r1,#2
00000a  d316              BCC      |L44.58|
00000c  6970              LDR      r0,[r6,#0x14]
00000e  42b8              CMP      r0,r7
000010  d913              BLS      |L44.58|
;;;950    		res = FR_INT_ERR;
;;;951    
;;;952    	} else {
;;;953    		res = FR_OK;
000012  2500              MOVS     r5,#0
;;;954    		while (clst < fs->n_fatent) {			/* Not a last link? */
000014  e01f              B        |L44.86|
                  |L44.22|
;;;955    			nxt = get_fat(fs, clst);			/* Get cluster status */
000016  4639              MOV      r1,r7
000018  4630              MOV      r0,r6
00001a  f7fffffe          BL       get_fat
00001e  0004              MOVS     r4,r0
;;;956    			if (nxt == 0) break;				/* Empty cluster? */
000020  d01c              BEQ      |L44.92|
;;;957    			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
000022  2c01              CMP      r4,#1
000024  d009              BEQ      |L44.58|
;;;958    			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
000026  1c60              ADDS     r0,r4,#1
000028  d009              BEQ      |L44.62|
;;;959    			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
00002a  2200              MOVS     r2,#0
00002c  4639              MOV      r1,r7
00002e  4630              MOV      r0,r6
000030  f7fffffe          BL       put_fat
000034  0005              MOVS     r5,r0
;;;960    			if (res != FR_OK) break;
000036  d111              BNE      |L44.92|
000038  e003              B        |L44.66|
                  |L44.58|
00003a  2502              MOVS     r5,#2                 ;957
00003c  e00e              B        |L44.92|
                  |L44.62|
00003e  2501              MOVS     r5,#1                 ;958
000040  e00c              B        |L44.92|
                  |L44.66|
;;;961    			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSINFO */
000042  6930              LDR      r0,[r6,#0x10]
000044  1c41              ADDS     r1,r0,#1
000046  d005              BEQ      |L44.84|
000048  1c40              ADDS     r0,r0,#1
;;;962    				fs->free_clust++;
;;;963    				fs->fsi_flag |= 1;
00004a  6130              STR      r0,[r6,#0x10]
00004c  7970              LDRB     r0,[r6,#5]
00004e  f0400001          ORR      r0,r0,#1
000052  7170              STRB     r0,[r6,#5]
                  |L44.84|
;;;964    			}
;;;965    #if _USE_TRIM
;;;966    			if (ecl + 1 == nxt) {	/* Is next cluster contiguous? */
;;;967    				ecl = nxt;
;;;968    			} else {				/* End of contiguous clusters */ 
;;;969    				rt[0] = clust2sect(fs, scl);					/* Start sector */
;;;970    				rt[1] = clust2sect(fs, ecl) + fs->csize - 1;	/* End sector */
;;;971    				disk_ioctl(fs->drv, CTRL_TRIM, rt);				/* Erase the block */
;;;972    				scl = ecl = nxt;
;;;973    			}
;;;974    #endif
;;;975    			clst = nxt;	/* Next cluster */
000054  4627              MOV      r7,r4
                  |L44.86|
000056  6970              LDR      r0,[r6,#0x14]         ;954
000058  42b8              CMP      r0,r7                 ;954
00005a  d8dc              BHI      |L44.22|
                  |L44.92|
;;;976    		}
;;;977    	}
;;;978    
;;;979    	return res;
00005c  4628              MOV      r0,r5
;;;980    }
00005e  e8bd81f0          POP      {r4-r8,pc}
;;;981    #endif
                          ENDP


                          AREA ||i.st_clust||, CODE, READONLY, ALIGN=1

                  st_clust PROC
;;;1252   static
;;;1253   void st_clust (
000000  7681              STRB     r1,[r0,#0x1a]
;;;1254   	BYTE* dir,	/* Pointer to the SFN entry */
;;;1255   	DWORD cl	/* Value to be set */
;;;1256   )
;;;1257   {
;;;1258   	ST_WORD(dir + DIR_FstClusLO, cl);
000002  0a0a              LSRS     r2,r1,#8
000004  76c2              STRB     r2,[r0,#0x1b]
;;;1259   	ST_WORD(dir + DIR_FstClusHI, cl >> 16);
000006  0c0a              LSRS     r2,r1,#16
000008  7502              STRB     r2,[r0,#0x14]
00000a  0e09              LSRS     r1,r1,#24
00000c  7541              STRB     r1,[r0,#0x15]
;;;1260   }
00000e  4770              BX       lr
;;;1261   #endif
                          ENDP


                          AREA ||i.sync_fs||, CODE, READONLY, ALIGN=1

                  sync_fs PROC
;;;760    static
;;;761    FRESULT sync_fs (	/* FR_OK:succeeded, !=0:error */
000000  b570              PUSH     {r4-r6,lr}
;;;762    	FATFS* fs		/* File system object */
;;;763    )
;;;764    {
000002  4604              MOV      r4,r0
;;;765    	FRESULT res;
;;;766    
;;;767    
;;;768    	res = sync_window(fs);
000004  f7fffffe          BL       sync_window
000008  0005              MOVS     r5,r0
;;;769    	if (res == FR_OK) {
00000a  d14f              BNE      |L46.172|
;;;770    		/* Update FSInfo sector if needed */
;;;771    		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
00000c  7820              LDRB     r0,[r4,#0]
00000e  2803              CMP      r0,#3
000010  d145              BNE      |L46.158|
000012  7960              LDRB     r0,[r4,#5]
000014  2801              CMP      r0,#1
000016  d142              BNE      |L46.158|
;;;772    			/* Create FSInfo structure */
;;;773    			mem_set(fs->win, 0, SS(fs));
000018  0242              LSLS     r2,r0,#9
00001a  f1040030          ADD      r0,r4,#0x30
00001e  2100              MOVS     r1,#0
000020  4606              MOV      r6,r0
000022  f7fffffe          BL       mem_set
;;;774    			ST_WORD(fs->win + BS_55AA, 0xAA55);
000026  2055              MOVS     r0,#0x55
000028  f884022e          STRB     r0,[r4,#0x22e]
00002c  20aa              MOVS     r0,#0xaa
00002e  f884022f          STRB     r0,[r4,#0x22f]
;;;775    			ST_DWORD(fs->win + FSI_LeadSig, 0x41615252);
000032  2052              MOVS     r0,#0x52
000034  f8840030          STRB     r0,[r4,#0x30]
000038  f8840031          STRB     r0,[r4,#0x31]
00003c  2061              MOVS     r0,#0x61
00003e  f8840032          STRB     r0,[r4,#0x32]
000042  2141              MOVS     r1,#0x41
000044  f8841033          STRB     r1,[r4,#0x33]
;;;776    			ST_DWORD(fs->win + FSI_StrucSig, 0x61417272);
000048  2272              MOVS     r2,#0x72
00004a  f8842214          STRB     r2,[r4,#0x214]
00004e  f8842215          STRB     r2,[r4,#0x215]
000052  f8841216          STRB     r1,[r4,#0x216]
000056  f8840217          STRB     r0,[r4,#0x217]
;;;777    			ST_DWORD(fs->win + FSI_Free_Count, fs->free_clust);
00005a  6920              LDR      r0,[r4,#0x10]
00005c  f8840218          STRB     r0,[r4,#0x218]
000060  0a01              LSRS     r1,r0,#8
000062  f8841219          STRB     r1,[r4,#0x219]
000066  0c01              LSRS     r1,r0,#16
000068  f884121a          STRB     r1,[r4,#0x21a]
00006c  0e00              LSRS     r0,r0,#24
00006e  f884021b          STRB     r0,[r4,#0x21b]
;;;778    			ST_DWORD(fs->win + FSI_Nxt_Free, fs->last_clust);
000072  68e0              LDR      r0,[r4,#0xc]
000074  f884021c          STRB     r0,[r4,#0x21c]
000078  0a01              LSRS     r1,r0,#8
00007a  f884121d          STRB     r1,[r4,#0x21d]
00007e  0c01              LSRS     r1,r0,#16
000080  f884121e          STRB     r1,[r4,#0x21e]
000084  0e00              LSRS     r0,r0,#24
000086  f884021f          STRB     r0,[r4,#0x21f]
;;;779    			/* Write it into the FSInfo sector */
;;;780    			fs->winsect = fs->volbase + 1;
00008a  69e2              LDR      r2,[r4,#0x1c]
;;;781    			disk_write(fs->drv, fs->win, fs->winsect, 1);
00008c  2301              MOVS     r3,#1
00008e  1c52              ADDS     r2,r2,#1              ;780
000090  62e2              STR      r2,[r4,#0x2c]
000092  7860              LDRB     r0,[r4,#1]
000094  4631              MOV      r1,r6
000096  f7fffffe          BL       disk_write
;;;782    			fs->fsi_flag = 0;
00009a  2000              MOVS     r0,#0
00009c  7160              STRB     r0,[r4,#5]
                  |L46.158|
;;;783    		}
;;;784    		/* Make sure that no pending write process in the physical drive */
;;;785    		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
00009e  2200              MOVS     r2,#0
0000a0  7860              LDRB     r0,[r4,#1]
0000a2  4611              MOV      r1,r2
0000a4  f7fffffe          BL       disk_ioctl
0000a8  b100              CBZ      r0,|L46.172|
;;;786    			res = FR_DISK_ERR;
0000aa  2501              MOVS     r5,#1
                  |L46.172|
;;;787    	}
;;;788    
;;;789    	return res;
0000ac  4628              MOV      r0,r5
;;;790    }
0000ae  bd70              POP      {r4-r6,pc}
;;;791    #endif
                          ENDP


                          AREA ||i.sync_window||, CODE, READONLY, ALIGN=1

                  sync_window PROC
;;;700    static
;;;701    FRESULT sync_window (	/* FR_OK:succeeded, !=0:error */
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;702    	FATFS* fs		/* File system object */
;;;703    )
;;;704    {
000004  4604              MOV      r4,r0
;;;705    	DWORD wsect;
;;;706    	UINT nf;
;;;707    	FRESULT res = FR_OK;
;;;708    
;;;709    
;;;710    	if (fs->wflag) {	/* Write back the sector if it is dirty */
000006  7900              LDRB     r0,[r0,#4]
000008  2700              MOVS     r7,#0                 ;707
00000a  b1f8              CBZ      r0,|L47.76|
;;;711    		wsect = fs->winsect;	/* Current sector number */
;;;712    		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
00000c  6ae5              LDR      r5,[r4,#0x2c]
00000e  f1040130          ADD      r1,r4,#0x30
000012  7860              LDRB     r0,[r4,#1]
000014  2301              MOVS     r3,#1
000016  462a              MOV      r2,r5
000018  4688              MOV      r8,r1
00001a  f7fffffe          BL       disk_write
00001e  b108              CBZ      r0,|L47.36|
;;;713    			res = FR_DISK_ERR;
000020  2701              MOVS     r7,#1
000022  e013              B        |L47.76|
                  |L47.36|
;;;714    		} else {
;;;715    			fs->wflag = 0;
000024  2000              MOVS     r0,#0
000026  7120              STRB     r0,[r4,#4]
;;;716    			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
000028  6a20              LDR      r0,[r4,#0x20]
00002a  69a1              LDR      r1,[r4,#0x18]
00002c  1a28              SUBS     r0,r5,r0
00002e  4288              CMP      r0,r1
000030  d20c              BCS      |L47.76|
;;;717    				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
000032  78e6              LDRB     r6,[r4,#3]
000034  e008              B        |L47.72|
                  |L47.54|
;;;718    					wsect += fs->fsize;
000036  69a0              LDR      r0,[r4,#0x18]
;;;719    					disk_write(fs->drv, fs->win, wsect, 1);
000038  2301              MOVS     r3,#1
00003a  4405              ADD      r5,r5,r0              ;718
00003c  7860              LDRB     r0,[r4,#1]
00003e  462a              MOV      r2,r5
000040  4641              MOV      r1,r8
000042  f7fffffe          BL       disk_write
000046  1e76              SUBS     r6,r6,#1
                  |L47.72|
000048  2e02              CMP      r6,#2                 ;717
00004a  d2f4              BCS      |L47.54|
                  |L47.76|
;;;720    				}
;;;721    			}
;;;722    		}
;;;723    	}
;;;724    	return res;
00004c  4638              MOV      r0,r7
;;;725    }
00004e  e8bd81f0          POP      {r4-r8,pc}
;;;726    #endif
                          ENDP


                          AREA ||i.validate||, CODE, READONLY, ALIGN=1

                  validate PROC
;;;2373   static
;;;2374   FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
000000  b510              PUSH     {r4,lr}
;;;2375   	void* obj		/* Pointer to the object FIL/DIR to check validity */
;;;2376   )
;;;2377   {
000002  b160              CBZ      r0,|L48.30|
;;;2378   	FIL *fil = (FIL*)obj;	/* Assuming offset of .fs and .id in the FIL/DIR structure is identical */
;;;2379       
;;;2380       //v1000_debug("fil :%x,fil-fs:%x,fs_type :%x,%x,%x\r\n",fil,fil->fs,fil->fs->fs_type,fil->fs->id ,fil->id);
;;;2381       //v1000_debug("fil %x , status :%x \r\n",fil->fs->drv,disk_status(fil->fs->drv));
;;;2382   
;;;2383   	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id || (disk_status(fil->fs->drv) & STA_NOINIT))
000004  6801              LDR      r1,[r0,#0]
000006  b151              CBZ      r1,|L48.30|
000008  780a              LDRB     r2,[r1,#0]
00000a  b142              CBZ      r2,|L48.30|
00000c  88ca              LDRH     r2,[r1,#6]
00000e  8880              LDRH     r0,[r0,#4]
000010  4282              CMP      r2,r0
000012  d104              BNE      |L48.30|
000014  7848              LDRB     r0,[r1,#1]
000016  f7fffffe          BL       disk_status
00001a  07c0              LSLS     r0,r0,#31
00001c  d000              BEQ      |L48.32|
                  |L48.30|
;;;2384   		return FR_INVALID_OBJECT;
00001e  2009              MOVS     r0,#9
                  |L48.32|
;;;2385   
;;;2386   	ENTER_FF(fil->fs);		/* Lock file system */
;;;2387   
;;;2388   	return FR_OK;
;;;2389   }
000020  bd10              POP      {r4,pc}
;;;2390   
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=1

                  ExCvt
000000  809a4541          DCB      0x80,0x9a,0x45,0x41
000004  8e418f80          DCB      0x8e,0x41,0x8f,0x80
000008  45454549          DCB      0x45,0x45,0x45,0x49
00000c  49498e8f          DCB      0x49,0x49,0x8e,0x8f
000010  9092924f          DCB      0x90,0x92,0x92,0x4f
000014  994f5555          DCB      0x99,0x4f,0x55,0x55
000018  59999a9b          DCB      0x59,0x99,0x9a,0x9b
00001c  9c9d9e9f          DCB      0x9c,0x9d,0x9e,0x9f
000020  41494f55          DCB      0x41,0x49,0x4f,0x55
000024  a5a5a6a7          DCB      0xa5,0xa5,0xa6,0xa7
000028  a8a9aaab          DCB      0xa8,0xa9,0xaa,0xab
00002c  acadaeaf          DCB      0xac,0xad,0xae,0xaf
000030  b0b1b2b3          DCB      0xb0,0xb1,0xb2,0xb3
000034  b4b5b6b7          DCB      0xb4,0xb5,0xb6,0xb7
000038  b8b9babb          DCB      0xb8,0xb9,0xba,0xbb
00003c  bcbdbebf          DCB      0xbc,0xbd,0xbe,0xbf
000040  c0c1c2c3          DCB      0xc0,0xc1,0xc2,0xc3
000044  c4c5c6c7          DCB      0xc4,0xc5,0xc6,0xc7
000048  c8c9cacb          DCB      0xc8,0xc9,0xca,0xcb
00004c  cccdcecf          DCB      0xcc,0xcd,0xce,0xcf
000050  d0d1d2d3          DCB      0xd0,0xd1,0xd2,0xd3
000054  d4d5d6d7          DCB      0xd4,0xd5,0xd6,0xd7
000058  d8d9dadb          DCB      0xd8,0xd9,0xda,0xdb
00005c  dcdddedf          DCB      0xdc,0xdd,0xde,0xdf
000060  e0e1e2e3          DCB      0xe0,0xe1,0xe2,0xe3
000064  e4e5e6e7          DCB      0xe4,0xe5,0xe6,0xe7
000068  e8e9eaeb          DCB      0xe8,0xe9,0xea,0xeb
00006c  ecedeeef          DCB      0xec,0xed,0xee,0xef
000070  f0f1f2f3          DCB      0xf0,0xf1,0xf2,0xf3
000074  f4f5f6f7          DCB      0xf4,0xf5,0xf6,0xf7
000078  f8f9fafb          DCB      0xf8,0xf9,0xfa,0xfb
00007c  fcfdfeff          DCB      0xfc,0xfd,0xfe,0xff
                  vst
000080  04000200          DCW      0x0400,0x0200
000084  01000080          DCW      0x0100,0x0080
000088  00400020          DCW      0x0040,0x0020
00008c  00100008          DCW      0x0010,0x0008
000090  00040002          DCW      0x0004,0x0002
000094  0000              DCW      0x0000
                  ||cst||
000096  8000              DCW      0x8000
000098  40002000          DCW      0x4000,0x2000
00009c  10000800          DCW      0x1000,0x0800
0000a0  40002000          DCW      0x4000,0x2000
0000a4  10000800          DCW      0x1000,0x0800
0000a8  04000200          DCW      0x0400,0x0200

                          AREA ||.data||, DATA, ALIGN=2

                  Fsid
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  FatFs
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\src\\ff11a\\src\\ff.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___4_ff_c_3f41df3e____REV16|
#line 114 "..\\..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___4_ff_c_3f41df3e____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___4_ff_c_3f41df3e____REVSH|
#line 128
|__asm___4_ff_c_3f41df3e____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
