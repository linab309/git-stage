L 1 "..\src\HARDWARE\BMP\bmp280.c"
N/**
N* Copyright (c) 2020 Bosch Sensortec GmbH. All rights reserved.
N*
N* BSD-3-Clause
N*
N* Redistribution and use in source and binary forms, with or without
N* modification, are permitted provided that the following conditions are met:
N*
N* 1. Redistributions of source code must retain the above copyright
N*    notice, this list of conditions and the following disclaimer.
N*
N* 2. Redistributions in binary form must reproduce the above copyright
N*    notice, this list of conditions and the following disclaimer in the
N*    documentation and/or other materials provided with the distribution.
N*
N* 3. Neither the name of the copyright holder nor the names of its
N*    contributors may be used to endorse or promote products derived from
N*    this software without specific prior written permission.
N*
N* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
N* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
N* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
N* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
N* COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
N* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
N* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
N* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
N* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N* POSSIBILITY OF SUCH DAMAGE.
N*
N* @file	bmp280.c
N* @date	2020-01-10
N* @version	v3.3.4
N*
N*/#include "bmp280.h"
L 1 "..\src\HARDWARE\BMP\bmp280.h" 1
N/**
N* Copyright (c) 2020 Bosch Sensortec GmbH. All rights reserved.
N*
N* BSD-3-Clause
N*
N* Redistribution and use in source and binary forms, with or without
N* modification, are permitted provided that the following conditions are met:
N*
N* 1. Redistributions of source code must retain the above copyright
N*    notice, this list of conditions and the following disclaimer.
N*
N* 2. Redistributions in binary form must reproduce the above copyright
N*    notice, this list of conditions and the following disclaimer in the
N*    documentation and/or other materials provided with the distribution.
N*
N* 3. Neither the name of the copyright holder nor the names of its
N*    contributors may be used to endorse or promote products derived from
N*    this software without specific prior written permission.
N*
N* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
N* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
N* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
N* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
N* COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
N* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
N* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
N* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
N* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N* POSSIBILITY OF SUCH DAMAGE.
N*
N* @file	bmp280.h
N* @date	2020-01-10
N* @version	v3.3.4
N*
N*/#ifndef __BMP280_H__
N#define __BMP280_H__
N
N#include "bmp280_defs.h"
L 1 "..\src\HARDWARE\BMP\bmp280_defs.h" 1
N/**
N* Copyright (c) 2020 Bosch Sensortec GmbH. All rights reserved.
N*
N* BSD-3-Clause
N*
N* Redistribution and use in source and binary forms, with or without
N* modification, are permitted provided that the following conditions are met:
N*
N* 1. Redistributions of source code must retain the above copyright
N*    notice, this list of conditions and the following disclaimer.
N*
N* 2. Redistributions in binary form must reproduce the above copyright
N*    notice, this list of conditions and the following disclaimer in the
N*    documentation and/or other materials provided with the distribution.
N*
N* 3. Neither the name of the copyright holder nor the names of its
N*    contributors may be used to endorse or promote products derived from
N*    this software without specific prior written permission.
N*
N* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
N* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
N* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
N* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
N* COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
N* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
N* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
N* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
N* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N* POSSIBILITY OF SUCH DAMAGE.
N*
N* @file	bmp280_defs.h
N* @date	2020-01-10
N* @version	v3.3.4
N*
N*/#ifndef __BMP280_DEFS_H__
N#define __BMP280_DEFS_H__
N
N/*! CPP guard */
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/****************************************************************/
N/*! @name       Header includes             */
N/****************************************************************/
N#ifdef __KERNEL__
S#include <linux/types.h>
S#include <linux/kernel.h>
N#else
N#include <stdint.h>
L 1 "C:\Keil_v5\ARM\ARMCC\bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999 */
N/* All rights reserved */
N
N/*
N * RCS $Revision: 180721 $
N * Checkin $Date: 2013-06-24 09:41:57 +0100 (Mon, 24 Jun 2013) $
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5040049
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N * '__int64' is used instead of 'long long' so that this header
N * can be used in --strict mode.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed       __int64 intmax_t;
Ntypedef unsigned       __int64 uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __ESCAPE__(~0x7fffffffffffffffll) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#define INTPTR_MIN (~0x7fffffff)
N
N    /* maximum value of pointer-holding signed integer type */
N#define INTPTR_MAX   2147483647
N
N    /* maximum value of pointer-holding unsigned integer type */
N#define UINTPTR_MAX  4294967295u
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#define PTRDIFF_MIN (~0x7fffffff)
N#define PTRDIFF_MAX   2147483647
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#define SIZE_MAX 4294967295u
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __ESCAPE__(x ## ll)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __ESCAPE__(x ## ull)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif 
N  #endif /* __cplusplus */
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
N
N
N
L 53 "..\src\HARDWARE\BMP\bmp280_defs.h" 2
N#include <stddef.h>
L 1 "C:\Keil_v5\ARM\ARMCC\bin\..\include\stddef.h" 1
N/* stddef.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.1.4 */
N
N/* Copyright (C) ARM Ltd., 1999
N * All rights reserved
N * RCS $Revision: 180113 $
N * Checkin $Date: 2013-05-22 14:27:44 +0100 (Wed, 22 May 2013) $
N * Revising $Author: agrant $
N */
N
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991 ARM Limited. All rights reserved.             */
N/* version 0.05 */
N
N/*
N * The following types and macros are defined in several headers referred to in
N * the descriptions of the functions declared in that header. They are also
N * defined in this header file.
N */
N
N#ifndef __stddef_h
N#define __stddef_h
N#define __ARMCLIB_VERSION 5040049
N
N  #ifndef __STDDEF_DECLS
N  #define __STDDEF_DECLS
N    #undef __CLIBNS
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS ::std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
Ntypedef signed int ptrdiff_t;
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;
N#elif !defined(__size_t)
S  #define __size_t 1
S  typedef unsigned int size_t;   /* others (e.g. <stdio.h>) also define */
S   /* the unsigned integral type of the result of the sizeof operator. */
N#endif
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N  /* unconditional in non-strict C for consistency of debug info */
N    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X    #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #else
N      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #endif
S   /*
S    * An integral type whose range of values can represent distinct codes for
S    * all members of the largest extended character set specified among the
S    * supported locales; the null character shall have the code value zero and
S    * each member of the basic character set shall have a code value when used
S    * as the lone character in an integer character constant.
S    */
N  #endif
N#endif
N
N#undef NULL  /* others (e.g. <stdio.h>) also define */
N#define NULL 0
N   /* null pointer constant. */
N
N  /* EDG uses __INTADDR__ to avoid errors when strict */
N  #define offsetof(t, memb) ((__CLIBNS size_t)__INTADDR__(&(((t *)0)->memb)))
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDDEF_DECLS */
N
N
N  #ifdef __cplusplus
S    #ifndef __STDDEF_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::ptrdiff_t;
S    #endif 
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of stddef.h */
N
L 54 "..\src\HARDWARE\BMP\bmp280_defs.h" 2
N#endif
N
N/****************************************************************/
N/*! @name       Common macros               */
N/****************************************************************/
N#ifdef __KERNEL__
S#if !defined(UINT8_C) && !defined(INT8_C)
S#define INT8_C(x)   S8_C(x)
S#define UINT8_C(x)  U8_C(x)
S#endif
S
S#if !defined(UINT16_C) && !defined(INT16_C)
S#define INT16_C(x)  S16_C(x)
S#define UINT16_C(x) U16_C(x)
S#endif
S
S#if !defined(INT32_C) && !defined(UINT32_C)
S#define INT32_C(x)  S32_C(x)
S#define UINT32_C(x) U32_C(x)
S#endif
S
S#if !defined(INT64_C) && !defined(UINT64_C)
S#define INT64_C(x)  S64_C(x)
S#define UINT64_C(x) U64_C(x)
S#endif
N#endif
N
N/*! @name C standard macros */
N#ifndef NULL
S#ifdef __cplusplus
S#define NULL 0
S#else
S#define NULL ((void *) 0)
S#endif
N#endif
N
N/****************************************************************/
N/*! @name       BMP280 Macros               */
N/****************************************************************/
N
N/*! @name Macro to disable double precision floating point compensation
N * @note Uncomment the following line to disable it
N */
N#ifndef BMP280_DISABLE_DOUBLE_COMPENSATION
N
N/* #define BMP280_DISABLE_DOUBLE_COMPENSATION */
N#endif
N
N/*! @name Macro to disable 64bit compensation
N * @note Uncomment the following line to disable it
N */
N#ifndef BMP280_DISABLE_64BIT_COMPENSATION
N
N/* #define BMP280_DISABLE_64BIT_COMPENSATION */
N#endif
N
N/*! @name Interface selection macros */
N#define BMP280_SPI_INTF                      UINT8_C(0)
N#define BMP280_I2C_INTF                      UINT8_C(1)
N
N/*! @name Return codes */
N/*! @name Success code*/
N#define BMP280_OK                            INT8_C(0)
N#define BMP280_BOND_WIRE_OK                  INT8_C(0)
N
N/*! @name Error codes */
N#define BMP280_E_NULL_PTR                    INT8_C(-1)
N#define BMP280_E_DEV_NOT_FOUND               INT8_C(-2)
N#define BMP280_E_INVALID_LEN                 INT8_C(-3)
N#define BMP280_E_COMM_FAIL                   INT8_C(-4)
N#define BMP280_E_INVALID_MODE                INT8_C(-5)
N#define BMP280_E_BOND_WIRE                   INT8_C(-6)
N#define BMP280_E_IMPLAUS_TEMP                INT8_C(-7)
N#define BMP280_E_IMPLAUS_PRESS               INT8_C(-8)
N#define BMP280_E_CAL_PARAM_RANGE             INT8_C(-9)
N#define BMP280_E_UNCOMP_TEMP_RANGE           INT8_C(-10)
N#define BMP280_E_UNCOMP_PRES_RANGE           INT8_C(-11)
N#define BMP280_E_UNCOMP_TEMP_AND_PRESS_RANGE INT8_C(-12)
N#define BMP280_E_UNCOMP_DATA_CALC            INT8_C(-13)
N#define BMP280_E_32BIT_COMP_TEMP             INT8_C(-14)
N#define BMP280_E_32BIT_COMP_PRESS            INT8_C(-15)
N#define BMP280_E_64BIT_COMP_PRESS            INT8_C(-16)
N#define BMP280_E_DOUBLE_COMP_TEMP            INT8_C(-17)
N#define BMP280_E_DOUBLE_COMP_PRESS           INT8_C(-18)
N
N/*! @name Chip IDs for samples and mass production parts */
N#define BMP180_CHIP_ID1                      UINT8_C(0x55)
N#define BMP280_CHIP_ID1                      UINT8_C(0x56)
N#define BMP280_CHIP_ID2                      UINT8_C(0x57)
N#define BMP280_CHIP_ID3                      UINT8_C(0x58)
N
N/*! @name I2C addresses */
N#define BMP280_I2C_ADDR_V1000                 UINT8_C(0xee)
N#define BMP280_I2C_ADDR_PRIM                 UINT8_C(0x76)
N#define BMP280_I2C_ADDR_SEC                  UINT8_C(0x77)
N
N/*! @name Calibration parameter register addresses*/
N#define BMP280_DIG_T1_LSB_ADDR               UINT8_C(0x88)
N#define BMP280_DIG_T1_MSB_ADDR               UINT8_C(0x89)
N#define BMP280_DIG_T2_LSB_ADDR               UINT8_C(0x8A)
N#define BMP280_DIG_T2_MSB_ADDR               UINT8_C(0x8B)
N#define BMP280_DIG_T3_LSB_ADDR               UINT8_C(0x8C)
N#define BMP280_DIG_T3_MSB_ADDR               UINT8_C(0x8D)
N#define BMP280_DIG_P1_LSB_ADDR               UINT8_C(0x8E)
N#define BMP280_DIG_P1_MSB_ADDR               UINT8_C(0x8F)
N#define BMP280_DIG_P2_LSB_ADDR               UINT8_C(0x90)
N#define BMP280_DIG_P2_MSB_ADDR               UINT8_C(0x91)
N#define BMP280_DIG_P3_LSB_ADDR               UINT8_C(0x92)
N#define BMP280_DIG_P3_MSB_ADDR               UINT8_C(0x93)
N#define BMP280_DIG_P4_LSB_ADDR               UINT8_C(0x94)
N#define BMP280_DIG_P4_MSB_ADDR               UINT8_C(0x95)
N#define BMP280_DIG_P5_LSB_ADDR               UINT8_C(0x96)
N#define BMP280_DIG_P5_MSB_ADDR               UINT8_C(0x97)
N#define BMP280_DIG_P6_LSB_ADDR               UINT8_C(0x98)
N#define BMP280_DIG_P6_MSB_ADDR               UINT8_C(0x99)
N#define BMP280_DIG_P7_LSB_ADDR               UINT8_C(0x9A)
N#define BMP280_DIG_P7_MSB_ADDR               UINT8_C(0x9B)
N#define BMP280_DIG_P8_LSB_ADDR               UINT8_C(0x9C)
N#define BMP280_DIG_P8_MSB_ADDR               UINT8_C(0x9D)
N#define BMP280_DIG_P9_LSB_ADDR               UINT8_C(0x9E)
N#define BMP280_DIG_P9_MSB_ADDR               UINT8_C(0x9F)
N
N/*! @name Other registers */
N#define BMP280_CHIP_ID_ADDR                  UINT8_C(0xD0)
N#define BMP280_SOFT_RESET_ADDR               UINT8_C(0xE0)
N#define BMP280_STATUS_ADDR                   UINT8_C(0xF3)
N#define BMP280_CTRL_MEAS_ADDR                UINT8_C(0xF4)
N#define BMP280_CONFIG_ADDR                   UINT8_C(0xF5)
N#define BMP280_PRES_MSB_ADDR                 UINT8_C(0xF7)
N#define BMP280_PRES_LSB_ADDR                 UINT8_C(0xF8)
N#define BMP280_PRES_XLSB_ADDR                UINT8_C(0xF9)
N#define BMP280_TEMP_MSB_ADDR                 UINT8_C(0xFA)
N#define BMP280_TEMP_LSB_ADDR                 UINT8_C(0xFB)
N#define BMP280_TEMP_XLSB_ADDR                UINT8_C(0xFC)
N
N/*! @name Power modes */
N#define BMP280_SLEEP_MODE                    UINT8_C(0x00)
N#define BMP280_FORCED_MODE                   UINT8_C(0x01)
N#define BMP280_NORMAL_MODE                   UINT8_C(0x03)
N
N/*! @name Soft reset command */
N#define BMP280_SOFT_RESET_CMD                UINT8_C(0xB6)
N
N/*! @name ODR options */
N#define BMP280_ODR_0_5_MS                    UINT8_C(0x00)
N#define BMP280_ODR_62_5_MS                   UINT8_C(0x01)
N#define BMP280_ODR_125_MS                    UINT8_C(0x02)
N#define BMP280_ODR_250_MS                    UINT8_C(0x03)
N#define BMP280_ODR_500_MS                    UINT8_C(0x04)
N#define BMP280_ODR_1000_MS                   UINT8_C(0x05)
N#define BMP280_ODR_2000_MS                   UINT8_C(0x06)
N#define BMP280_ODR_4000_MS                   UINT8_C(0x07)
N
N/*! @name Over-sampling macros */
N#define BMP280_OS_NONE                       UINT8_C(0x00)
N#define BMP280_OS_1X                         UINT8_C(0x01)
N#define BMP280_OS_2X                         UINT8_C(0x02)
N#define BMP280_OS_4X                         UINT8_C(0x03)
N#define BMP280_OS_8X                         UINT8_C(0x04)
N#define BMP280_OS_16X                        UINT8_C(0x05)
N
N/*! @name Filter coefficient macros */
N#define BMP280_FILTER_OFF                    UINT8_C(0x00)
N#define BMP280_FILTER_COEFF_2                UINT8_C(0x01)
N#define BMP280_FILTER_COEFF_4                UINT8_C(0x02)
N#define BMP280_FILTER_COEFF_8                UINT8_C(0x03)
N#define BMP280_FILTER_COEFF_16               UINT8_C(0x04)
N
N/*! @name SPI 3-Wire macros */
N#define BMP280_SPI3_WIRE_ENABLE              UINT8_C(1)
N#define BMP280_SPI3_WIRE_DISABLE             UINT8_C(0)
N
N/*! @name Measurement status */
N#define BMP280_MEAS_DONE                     UINT8_C(0)
N#define BMP280_MEAS_ONGOING                  UINT8_C(1)
N
N/*! @name Image update */
N#define BMP280_IM_UPDATE_DONE                UINT8_C(0)
N#define BMP280_IM_UPDATE_ONGOING             UINT8_C(1)
N
N/*! @name Position and mask macros */
N#define BMP280_STATUS_IM_UPDATE_POS          UINT8_C(0)
N#define BMP280_STATUS_IM_UPDATE_MASK         UINT8_C(0x01)
N#define BMP280_STATUS_MEAS_POS               UINT8_C(3)
N#define BMP280_STATUS_MEAS_MASK              UINT8_C(0x08)
N#define BMP280_OS_TEMP_POS                   UINT8_C(5)
N#define BMP280_OS_TEMP_MASK                  UINT8_C(0xE0)
N#define BMP280_OS_PRES_POS                   UINT8_C(2)
N#define BMP280_OS_PRES_MASK                  UINT8_C(0x1C)
N#define BMP280_POWER_MODE_POS                UINT8_C(0)
N#define BMP280_POWER_MODE_MASK               UINT8_C(0x03)
N#define BMP280_STANDBY_DURN_POS              UINT8_C(5)
N#define BMP280_STANDBY_DURN_MASK             UINT8_C(0xE0)
N#define BMP280_FILTER_POS                    UINT8_C(2)
N#define BMP280_FILTER_MASK                   UINT8_C(0x1C)
N#define BMP280_SPI3_ENABLE_POS               UINT8_C(0)
N#define BMP280_SPI3_ENABLE_MASK              UINT8_C(0x01)
N
N/*! @name Calibration parameters' relative position */
N#define BMP280_DIG_T1_LSB_POS                UINT8_C(0)
N#define BMP280_DIG_T1_MSB_POS                UINT8_C(1)
N#define BMP280_DIG_T2_LSB_POS                UINT8_C(2)
N#define BMP280_DIG_T2_MSB_POS                UINT8_C(3)
N#define BMP280_DIG_T3_LSB_POS                UINT8_C(4)
N#define BMP280_DIG_T3_MSB_POS                UINT8_C(5)
N#define BMP280_DIG_P1_LSB_POS                UINT8_C(6)
N#define BMP280_DIG_P1_MSB_POS                UINT8_C(7)
N#define BMP280_DIG_P2_LSB_POS                UINT8_C(8)
N#define BMP280_DIG_P2_MSB_POS                UINT8_C(9)
N#define BMP280_DIG_P3_LSB_POS                UINT8_C(10)
N#define BMP280_DIG_P3_MSB_POS                UINT8_C(11)
N#define BMP280_DIG_P4_LSB_POS                UINT8_C(12)
N#define BMP280_DIG_P4_MSB_POS                UINT8_C(13)
N#define BMP280_DIG_P5_LSB_POS                UINT8_C(14)
N#define BMP280_DIG_P5_MSB_POS                UINT8_C(15)
N#define BMP280_DIG_P6_LSB_POS                UINT8_C(16)
N#define BMP280_DIG_P6_MSB_POS                UINT8_C(17)
N#define BMP280_DIG_P7_LSB_POS                UINT8_C(18)
N#define BMP280_DIG_P7_MSB_POS                UINT8_C(19)
N#define BMP280_DIG_P8_LSB_POS                UINT8_C(20)
N#define BMP280_DIG_P8_MSB_POS                UINT8_C(21)
N#define BMP280_DIG_P9_LSB_POS                UINT8_C(22)
N#define BMP280_DIG_P9_MSB_POS                UINT8_C(23)
N#define BMP280_CALIB_DATA_SIZE               UINT8_C(24)
N
N/*! @name Bit-slicing macros */
N#define BMP280_GET_BITS(bitname, x)                    ((x & bitname##_MASK) \
N                                                        >> bitname##_POS)
X#define BMP280_GET_BITS(bitname, x)                    ((x & bitname##_MASK)                                                         >> bitname##_POS)
N#define BMP280_SET_BITS(regvar, bitname, val)          ((regvar & \
N                                                         ~bitname##_MASK) | ((val << bitname##_POS) & bitname##_MASK))
X#define BMP280_SET_BITS(regvar, bitname, val)          ((regvar &                                                          ~bitname##_MASK) | ((val << bitname##_POS) & bitname##_MASK))
N#define BMP280_SET_BITS_POS_0(reg_data, bitname, data) ((reg_data & \
N                                                         ~(bitname##_MASK)) | (data & bitname##_MASK))
X#define BMP280_SET_BITS_POS_0(reg_data, bitname, data) ((reg_data &                                                          ~(bitname##_MASK)) | (data & bitname##_MASK))
N#define BMP280_GET_BITS_POS_0(bitname, reg_data)       (reg_data & \
N                                                        (bitname##_MASK))
X#define BMP280_GET_BITS_POS_0(bitname, reg_data)       (reg_data &                                                         (bitname##_MASK))
N
N/*! @brief Macros holding the minimum and maximum for trimming values */
N
N#define BMP280_ST_DIG_T1_MIN UINT16_C(19000)
N#define BMP280_ST_DIG_T1_MAX UINT16_C(35000)
N#define BMP280_ST_DIG_T2_MIN UINT16_C(22000)
N#define BMP280_ST_DIG_T2_MAX UINT16_C(30000)
N#define BMP280_ST_DIG_T3_MIN INT16_C(-3000)
N#define BMP280_ST_DIG_T3_MAX INT16_C(-1000)
N#define BMP280_ST_DIG_P1_MIN UINT16_C(30000)
N#define BMP280_ST_DIG_P1_MAX UINT16_C(42000)
N#define BMP280_ST_DIG_P2_MIN INT16_C(-12970)
N#define BMP280_ST_DIG_P2_MAX INT16_C(-8000)
N#define BMP280_ST_DIG_P3_MIN INT16_C(-5000)
N#define BMP280_ST_DIG_P3_MAX UINT16_C(8000)
N#define BMP280_ST_DIG_P4_MIN INT16_C(-10000)
N#define BMP280_ST_DIG_P4_MAX UINT16_C(18000)
N#define BMP280_ST_DIG_P5_MIN INT16_C(-500)
N#define BMP280_ST_DIG_P5_MAX UINT16_C(1100)
N#define BMP280_ST_DIG_P6_MIN INT16_C(-1000)
N#define BMP280_ST_DIG_P6_MAX UINT16_C(1000)
N#define BMP280_ST_DIG_P7_MIN INT16_C(-32768)
N#define BMP280_ST_DIG_P7_MAX UINT16_C(32767)
N#define BMP280_ST_DIG_P8_MIN INT16_C(-30000)
N#define BMP280_ST_DIG_P8_MAX UINT16_C(10000)
N#define BMP280_ST_DIG_P9_MIN INT16_C(-10000)
N#define BMP280_ST_DIG_P9_MAX UINT16_C(30000)
N
N#define BMP280_GET_BITSLICE(regvar, bitname) \
N    ((regvar & bitname##__MSK) >> bitname##__POS)
X#define BMP280_GET_BITSLICE(regvar, bitname)     ((regvar & bitname##__MSK) >> bitname##__POS)
N
N/*! @brief Macros to read out API revision number */
N/*Register holding custom trimming values */
N#define BMP280_ST_TRIMCUSTOM_REG             UINT8_C(0x87)
N#define BMP280_ST_TRIMCUSTOM_REG_APIREV__POS UINT8_C(1)
N#define BMP280_ST_TRIMCUSTOM_REG_APIREV__MSK UINT8_C(0x06)
N#define BMP280_ST_TRIMCUSTOM_REG_APIREV__LEN UINT8_C(2)
N#define BMP280_ST_TRIMCUSTOM_REG_APIREV__REG BMP280_ST_TRIMCUSTOM_REG
N
N/* highest API revision supported is revision 0. */
N#define BMP280_ST_MAX_APIREVISION            UINT8_C(0x00)
N
N/*! @brief Macros holding the minimum and maximum for trimming values */
N/* 0x00000 is minimum output value */
N#define BMP280_ST_ADC_T_MIN                  INT32_C(0x00000)
N
N/* 0xFFFF0 is maximum 20-bit output value without over sampling */
N#define BMP280_ST_ADC_T_MAX                  INT32_C(0xFFFF0)
N
N/* 0x00000 is minimum output value */
N#define BMP280_ST_ADC_P_MIN                  INT32_C(0x00000)
N
N/* 0xFFFF0 is maximum 20-bit output value without over sampling */
N#define BMP280_ST_ADC_P_MAX                  INT32_C(0xFFFF0)
N
N/*! @name Function pointer type definitions */
Ntypedef int8_t (*bmp280_com_fptr_t)(uint8_t dev_id, uint8_t reg_addr, uint8_t *data, uint16_t len);
Ntypedef void (*bmp280_delay_fptr_t)(uint32_t period);
N
N/*! @name Calibration parameters' structure */
Nstruct bmp280_calib_param
N{
N    uint16_t dig_t1;
N    int16_t dig_t2;
N    int16_t dig_t3;
N    uint16_t dig_p1;
N    int16_t dig_p2;
N    int16_t dig_p3;
N    int16_t dig_p4;
N    int16_t dig_p5;
N    int16_t dig_p6;
N    int16_t dig_p7;
N    int16_t dig_p8;
N    int16_t dig_p9;
N    int32_t t_fine;
N};
N
N/*! @name Sensor configuration structure */
Nstruct bmp280_config
N{
N    uint8_t os_temp;
N    uint8_t os_pres;
N    uint8_t odr;
N    uint8_t filter;
N    uint8_t spi3w_en;
N};
N
N/*! @name Sensor status structure */
Nstruct bmp280_status
N{
N    uint8_t measuring;
N    uint8_t im_update;
N};
N
N/*! @name Uncompensated data structure */
Nstruct bmp280_uncomp_data
N{
N    int32_t uncomp_temp;
N    uint32_t uncomp_press;
N};
N
N/*! @name API device structure */
Nstruct bmp280_dev
N{
N    uint8_t chip_id;
N    uint8_t dev_id;
N    uint8_t intf;
N    bmp280_com_fptr_t read;
N    bmp280_com_fptr_t write;
N    bmp280_delay_fptr_t delay_ms;
N    struct bmp280_calib_param calib_param;
N    struct bmp280_config conf;
N};
N
N#ifdef __cplusplus
S}
N#endif /* End of CPP guard */
N
N#endif /* __BMP280_DEFS_H__ */
L 41 "..\src\HARDWARE\BMP\bmp280.h" 2
N
N/*! CPP guard */
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/*!
N * @brief This API reads the data from the given register address of the
N * sensor.
N *
N * @param[in] reg_addr : Register address from where the data to be read
N * @param[out] reg_data : Pointer to data buffer to store the read data.
N * @param[in] len : No of bytes of data to be read.
N * @param[in] dev : Structure instance of bmp280_dev.
N *
N * @return Result of API execution
N * @retval Zero for Success, non-zero otherwise.
N */
Nint8_t bmp280_get_regs(uint8_t reg_addr, uint8_t *reg_data, uint8_t len, const struct bmp280_dev *dev);
N
N/*!
N * @brief This API writes the given data to the register addresses
N * of the sensor.
N *
N * @param[in] reg_addr : Register address from where the data to be written.
N * @param[in] reg_data : Pointer to data buffer which is to be written
N * in the sensor.
N * @param[in] len : No of bytes of data to write..
N * @param[in] dev : Structure instance of bmp280_dev.
N *
N * @return Result of API execution
N * @retval Zero for Success, non-zero otherwise.
N */
Nint8_t bmp280_set_regs(uint8_t *reg_addr, const uint8_t *reg_data, uint8_t len, const struct bmp280_dev *dev);
N
N/*!
N * @brief This API triggers the soft reset of the sensor.
N *
N * @param[in] dev : Structure instance of bmp280_dev.
N *
N * @return Result of API execution
N * @retval Zero for Success, non-zero otherwise..
N */
Nint8_t bmp280_soft_reset(const struct bmp280_dev *dev);
N
N/*!
N *  @brief This API is the entry point.
N *  It reads the chip-id and calibration data from the sensor.
N *
N *  @param[in,out] dev : Structure instance of bmp280_dev
N *
N *  @return Result of API execution
N *  @retval zero -> Success / +ve value -> Warning / -ve value -> Error
N */
Nint8_t bmp280_init(struct bmp280_dev *dev);
N
N/*!
N * @brief This API reads the data from the ctrl_meas register and config
N * register. It gives the currently set temperature and pressure over-sampling
N * configuration, power mode configuration, sleep duration and
N * IIR filter coefficient.
N *
N * @param[out] conf : Current configuration of the bmp280
N * conf.osrs_t, conf.osrs_p = BMP280_OS_NONE, BMP280_OS_1X,
N *     BMP280_OS_2X, BMP280_OS_4X, BMP280_OS_8X, BMP280_OS_16X
N * conf.odr = BMP280_ODR_0_5_MS, BMP280_ODR_62_5_MS, BMP280_ODR_125_MS,
N *     BMP280_ODR_250_MS, BMP280_ODR_500_MS, BMP280_ODR_1000_MS,
N *     BMP280_ODR_2000_MS, BMP280_ODR_4000_MS
N * conf.filter = BMP280_FILTER_OFF, BMP280_FILTER_COEFF_2,
N *     BMP280_FILTER_COEFF_4, BMP280_FILTER_COEFF_8, BMP280_FILTER_COEFF_16
N * conf.spi3w_en = BMP280_SPI3_WIRE_ENABLE, BMP280_SPI3_WIRE_DISABLE
N * @param[in] dev : Structure instance of bmp280_dev
N *
N * @return Result of API execution
N * @retval Zero for Success, non-zero otherwise.
N */
Nint8_t bmp280_get_config(struct bmp280_config *conf, struct bmp280_dev *dev);
N
N/*!
N * @brief This API writes the data to the ctrl_meas register and config register.
N * It sets the temperature and pressure over-sampling configuration,
N * power mode configuration, sleep duration and IIR filter coefficient.
N *
N * @param[in] conf : Desired configuration to the bmp280
N * conf.osrs_t, conf.osrs_p = BMP280_OS_NONE, BMP280_OS_1X,
N *     BMP280_OS_2X, BMP280_OS_4X, BMP280_OS_8X, BMP280_OS_16X
N * conf.odr = BMP280_ODR_0_5_MS, BMP280_ODR_62_5_MS, BMP280_ODR_125_MS,
N *     BMP280_ODR_250_MS, BMP280_ODR_500_MS, BMP280_ODR_1000_MS,
N *     BMP280_ODR_2000_MS, BMP280_ODR_4000_MS
N * conf.filter = BMP280_FILTER_OFF, BMP280_FILTER_COEFF_2,
N *     BMP280_FILTER_COEFF_4, BMP280_FILTER_COEFF_8, BMP280_FILTER_COEFF_16
N * conf.spi3w_en = BMP280_SPI3_WIRE_ENABLE, BMP280_SPI3_WIRE_DISABLE
N * @param[in] dev : Structure instance of bmp280_dev
N *
N * @return Result of API execution
N * @retval Zero for Success, non-zero otherwise.
N */
Nint8_t bmp280_set_config(const struct bmp280_config *conf, struct bmp280_dev *dev);
N
N/*!
N * @brief This API reads the status register
N *
N * @param[out] status : Status of the sensor
N * status.measuring = BMP280_MEAS_DONE, BMP280_MEAS_ONGOING
N * status.im_update = BMP280_IM_UPDATE_DONE, BMP280_IM_UPDATE_ONGOING
N * @param[in] dev : structure instance of bmp280_dev
N *
N * @return Result of API execution
N * @retval Zero for Success, non-zero otherwise.
N */
Nint8_t bmp280_get_status(struct bmp280_status *status, const struct bmp280_dev *dev);
N
N/*!
N * @brief This API reads the power mode.
N *
N * @param[out] mode : BMP280_SLEEP_MODE, BMP280_NORMAL_MODE,
N *     BMP280_FORCED_MODE
N * @param[in] dev : Structure instance of bmp280_dev
N *
N * @return Result of API execution
N * @retval Zero for Success, non-zero otherwise.
N */
Nint8_t bmp280_get_power_mode(uint8_t *mode, const struct bmp280_dev *dev);
N
N/*!
N * @brief This API writes the power mode.
N *
N * @param[out] mode : BMP280_SLEEP_MODE, BMP280_NORMAL_MODE,
N *     BMP280_FORCED_MODE
N * @param[in] dev : Structure instance of bmp280_dev
N *
N * @return Result of API execution
N * @retval Zero for Success, non-zero otherwise.
N */
Nint8_t bmp280_set_power_mode(uint8_t mode, struct bmp280_dev *dev);
N
N/*!
N * @brief This API reads the temperature and pressure data registers.
N * It gives the raw temperature and pressure data.
N *
N * @param[in] uncomp_data : Structure instance of bmp280_uncomp_data
N * @param[in] dev : Structure instance of bmp280_dev
N *
N * @return Result of API execution
N * @retval Zero for Success, non-zero otherwise.
N */
Nint8_t bmp280_get_uncomp_data(struct bmp280_uncomp_data *uncomp_data, const struct bmp280_dev *dev);
N
N/*!
N * @brief This API is used to get the compensated temperature from
N * uncompensated temperature. This API uses 32 bit integers.
N * Temperature in degC, resolution is 0.01 DegC. output value of
N * "5123" equals 51.23 degree Celsius
N *
N * @param[out] comp_temp : 32 bit compensated temperature
N * @param[in] uncomp_temp : Raw temperature values from the sensor
N * @param[in] dev : Structure instance of bmp280_dev
N *
N * @return Result of API execution
N * @retval Zero for Success, non-zero otherwise.
N */
Nint8_t bmp280_get_comp_temp_32bit(int32_t *comp_temp, int32_t uncomp_temp, struct bmp280_dev *dev);
N
N/*!
N * @brief This API is used to get the compensated pressure from
N * uncompensated pressure. This API uses 32 bit integers.
N * Pressure in Pa as unsigned 32 bit integer
N * output value of "96386" equals 96386 Pa = 963.86 hPa
N *
N * @param[out] comp_pres : 32 bit compensated pressure
N * @param[in] uncomp_pres : Raw pressure values from the sensor
N * @param[in] dev : structure instance of bmp280_dev
N *
N * @return Result of API execution
N * @retval Zero for Success, non-zero otherwise.
N */
Nint8_t bmp280_get_comp_pres_32bit(uint32_t *comp_pres, uint32_t uncomp_pres, const struct bmp280_dev *dev);
N
N#ifndef BMP280_DISABLE_64BIT_COMPENSATION
N
N/*!
N * @brief This API is used to get the compensated pressure from
N * uncompensated pressure. This API uses 64 bit integers.
N * Pressure in Pa as unsigned 32 bit integer in Q24.8 format
N * (24 integer bits and 8 fractional bits). Output value of "24674867"
N * represents 24674867/256 = 96386.2 Pa = 963.862 hPa
N *
N * @param[out] pressure : compensated pressure
N * @param[in] uncomp_pres : Raw pressure values from the sensor
N * @param[in] dev : Structure instance of bmp280_dev
N *
N * @return Result of API execution
N * @retval Zero for Success, non-zero otherwise.
N */
Nint8_t bmp280_get_comp_pres_64bit(uint32_t *pressure, uint32_t uncomp_pres, const struct bmp280_dev *dev);
N
N#endif /* BMP280_DISABLE_64BIT_COMPENSATION */
N
N#ifndef BMP280_DISABLE_DOUBLE_COMPENSATION
N
N/*!
N * @brief This API is used to get the compensated temperature from
N * uncompensated temperature. This API uses double floating precision.
N * Temperature in degree Celsius , double precision. output value
N * of "51.23" equals 51.23 degC.
N *
N * @param[out] temperature : compensated temperature
N * @param[in] uncomp_temp : Raw temperature values from the sensor
N * @param[in] dev : Structure instance of bmp280_dev
N *
N * @return Result of API execution
N * @retval Zero for Success, non-zero otherwise.
N */
Nint8_t bmp280_get_comp_temp_double(double *temperature, int32_t uncomp_temp, struct bmp280_dev *dev);
N
N/*!
N * @brief This API is used to get the compensated pressure from
N * uncompensated pressure. This API uses double floating precision.
N * Pressure in Pa as double. Output value of "96386.2"
N * equals 96386.2 Pa = 963.862 hPa
N *
N * @param[out] pressure : compensated pressure
N * @param[in] uncomp_pres : Raw pressure values from the sensor
N * @param[in] dev : Structure instance of bmp280_dev
N *
N * @return Result of API execution
N * @retval Zero for Success, non-zero otherwise.
N */
Nint8_t bmp280_get_comp_pres_double(double *pressure, uint32_t uncomp_pres, const struct bmp280_dev *dev);
N
N#endif /* BMP280_DISABLE_DOUBLE_COMPENSATION */
N
N/*!
N * @brief This API computes the measurement time in milliseconds for the
N * active configuration
N *
N * @param[in] dev : Structure instance of bmp280_dev
N *
N * @return Measurement time for the active configuration in milliseconds
N */
Nuint8_t bmp280_compute_meas_time(const struct bmp280_dev *dev);
N
N#ifdef __cplusplus
S}
N#endif /* End of CPP guard */
N
N#endif /* _BMP280_H_ */
L 38 "..\src\HARDWARE\BMP\bmp280.c" 2
N
N/********************** Static function declarations ************************/
N
N/*!
N * @brief This internal API is used to check for null-pointers in the device
N * structure.
N *
N * @param[in] dev : Structure instance of bmp280_dev.
N *
N * @return Result of API execution status
N * @retval Zero for Success, non-zero otherwise.
N */
Nstatic int8_t null_ptr_check(const struct bmp280_dev *dev);
N
N/*!
N * @brief This internal API interleaves the register addresses and respective
N * register data for a burst write
N *
N * @param[in] reg_addr: Register address array
N * @param[out] temp_buff: Interleaved register address and data array
N * @param[in] reg_addr: Register data array
N * @param[in] len : Length of the reg_addr and reg_data arrays
N *
N * @return Result of API execution status
N * @retval Zero for Success, non-zero otherwise.
N */
Nstatic void interleave_data(const uint8_t *reg_addr, uint8_t *temp_buff, const uint8_t *reg_data, uint8_t len);
N
N/*!
N * @brief This API is used to read the calibration parameters used
N * for calculating the compensated data.
N *
N * @param[in] dev : Structure instance of bmp280_dev
N *
N * @return Result of API execution
N * @retval Zero for Success, non-zero otherwise.
N */
Nstatic int8_t get_calib_param(struct bmp280_dev *dev);
N
N/*!
N * @brief This internal API to reset the sensor, restore/set conf, restore/set mode
N *
N * @param[in] mode: Desired mode
N * @param[in] conf : Desired configuration to the bmp280
N * conf.os_temp, conf.os_pres = BMP280_OS_NONE, BMP280_OS_1X,
N *     BMP280_OS_2X, BMP280_OS_4X, BMP280_OS_8X, BMP280_OS_16X
N * conf.mode = BMP280_SLEEP_MODE, BMP280_FORCED_MODE, BMP280_NORMAL_MODE
N * conf.odr = BMP280_ODR_0_5_MS, BMP280_ODR_62_5_MS, BMP280_ODR_125_MS,
N *     BMP280_ODR_250_MS, BMP280_ODR_500_MS, BMP280_ODR_1000_MS,
N *     BMP280_ODR_2000_MS, BMP280_ODR_4000_MS
N * conf.filter = BMP280_FILTER_OFF, BMP280_FILTER_COEFF_2,
N *     BMP280_FILTER_COEFF_4, BMP280_FILTER_COEFF_8, BMP280_FILTER_COEFF_16
N * @param[in] dev : Structure instance of bmp280_dev
N *
N * @return Result of API execution status
N * @retval Zero for Success, non-zero otherwise.
N */
Nstatic int8_t conf_sensor(uint8_t mode, const struct bmp280_config *conf, struct bmp280_dev *dev);
N
N/*!
N * @This internal API checks whether the uncompensated temperature and pressure are within the range
N *
N * @param[in] utemperature : uncompensated temperature
N * @param[in] upressure : uncompensated pressure
N *
N * @return Result of API execution status
N * @retval Zero for Success, non-zero otherwise.
N */
Nstatic int8_t st_check_boundaries(int32_t utemperature, int32_t upressure);
N
N/****************** User Function Definitions *******************************/
N
N/*!
N * @brief This API reads the data from the given register address of the
N * sensor.
N */
Nint8_t bmp280_get_regs(uint8_t reg_addr, uint8_t *reg_data, uint8_t len, const struct bmp280_dev *dev)
N{
N    int8_t rslt;
N
N    rslt = null_ptr_check(dev);
N    if ((rslt == BMP280_OK) && (reg_data != NULL))
X    if ((rslt == (0)) && (reg_data != 0))
N    {
N        /* Mask the register address' MSB if interface selected is SPI */
N        if (dev->intf == BMP280_SPI_INTF)
X        if (dev->intf == (0u))
N        {
N            reg_addr = reg_addr | 0x80;
N        }
N        rslt = dev->read(dev->dev_id, reg_addr, reg_data, len);
N
N        /* Check for communication error and mask with an internal error code */
N        if (rslt != BMP280_OK)
X        if (rslt != (0))
N        {
N            rslt = BMP280_E_COMM_FAIL;
X            rslt = (-4);
N        }
N    }
N    else
N    {
N        rslt = BMP280_E_NULL_PTR;
X        rslt = (-1);
N    }
N
N    return rslt;
N}
N
N/*!
N * @brief This API writes the given data to the register addresses
N * of the sensor.
N */
Nint8_t bmp280_set_regs(uint8_t *reg_addr, const uint8_t *reg_data, uint8_t len, const struct bmp280_dev *dev)
N{
N    int8_t rslt;
N    uint8_t temp_buff[8]; /* Typically not to write more than 4 registers */
N    uint16_t temp_len;
N    uint8_t reg_addr_cnt;
N
N    if (len > 4)
N    {
N        len = 4;
N    }
N    rslt = null_ptr_check(dev);
N    if ((rslt == BMP280_OK) && (reg_addr != NULL) && (reg_data != NULL))
X    if ((rslt == (0)) && (reg_addr != 0) && (reg_data != 0))
N    {
N        if (len != 0)
N        {
N            temp_buff[0] = reg_data[0];
N
N            /* Mask the register address' MSB if interface selected is SPI */
N            if (dev->intf == BMP280_SPI_INTF)
X            if (dev->intf == (0u))
N            {
N                /* Converting all the reg address into proper SPI write address
N                 * i.e making MSB(R/`W) bit 0
N                 */
N                for (reg_addr_cnt = 0; reg_addr_cnt < len; reg_addr_cnt++)
N                {
N                    reg_addr[reg_addr_cnt] = reg_addr[reg_addr_cnt] & 0x7F;
N                }
N            }
N
N            /* Burst write mode */
N            if (len > 1)
N            {
N                /* Interleave register address w.r.t data for burst write*/
N                interleave_data(reg_addr, temp_buff, reg_data, len);
N                temp_len = ((len * 2) - 1);
N            }
N            else
N            {
N                temp_len = len;
N            }
N            rslt = dev->write(dev->dev_id, reg_addr[0], temp_buff, temp_len);
N
N            /* Check for communication error and mask with an internal error code */
N            if (rslt != BMP280_OK)
X            if (rslt != (0))
N            {
N                rslt = BMP280_E_COMM_FAIL;
X                rslt = (-4);
N            }
N        }
N        else
N        {
N            rslt = BMP280_E_INVALID_LEN;
X            rslt = (-3);
N        }
N    }
N    else
N    {
N        rslt = BMP280_E_NULL_PTR;
X        rslt = (-1);
N    }
N
N    return rslt;
N}
N
N/*!
N * @brief This API triggers the soft reset of the sensor.
N */
Nint8_t bmp280_soft_reset(const struct bmp280_dev *dev)
N{
N    int8_t rslt;
N    uint8_t reg_addr = BMP280_SOFT_RESET_ADDR;
X    uint8_t reg_addr = (0xE0u);
N    uint8_t soft_rst_cmd = BMP280_SOFT_RESET_CMD;
X    uint8_t soft_rst_cmd = (0xB6u);
N
N    rslt = null_ptr_check(dev);
N    if (rslt == BMP280_OK)
X    if (rslt == (0))
N    {
N        rslt = bmp280_set_regs(&reg_addr, &soft_rst_cmd, 1, dev);
N
N        /* As per the datasheet, startup time is 2 ms. */
N        dev->delay_ms(2);
N    }
N
N    return rslt;
N}
N
N/*!
N * @brief This API is the entry point.
N * It reads the chip-id and calibration data from the sensor.
N */
Nint8_t bmp280_init(struct bmp280_dev *dev)
N{
N    int8_t rslt;
N
N    /* Maximum number of tries before timeout */
N    uint8_t try_count = 5;
N
N    rslt = null_ptr_check(dev);
N    if (rslt == BMP280_OK)
X    if (rslt == (0))
N    {
N        while (try_count)
N        {
N            rslt = bmp280_get_regs(BMP280_CHIP_ID_ADDR, &dev->chip_id, 1, dev);
X            rslt = bmp280_get_regs((0xD0u), &dev->chip_id, 1, dev);
N
N            /* Check for chip id validity */
N            if ((rslt == BMP280_OK) &&
X            if ((rslt == (0)) &&
N                (dev->chip_id == BMP280_CHIP_ID1 || dev->chip_id == BMP280_CHIP_ID2 || dev->chip_id == BMP280_CHIP_ID3))
X                (dev->chip_id == (0x56u) || dev->chip_id == (0x57u) || dev->chip_id == (0x58u)))
N            {
N                rslt = bmp280_soft_reset(dev);
N                if (rslt == BMP280_OK)
X                if (rslt == (0))
N                {
N                    rslt = get_calib_param(dev);
N                }
N                break;
N            }
N
N            /* Wait for 10 ms */
N            dev->delay_ms(10);
N            --try_count;
N        }
N
N        /* Chip id check failed, and timed out */
N        if (!try_count)
N        {
N            rslt = BMP280_E_DEV_NOT_FOUND;
X            rslt = (-2);
N        }
N        if (rslt == BMP280_OK)
X        if (rslt == (0))
N        {
N            /* Set values to default */
N            dev->conf.filter = BMP280_FILTER_OFF;
X            dev->conf.filter = (0x00u);
N            dev->conf.os_pres = BMP280_OS_NONE;
X            dev->conf.os_pres = (0x00u);
N            dev->conf.os_temp = BMP280_OS_NONE;
X            dev->conf.os_temp = (0x00u);
N            dev->conf.odr = BMP280_ODR_0_5_MS;
X            dev->conf.odr = (0x00u);
N            dev->conf.spi3w_en = BMP280_SPI3_WIRE_DISABLE;
X            dev->conf.spi3w_en = (0u);
N        }
N    }
N
N    return rslt;
N}
N
N/*!
N * @brief This API reads the data from the ctrl_meas register and config
N * register. It gives the currently set temperature and pressure over-sampling
N * configuration, power mode configuration, sleep duration and
N * IIR filter coefficient.
N */
Nint8_t bmp280_get_config(struct bmp280_config *conf, struct bmp280_dev *dev)
N{
N    int8_t rslt;
N    uint8_t temp[2] = { 0, 0 };
N
N    rslt = null_ptr_check(dev);
N    if ((rslt == BMP280_OK) && (conf != NULL))
X    if ((rslt == (0)) && (conf != 0))
N    {
N        rslt = bmp280_get_regs(BMP280_CTRL_MEAS_ADDR, temp, 2, dev);
X        rslt = bmp280_get_regs((0xF4u), temp, 2, dev);
N        if (rslt == BMP280_OK)
X        if (rslt == (0))
N        {
N            conf->os_temp = BMP280_GET_BITS(BMP280_OS_TEMP, temp[0]);
X            conf->os_temp = ((temp[0] & (0xE0u)) >> (5u));
N            conf->os_pres = BMP280_GET_BITS(BMP280_OS_PRES, temp[0]);
X            conf->os_pres = ((temp[0] & (0x1Cu)) >> (2u));
N            conf->odr = BMP280_GET_BITS(BMP280_STANDBY_DURN, temp[1]);
X            conf->odr = ((temp[1] & (0xE0u)) >> (5u));
N            conf->filter = BMP280_GET_BITS(BMP280_FILTER, temp[1]);
X            conf->filter = ((temp[1] & (0x1Cu)) >> (2u));
N            conf->spi3w_en = BMP280_GET_BITS_POS_0(BMP280_SPI3_ENABLE, temp[1]);
X            conf->spi3w_en = (temp[1] & ((0x01u)));
N            dev->conf = *conf;
N        }
N    }
N    else
N    {
N        rslt = BMP280_E_NULL_PTR;
X        rslt = (-1);
N    }
N
N    return rslt;
N}
N
N/*!
N * @brief This API writes the data to the ctrl_meas register and config register.
N * It sets the temperature and pressure over-sampling configuration,
N * power mode configuration, sleep duration and IIR filter coefficient.
N */
Nint8_t bmp280_set_config(const struct bmp280_config *conf, struct bmp280_dev *dev)
N{
N    return conf_sensor(BMP280_SLEEP_MODE, conf, dev);
X    return conf_sensor((0x00u), conf, dev);
N}
N
N/*!
N * @brief This API reads the status register
N */
Nint8_t bmp280_get_status(struct bmp280_status *status, const struct bmp280_dev *dev)
N{
N    int8_t rslt;
N    uint8_t temp;
N
N    rslt = null_ptr_check(dev);
N    if ((rslt == BMP280_OK) && (status != NULL))
X    if ((rslt == (0)) && (status != 0))
N    {
N        rslt = bmp280_get_regs(BMP280_STATUS_ADDR, &temp, 1, dev);
X        rslt = bmp280_get_regs((0xF3u), &temp, 1, dev);
N        status->measuring = BMP280_GET_BITS(BMP280_STATUS_MEAS, temp);
X        status->measuring = ((temp & (0x08u)) >> (3u));
N        status->im_update = BMP280_GET_BITS_POS_0(BMP280_STATUS_IM_UPDATE, temp);
X        status->im_update = (temp & ((0x01u)));
N    }
N    else
N    {
N        rslt = BMP280_E_NULL_PTR;
X        rslt = (-1);
N    }
N
N    return rslt;
N}
N
N/*!
N * @brief This API reads the power mode.
N */
Nint8_t bmp280_get_power_mode(uint8_t *mode, const struct bmp280_dev *dev)
N{
N    int8_t rslt;
N    uint8_t temp;
N
N    rslt = null_ptr_check(dev);
N    if ((rslt == BMP280_OK) && (mode != NULL))
X    if ((rslt == (0)) && (mode != 0))
N    {
N        rslt = bmp280_get_regs(BMP280_CTRL_MEAS_ADDR, &temp, 1, dev);
X        rslt = bmp280_get_regs((0xF4u), &temp, 1, dev);
N        *mode = BMP280_GET_BITS_POS_0(BMP280_POWER_MODE, temp);
X        *mode = (temp & ((0x03u)));
N    }
N    else
N    {
N        rslt = BMP280_E_NULL_PTR;
X        rslt = (-1);
N    }
N
N    return rslt;
N}
N
N/*!
N * @brief This API writes the power mode.
N */
Nint8_t bmp280_set_power_mode(uint8_t mode, struct bmp280_dev *dev)
N{
N    int8_t rslt;
N
N    rslt = null_ptr_check(dev);
N    if (rslt == BMP280_OK)
X    if (rslt == (0))
N    {
N        rslt = conf_sensor(mode, &dev->conf, dev);
N    }
N
N    return rslt;
N}
N
N/*!
N * @brief This API reads the temperature and pressure data registers.
N * It gives the raw temperature and pressure data .
N */
Nint8_t bmp280_get_uncomp_data(struct bmp280_uncomp_data *uncomp_data, const struct bmp280_dev *dev)
N{
N    int8_t rslt;
N    uint8_t temp[6] = { 0 };
N
N    rslt = null_ptr_check(dev);
N    if ((rslt == BMP280_OK) && (uncomp_data != NULL))
X    if ((rslt == (0)) && (uncomp_data != 0))
N    {
N        rslt = bmp280_get_regs(BMP280_PRES_MSB_ADDR, temp, 6, dev);
X        rslt = bmp280_get_regs((0xF7u), temp, 6, dev);
N        if (rslt == BMP280_OK)
X        if (rslt == (0))
N        {
W "..\src\HARDWARE\BMP\bmp280.c" 402 13 function "printf" declared implicitly
N            printf("temp[0] :%x \r\n",temp[0]);
N            printf("temp[1] :%x \r\n",temp[1]);
N            printf("temp[2] :%x \r\n",temp[2]);
N            printf("temp[3] :%x \r\n",temp[3]);
N            printf("temp[4] :%x \r\n",temp[4]);
N            printf("temp[5] :%x \r\n",temp[5]);
N            uncomp_data->uncomp_press =
N                (int32_t) ((((uint32_t) (temp[0])) << 12) | (((uint32_t) (temp[1])) << 4) | ((uint32_t) temp[2] >> 4));
N            uncomp_data->uncomp_temp =
N                (int32_t) ((((int32_t) (temp[3])) << 12) | (((int32_t) (temp[4])) << 4) | (((int32_t) (temp[5])) >> 4));
N            rslt = st_check_boundaries((int32_t)uncomp_data->uncomp_temp, (int32_t)uncomp_data->uncomp_press);
N        }
N        else
N        {
N            rslt = BMP280_E_UNCOMP_DATA_CALC;
X            rslt = (-13);
N        }
N    }
N    else
N    {
N        rslt = BMP280_E_NULL_PTR;
X        rslt = (-1);
N    }
N
N    return rslt;
N}
N
N/*!
N * @brief This API is used to get the compensated temperature from
N * uncompensated temperature. This API uses 32 bit integers.
N */
Nint8_t bmp280_get_comp_temp_32bit(int32_t *comp_temp, int32_t uncomp_temp, struct bmp280_dev *dev)
N{
N    int32_t var1, var2;
N    int8_t rslt;
N
N    rslt = null_ptr_check(dev);
N    if (rslt == BMP280_OK)
X    if (rslt == (0))
N    {
N        var1 =
N            ((((uncomp_temp / 8) - ((int32_t) dev->calib_param.dig_t1 << 1))) * ((int32_t) dev->calib_param.dig_t2)) /
N            2048;
N        var2 =
N            (((((uncomp_temp / 16) - ((int32_t) dev->calib_param.dig_t1)) *
N               ((uncomp_temp / 16) - ((int32_t) dev->calib_param.dig_t1))) / 4096) *
N             ((int32_t) dev->calib_param.dig_t3)) /
N            16384;
N        dev->calib_param.t_fine = var1 + var2;
N        *comp_temp = (dev->calib_param.t_fine * 5 + 128) / 256;
N        rslt = BMP280_OK;
X        rslt = (0);
N    }
N    else
N    {
N        *comp_temp = 0;
N        rslt = BMP280_E_32BIT_COMP_TEMP;
X        rslt = (-14);
N    }
N
N    return rslt;
N}
N
N/*!
N * @brief This API is used to get the compensated pressure from
N * uncompensated pressure. This API uses 32 bit integers.
N */
Nint8_t bmp280_get_comp_pres_32bit(uint32_t *comp_pres, uint32_t uncomp_pres, const struct bmp280_dev *dev)
N{
N    int32_t var1, var2;
N    int8_t rslt;
N
N    rslt = null_ptr_check(dev);
N    if (rslt == BMP280_OK)
X    if (rslt == (0))
N    {
N        var1 = (((int32_t) dev->calib_param.t_fine) / 2) - (int32_t) 64000;
N        var2 = (((var1 / 4) * (var1 / 4)) / 2048) * ((int32_t) dev->calib_param.dig_p6);
N        var2 = var2 + ((var1 * ((int32_t) dev->calib_param.dig_p5)) * 2);
N        var2 = (var2 / 4) + (((int32_t) dev->calib_param.dig_p4) * 65536);
N        var1 =
N            (((dev->calib_param.dig_p3 * (((var1 / 4) * (var1 / 4)) / 8192)) / 8) +
N             ((((int32_t) dev->calib_param.dig_p2) * var1) / 2)) / 262144;
N        var1 = ((((32768 + var1)) * ((int32_t) dev->calib_param.dig_p1)) / 32768);
N        *comp_pres = (uint32_t)(((int32_t)(1048576 - uncomp_pres) - (var2 / 4096)) * 3125);
N
N        /* Avoid exception caused by division with zero */
N        if (var1 != 0)
N        {
N            /* Check for overflows against UINT32_MAX/2; if pres is left-shifted by 1 */
N            if (*comp_pres < 0x80000000)
N            {
N                *comp_pres = (*comp_pres << 1) / ((uint32_t) var1);
N            }
N            else
N            {
N                *comp_pres = (*comp_pres / (uint32_t) var1) * 2;
N            }
N            var1 = (((int32_t) dev->calib_param.dig_p9) * ((int32_t) (((*comp_pres / 8) * (*comp_pres / 8)) / 8192))) /
N                   4096;
N            var2 = (((int32_t) (*comp_pres / 4)) * ((int32_t) dev->calib_param.dig_p8)) / 8192;
N            *comp_pres = (uint32_t) ((int32_t) *comp_pres + ((var1 + var2 + dev->calib_param.dig_p7) / 16));
N            rslt = BMP280_OK;
X            rslt = (0);
N        }
N        else
N        {
N            *comp_pres = 0;
N            rslt = BMP280_E_32BIT_COMP_PRESS;
X            rslt = (-15);
N        }
N    }
N
N    return rslt;
N}
N
N#ifndef BMP280_DISABLE_64BIT_COMPENSATION
N
N/*!
N * @brief This API is used to get the compensated pressure from
N * uncompensated pressure. This API uses 64 bit integers.
N */
Nint8_t bmp280_get_comp_pres_64bit(uint32_t *pressure, uint32_t uncomp_pres, const struct bmp280_dev *dev)
N{
N    int64_t var1, var2, p;
N    int8_t rslt;
N
N    rslt = null_ptr_check(dev);
N    if (rslt == BMP280_OK)
X    if (rslt == (0))
N    {
N        var1 = ((int64_t) (dev->calib_param.t_fine)) - 128000;
N        var2 = var1 * var1 * (int64_t) dev->calib_param.dig_p6;
N        var2 = var2 + ((var1 * (int64_t) dev->calib_param.dig_p5) * 131072);
N        var2 = var2 + (((int64_t) dev->calib_param.dig_p4) * 34359738368);
N        var1 = ((var1 * var1 * (int64_t) dev->calib_param.dig_p3) / 256) +
N               ((var1 * (int64_t) dev->calib_param.dig_p2) * 4096);
N        var1 = ((INT64_C(0x800000000000) + var1) * ((int64_t)dev->calib_param.dig_p1)) / 8589934592;
X        var1 = ((__ESCAPE__(0x800000000000ll) + var1) * ((int64_t)dev->calib_param.dig_p1)) / 8589934592;
N        if (var1 != 0)
N        {
N            p = 1048576 - uncomp_pres;
N            p = (((((p * 2147483648U)) - var2) * 3125) / var1);
N            var1 = (((int64_t) dev->calib_param.dig_p9) * (p / 8192) * (p / 8192)) / 33554432;
N            var2 = (((int64_t) dev->calib_param.dig_p8) * p) / 524288;
N            p = ((p + var1 + var2) / 256) + (((int64_t)dev->calib_param.dig_p7) * 16);
N            *pressure = (uint32_t)p;
N            rslt = BMP280_OK;
X            rslt = (0);
N        }
N        else
N        {
N            *pressure = 0;
N            rslt = BMP280_E_64BIT_COMP_PRESS;
X            rslt = (-16);
N        }
N    }
N
N    return rslt;
N}
N
N#endif /* BMP280_DISABLE_64BIT_COMPENSATION */
N
N#ifndef BMP280_DISABLE_DOUBLE_COMPENSATION
N
N/*!
N * @brief This API is used to get the compensated temperature from
N * uncompensated temperature. This API uses double floating precision.
N */
Nint8_t bmp280_get_comp_temp_double(double *temperature, int32_t uncomp_temp, struct bmp280_dev *dev)
N{
N    double var1, var2;
N    int8_t rslt;
N
N    rslt = null_ptr_check(dev);
N    if (rslt == BMP280_OK)
X    if (rslt == (0))
N    {
N        var1 = (((double) uncomp_temp) / 16384.0 - ((double) dev->calib_param.dig_t1) / 1024.0) *
N               ((double) dev->calib_param.dig_t2);
N        var2 =
N            ((((double) uncomp_temp) / 131072.0 - ((double) dev->calib_param.dig_t1) / 8192.0) *
N             (((double) uncomp_temp) / 131072.0 - ((double) dev->calib_param.dig_t1) / 8192.0)) *
N            ((double) dev->calib_param.dig_t3);
N        dev->calib_param.t_fine = (int32_t) (var1 + var2);
N        *temperature = ((var1 + var2) / 5120.0);
N    }
N    else
N    {
N        *temperature = 0;
N        rslt = BMP280_E_DOUBLE_COMP_TEMP;
X        rslt = (-17);
N    }
N
N    return rslt;
N}
N
N/*!
N * @brief This API is used to get the compensated pressure from
N * uncompensated pressure. This API uses double floating precision.
N */
Nint8_t bmp280_get_comp_pres_double(double *pressure, uint32_t uncomp_pres, const struct bmp280_dev *dev)
N{
N    double var1, var2;
N    int8_t rslt;
N
N    rslt = null_ptr_check(dev);
N    if (rslt == BMP280_OK)
X    if (rslt == (0))
N    {
N        var1 = ((double) dev->calib_param.t_fine / 2.0) - 64000.0;
N        var2 = var1 * var1 * ((double) dev->calib_param.dig_p6) / 32768.0;
N        var2 = var2 + var1 * ((double) dev->calib_param.dig_p5) * 2.0;
N        var2 = (var2 / 4.0) + (((double) dev->calib_param.dig_p4) * 65536.0);
N        var1 = (((double)dev->calib_param.dig_p3) * var1 * var1 / 524288.0 + ((double)dev->calib_param.dig_p2) * var1) /
N               524288.0;
N        var1 = (1.0 + var1 / 32768.0) * ((double) dev->calib_param.dig_p1);
N
N        *pressure = 1048576.0 - (double)uncomp_pres;
N        if (var1 < 0 || var1 > 0)
N        {
N            *pressure = (*pressure - (var2 / 4096.0)) * 6250.0 / var1;
N            var1 = ((double)dev->calib_param.dig_p9) * (*pressure) * (*pressure) / 2147483648.0;
N            var2 = (*pressure) * ((double)dev->calib_param.dig_p8) / 32768.0;
N            *pressure = *pressure + (var1 + var2 + ((double)dev->calib_param.dig_p7)) / 16.0;
N        }
N        else
N        {
N            *pressure = 0;
N            rslt = BMP280_E_DOUBLE_COMP_PRESS;
X            rslt = (-18);
N        }
N    }
N
N    return rslt;
N}
N
N#endif /* BMP280_DISABLE_DOUBLE_COMPENSATION */
N
N/*!
N * @brief This API computes the measurement time in milliseconds for the
N * active configuration
N */
Nuint8_t bmp280_compute_meas_time(const struct bmp280_dev *dev)
N{
N    uint32_t period = 0;
N    uint32_t t_dur = 0, p_dur = 0, p_startup = 0;
N    const uint32_t startup = 1000, period_per_osrs = 2000; /* Typical timings in us. Maximum is +15% each */
N    int8_t rslt;
N
N    rslt = null_ptr_check(dev);
N    if (rslt == BMP280_OK)
X    if (rslt == (0))
N    {
N        t_dur = period_per_osrs * ((UINT32_C(1) << dev->conf.os_temp) >> 1);
X        t_dur = period_per_osrs * (((1u) << dev->conf.os_temp) >> 1);
N        p_dur = period_per_osrs * ((UINT32_C(1) << dev->conf.os_pres) >> 1);
X        p_dur = period_per_osrs * (((1u) << dev->conf.os_pres) >> 1);
N        p_startup = (dev->conf.os_pres) ? 500 : 0;
N
N        /* Increment the value to next highest integer if greater than 0.5 */
N        period = startup + t_dur + p_startup + p_dur + 500;
N        period /= 1000; /* Convert to milliseconds */
N    }
N
N    return (uint8_t)period;
N}
N
N/****************** Static Function Definitions *******************************/
N
N/*!
N * @brief This internal API is used to check for null-pointers in the device
N * structure.
N */
Nstatic int8_t null_ptr_check(const struct bmp280_dev *dev)
N{
N    int8_t rslt;
N
N    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_ms == NULL))
X    if ((dev == 0) || (dev->read == 0) || (dev->write == 0) || (dev->delay_ms == 0))
N    {
N        /* Null-pointer found */
N        rslt = BMP280_E_NULL_PTR;
X        rslt = (-1);
N    }
N    else
N    {
N        rslt = BMP280_OK;
X        rslt = (0);
N    }
N
N    return rslt;
N}
N
N/*!
N * @brief This internal API interleaves the register addresses and respective
N * register data for a burst write
N */
Nstatic void interleave_data(const uint8_t *reg_addr, uint8_t *temp_buff, const uint8_t *reg_data, uint8_t len)
N{
N    uint8_t index;
N
N    for (index = 1; index < len; index++)
N    {
N        temp_buff[(index * 2) - 1] = reg_addr[index];
N        temp_buff[index * 2] = reg_data[index];
N    }
N}
N
N/*!
N * @brief This API is used to read the calibration parameters used
N * for calculating the compensated data.
N */
Nstatic int8_t get_calib_param(struct bmp280_dev *dev)
N{
N    int8_t rslt;
N    uint8_t temp[BMP280_CALIB_DATA_SIZE] = { 0 };
X    uint8_t temp[(24u)] = { 0 };
N
N    rslt = null_ptr_check(dev);
N    if (rslt == BMP280_OK)
X    if (rslt == (0))
N    {
N        rslt = bmp280_get_regs(BMP280_DIG_T1_LSB_ADDR, temp, BMP280_CALIB_DATA_SIZE, dev);
X        rslt = bmp280_get_regs((0x88u), temp, (24u), dev);
N        if (rslt == BMP280_OK)
X        if (rslt == (0))
N        {
N            dev->calib_param.dig_t1 =
N                (uint16_t) (((uint16_t) temp[BMP280_DIG_T1_MSB_POS] << 8) | ((uint16_t) temp[BMP280_DIG_T1_LSB_POS]));
X                (uint16_t) (((uint16_t) temp[(1u)] << 8) | ((uint16_t) temp[(0u)]));
N            dev->calib_param.dig_t2 =
N                (int16_t) (((int16_t) temp[BMP280_DIG_T2_MSB_POS] << 8) | ((int16_t) temp[BMP280_DIG_T2_LSB_POS]));
X                (int16_t) (((int16_t) temp[(3u)] << 8) | ((int16_t) temp[(2u)]));
N            dev->calib_param.dig_t3 =
N                (int16_t) (((int16_t) temp[BMP280_DIG_T3_MSB_POS] << 8) | ((int16_t) temp[BMP280_DIG_T3_LSB_POS]));
X                (int16_t) (((int16_t) temp[(5u)] << 8) | ((int16_t) temp[(4u)]));
N            dev->calib_param.dig_p1 =
N                (uint16_t) (((uint16_t) temp[BMP280_DIG_P1_MSB_POS] << 8) | ((uint16_t) temp[BMP280_DIG_P1_LSB_POS]));
X                (uint16_t) (((uint16_t) temp[(7u)] << 8) | ((uint16_t) temp[(6u)]));
N            dev->calib_param.dig_p2 =
N                (int16_t) (((int16_t) temp[BMP280_DIG_P2_MSB_POS] << 8) | ((int16_t) temp[BMP280_DIG_P2_LSB_POS]));
X                (int16_t) (((int16_t) temp[(9u)] << 8) | ((int16_t) temp[(8u)]));
N            dev->calib_param.dig_p3 =
N                (int16_t) (((int16_t) temp[BMP280_DIG_P3_MSB_POS] << 8) | ((int16_t) temp[BMP280_DIG_P3_LSB_POS]));
X                (int16_t) (((int16_t) temp[(11u)] << 8) | ((int16_t) temp[(10u)]));
N            dev->calib_param.dig_p4 =
N                (int16_t) (((int16_t) temp[BMP280_DIG_P4_MSB_POS] << 8) | ((int16_t) temp[BMP280_DIG_P4_LSB_POS]));
X                (int16_t) (((int16_t) temp[(13u)] << 8) | ((int16_t) temp[(12u)]));
N            dev->calib_param.dig_p5 =
N                (int16_t) (((int16_t) temp[BMP280_DIG_P5_MSB_POS] << 8) | ((int16_t) temp[BMP280_DIG_P5_LSB_POS]));
X                (int16_t) (((int16_t) temp[(15u)] << 8) | ((int16_t) temp[(14u)]));
N            dev->calib_param.dig_p6 =
N                (int16_t) (((int16_t) temp[BMP280_DIG_P6_MSB_POS] << 8) | ((int16_t) temp[BMP280_DIG_P6_LSB_POS]));
X                (int16_t) (((int16_t) temp[(17u)] << 8) | ((int16_t) temp[(16u)]));
N            dev->calib_param.dig_p7 =
N                (int16_t) (((int16_t) temp[BMP280_DIG_P7_MSB_POS] << 8) | ((int16_t) temp[BMP280_DIG_P7_LSB_POS]));
X                (int16_t) (((int16_t) temp[(19u)] << 8) | ((int16_t) temp[(18u)]));
N            dev->calib_param.dig_p8 =
N                (int16_t) (((int16_t) temp[BMP280_DIG_P8_MSB_POS] << 8) | ((int16_t) temp[BMP280_DIG_P8_LSB_POS]));
X                (int16_t) (((int16_t) temp[(21u)] << 8) | ((int16_t) temp[(20u)]));
N            dev->calib_param.dig_p9 =
N                (int16_t) (((int16_t) temp[BMP280_DIG_P9_MSB_POS] << 8) | ((int16_t) temp[BMP280_DIG_P9_LSB_POS]));
X                (int16_t) (((int16_t) temp[(23u)] << 8) | ((int16_t) temp[(22u)]));
N        }
N    }
N
N    return rslt;
N}
N
N/*!
N * @brief This internal API to reset the sensor, restore/set conf, restore/set mode
N */
Nstatic int8_t conf_sensor(uint8_t mode, const struct bmp280_config *conf, struct bmp280_dev *dev)
N{
N    int8_t rslt;
N    uint8_t temp[2] = { 0, 0 };
N    uint8_t reg_addr[2] = { BMP280_CTRL_MEAS_ADDR, BMP280_CONFIG_ADDR };
X    uint8_t reg_addr[2] = { (0xF4u), (0xF5u) };
N
N    rslt = null_ptr_check(dev);
N    if ((rslt == BMP280_OK) && (conf != NULL))
X    if ((rslt == (0)) && (conf != 0))
N    {
N        rslt = bmp280_get_regs(BMP280_CTRL_MEAS_ADDR, temp, 2, dev);
X        rslt = bmp280_get_regs((0xF4u), temp, 2, dev);
N        if (rslt == BMP280_OK)
X        if (rslt == (0))
N        {
N            /* Here the intention is to put the device to sleep
N             * within the shortest period of time
N             */
N            rslt = bmp280_soft_reset(dev);
N            if (rslt == BMP280_OK)
X            if (rslt == (0))
N            {
N                temp[0] = BMP280_SET_BITS(temp[0], BMP280_OS_TEMP, conf->os_temp);
X                temp[0] = ((temp[0] & ~(0xE0u)) | ((conf->os_temp << (5u)) & (0xE0u)));
N                temp[0] = BMP280_SET_BITS(temp[0], BMP280_OS_PRES, conf->os_pres);
X                temp[0] = ((temp[0] & ~(0x1Cu)) | ((conf->os_pres << (2u)) & (0x1Cu)));
N                temp[1] = BMP280_SET_BITS(temp[1], BMP280_STANDBY_DURN, conf->odr);
X                temp[1] = ((temp[1] & ~(0xE0u)) | ((conf->odr << (5u)) & (0xE0u)));
N                temp[1] = BMP280_SET_BITS(temp[1], BMP280_FILTER, conf->filter);
X                temp[1] = ((temp[1] & ~(0x1Cu)) | ((conf->filter << (2u)) & (0x1Cu)));
N                temp[1] = BMP280_SET_BITS_POS_0(temp[1], BMP280_SPI3_ENABLE, conf->spi3w_en);
X                temp[1] = ((temp[1] & ~((0x01u))) | (conf->spi3w_en & (0x01u)));
N                rslt = bmp280_set_regs(reg_addr, temp, 2, dev);
N                if (rslt == BMP280_OK)
X                if (rslt == (0))
N                {
N                    dev->conf = *conf;
N                    if (mode != BMP280_SLEEP_MODE)
X                    if (mode != (0x00u))
N                    {
N                        /* Write only the power mode register in a separate write */
N                        temp[0] = BMP280_SET_BITS_POS_0(temp[0], BMP280_POWER_MODE, mode);
X                        temp[0] = ((temp[0] & ~((0x03u))) | (mode & (0x03u)));
N                        rslt = bmp280_set_regs(reg_addr, temp, 1, dev);
N                    }
N                }
N            }
N        }
N    }
N    else
N    {
N        rslt = BMP280_E_NULL_PTR;
X        rslt = (-1);
N    }
N
N    return rslt;
N}
N
N/*!
N * @This internal API checks whether the uncompensated temperature and pressure are within the range
N */
Nstatic int8_t st_check_boundaries(int32_t utemperature, int32_t upressure)
N{
N    int8_t rslt = 0;
N
N    /* check UT and UP for valid range */
N    if ((utemperature <= BMP280_ST_ADC_T_MIN || utemperature >= BMP280_ST_ADC_T_MAX) &&
X    if ((utemperature <= (0x00000) || utemperature >= (0xFFFF0)) &&
N        (upressure <= BMP280_ST_ADC_P_MIN || upressure >= BMP280_ST_ADC_P_MAX))
X        (upressure <= (0x00000) || upressure >= (0xFFFF0)))
N    {
N        rslt = BMP280_E_UNCOMP_TEMP_AND_PRESS_RANGE;
X        rslt = (-12);
N    }
N    else if (utemperature <= BMP280_ST_ADC_T_MIN || utemperature >= BMP280_ST_ADC_T_MAX)
X    else if (utemperature <= (0x00000) || utemperature >= (0xFFFF0))
N    {
N        rslt = BMP280_E_UNCOMP_TEMP_RANGE;
X        rslt = (-10);
N    }
N    else if (upressure <= BMP280_ST_ADC_P_MIN || upressure >= BMP280_ST_ADC_P_MAX)
X    else if (upressure <= (0x00000) || upressure >= (0xFFFF0))
N    {
N        rslt = BMP280_E_UNCOMP_PRES_RANGE;
X        rslt = (-11);
N    }
N    else
N    {
N        rslt = BMP280_OK;
X        rslt = (0);
N    }
N
N    return rslt;
N}
