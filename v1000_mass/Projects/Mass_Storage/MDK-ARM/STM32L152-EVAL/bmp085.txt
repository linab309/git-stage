; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm32l152-eval\bmp085.o --asm_dir=.\STM32L152-EVAL\ --list_dir=.\STM32L152-EVAL\ --depend=.\stm32l152-eval\bmp085.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32L1xx\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32L1xx_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM32L152_EVAL -I..\src\user -I..\src\user\include -I..\src\SYSTEM\delay -I..\src\SYSTEM\sys -I..\src\SYSTEM\usart -I..\src\HARDWARE\ADC -I..\src\HARDWARE\BMP -I..\src\HARDWARE\DMA -I..\src\HARDWARE\FLASH -I..\src\HARDWARE\GPS -I..\src\HARDWARE\KEY -I..\src\HARDWARE\PWM -I..\src\HARDWARE\RTC -I..\src\HARDWARE\SPI -I..\src\HARDWARE\USART2 -I..\src\HARDWARE\TIMER -I..\src\EX -I..\src\USMART -I..\..\..\Libraries\CMSIS\Include -I..\src\ff11a\src -I..\src\ff11a\src\option -I..\src\HARDWARE\LED -I..\src\HARDWARE\OLED -I..\src\ff11a\src -I..\src\ff11a\src\option -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.1.0\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32L1xx -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32L1XX_MD -DUSE_STM32L152_EVAL ..\src\HARDWARE\BMP\BMP085.c]
                          THUMB

                          AREA ||i.BMP085_Get_Altitude||, CODE, READONLY, ALIGN=2

                  BMP085_Get_Altitude PROC
;;;413    *****************************************************************/
;;;414    int BMP085_Get_Altitude(void)
000000  480f              LDR      r0,|L1.64|
;;;415    {
000002  b510              PUSH     {r4,lr}
;;;416    	float pressure_tmep,pp;
;;;417    	float altitude;
;;;418    //	u8 dtbuf_jian[50]; 
;;;419    	//v1000_debug("\r\n pressure: %ld!\n\n",pressure);
;;;420    	pressure_tmep = (float)pressure;
000004  69c0              LDR      r0,[r0,#0x1c]  ; pressure
000006  f7fffffe          BL       __aeabi_i2f
;;;421    	pp =(pressure_tmep/101325);
00000a  490e              LDR      r1,|L1.68|
00000c  f7fffffe          BL       __aeabi_fdiv
;;;422    //	v1000_debug("\r\n pressure_tmep: %f m \n\n",pressure_tmep);
;;;423    //	v1000_debug("\r\n pp: %f m \n\n",pp);
;;;424    	pressure_tmep = (1/5.255);	
;;;425    //	v1000_debug("\r\n 1/5.255: %f m \n\n",pressure_tmep);
;;;426    	pressure_tmep = pow(pp,pressure_tmep);				//��ȡ��ѹֵ
000010  f7fffffe          BL       __aeabi_f2d
000014  f04f4240          MOV      r2,#0xc0000000
000018  4b0b              LDR      r3,|L1.72|
00001a  f7fffffe          BL       pow
00001e  f7fffffe          BL       __aeabi_d2f
000022  4601              MOV      r1,r0
;;;427    //	v1000_debug("\r\n pressure_tmep: %f m \n\n",pressure_tmep);
;;;428    	altitude=44330*(1-pressure_tmep);  	//����оƬ�ֲ��ṩ�Ĺ�ʽ���㺣�θ߶�
000024  f04f507e          MOV      r0,#0x3f800000
000028  f7fffffe          BL       __aeabi_fsub
00002c  4907              LDR      r1,|L1.76|
00002e  f7fffffe          BL       __aeabi_fmul
;;;429    	altitude*=10;	 		//ת�������׵�λ�ĸ߶�ֵ������ʱ�ٻ���ɴ�С���ĸ߶�ֵ����߾���
000032  4907              LDR      r1,|L1.80|
000034  f7fffffe          BL       __aeabi_fmul
;;;430    //	if(altitude<0)
;;;431    //		altitude	
;;;432    //	conversion(altitude);
;;;433    	
;;;434    //	sprintf((char *)dtbuf_jian,"H: +%c%c%c.%c%cm",wan,qian,bai,shi,ge);	//�õ������ַ���
;;;435    //		
;;;436    //	OLED_ShowString(0,32,dtbuf_jian);	 
;;;437    	//v1000_debug("\r\n H: %f m \n\n",altitude);
;;;438    	return (int)altitude;
000038  e8bd4010          POP      {r4,lr}
00003c  f7ffbffe          B.W      __aeabi_f2iz
;;;439    }
;;;440    
                          ENDP

                  |L1.64|
                          DCD      ||.data||
                  |L1.68|
                          DCD      0x47c5e680
                  |L1.72|
                          DCD      0x3fc85b95
                  |L1.76|
                          DCD      0x472d2a00
                  |L1.80|
                          DCD      0x41200000

                          AREA ||i.BMP085_RecvACK||, CODE, READONLY, ALIGN=2

                  BMP085_RecvACK PROC
;;;119    **************************************/
;;;120    u8 BMP085_RecvACK()
000000  b570              PUSH     {r4-r6,lr}
;;;121    {
;;;122    
;;;123    #if 0
;;;124    	u8 ucErrTime=0;
;;;125    	SDA_IN();      //SDA����Ϊ����  
;;;126    	IIC_SDA=1;delay_us(1);	   
;;;127    	IIC_SCL=1;delay_us(1);	 
;;;128    	while(READ_SDA)
;;;129    	{
;;;130    		ucErrTime++;
;;;131    		if(ucErrTime>250)
;;;132    		{
;;;133    			IIC_Stop();
;;;134    			return 1;
;;;135    		}
;;;136    	}
;;;137    	IIC_SCL=0;//ʱ�����0 	   
;;;138    	return 0;  
;;;139    #endif
;;;140    	SDA_IN();      //SDA����Ϊ����  
000002  f7fffffe          BL       SDA_IN
;;;141        IIC_SCL = 1;
000006  4c09              LDR      r4,|L2.44|
000008  2001              MOVS     r0,#1
00000a  f8c402a4          STR      r0,[r4,#0x2a4]
;;;142        delay_us(5);
00000e  2005              MOVS     r0,#5
000010  f5047428          ADD      r4,r4,#0x2a0
000014  f7fffffe          BL       delay_us
;;;143    	cy =IIC_SDA ;
000018  6820              LDR      r0,[r4,#0]
00001a  4d05              LDR      r5,|L2.48|
00001c  7068              STRB     r0,[r5,#1]
;;;144    	IIC_SCL = 0;
00001e  2000              MOVS     r0,#0
000020  6060              STR      r0,[r4,#4]
;;;145        delay_us(5);
000022  2005              MOVS     r0,#5
000024  f7fffffe          BL       delay_us
;;;146    	return cy;
000028  7868              LDRB     r0,[r5,#1]  ; cy
;;;147    }
00002a  bd70              POP      {r4-r6,pc}
;;;148    
                          ENDP

                  |L2.44|
                          DCD      0x42408000
                  |L2.48|
                          DCD      ||.data||

                          AREA ||i.BMP085_RecvByte||, CODE, READONLY, ALIGN=1

                  BMP085_RecvByte PROC
;;;175    **************************************/
;;;176    u8 BMP085_RecvByte(void)
000000  f7ffbffe          B.W      IIC_Read_Byte
;;;177    {
;;;178     u8 dat;
;;;179    #if 0
;;;180    	unsigned char i,receive=0;
;;;181    	SDA_IN();//SDA����Ϊ����
;;;182        for(i=0;i<8;i++ )
;;;183    	{
;;;184            IIC_SCL=0; 
;;;185            delay_us(2);
;;;186    		IIC_SCL=1;
;;;187            receive<<=1;
;;;188            if(READ_SDA)receive++;   
;;;189    		delay_us(1); 
;;;190        }					 
;;;191        if (!ack)
;;;192            IIC_NAck();//����nACK
;;;193        else
;;;194            IIC_Ack(); //����ACK   
;;;195        return receive;
;;;196    #endif
;;;197    	dat =IIC_Read_Byte();
;;;198        return  dat;
;;;199    	
;;;200    }
;;;201    
                          ENDP


                          AREA ||i.BMP085_SendACK||, CODE, READONLY, ALIGN=2

                  BMP085_SendACK PROC
;;;102    **************************************/
;;;103    void BMP085_SendACK(u8 ack)
000000  b570              PUSH     {r4-r6,lr}
;;;104    {
000002  4605              MOV      r5,r0
;;;105    // if(ack == 0)
;;;106    //	IIC_Ack();
;;;107     //else
;;;108     //	IIC_NAck();
;;;109    	 SDA_OUT();      //SDA����Ϊ����  
000004  f7fffffe          BL       SDA_OUT
;;;110    	 IIC_SDA = ack;
000008  4c08              LDR      r4,|L4.44|
00000a  f8c452a0          STR      r5,[r4,#0x2a0]
;;;111         IIC_SCL = 1;
00000e  2001              MOVS     r0,#1
000010  f8c402a4          STR      r0,[r4,#0x2a4]
;;;112    	 delay_us(5);
000014  2005              MOVS     r0,#5
000016  f5047428          ADD      r4,r4,#0x2a0
00001a  f7fffffe          BL       delay_us
;;;113         IIC_SCL = 0;
00001e  2000              MOVS     r0,#0
000020  6060              STR      r0,[r4,#4]
;;;114    	 delay_us(5);
000022  e8bd4070          POP      {r4-r6,lr}
000026  2005              MOVS     r0,#5
000028  f7ffbffe          B.W      delay_us
;;;115    }
;;;116    
                          ENDP

                  |L4.44|
                          DCD      0x42408000

                          AREA ||i.BMP085_SendByte||, CODE, READONLY, ALIGN=1

                  BMP085_SendByte PROC
;;;151    **************************************/
;;;152    void BMP085_SendByte(u8 txd)
000000  b510              PUSH     {r4,lr}
;;;153    {
;;;154    
;;;155    #if 0
;;;156        u8 i;
;;;157    	SDA_OUT();      //SDA����Ϊ����  
;;;158        for (i=0; i<8; i++)         //8λ������
;;;159        { 
;;;160            txd cy;               //�����ݿ�
;;;161            IIC_SCL = 1;                //����ʱ����
;;;162            delay_us(5);             //��ʱ
;;;163            IIC_SCL = 0;                //����ʱ����
;;;164            delay_us(5);            //��ʱ
;;;165        }
;;;166        BMP085_RecvACK(); 
;;;167    	#endif
;;;168    
;;;169    	IIC_Send_Byte(txd);
000002  f7fffffe          BL       IIC_Send_Byte
;;;170    	BMP085_RecvACK();
000006  e8bd4010          POP      {r4,lr}
00000a  f7ffbffe          B.W      BMP085_RecvACK
;;;171    }
;;;172    
                          ENDP


                          AREA ||i.BMP085_Start||, CODE, READONLY, ALIGN=1

                  BMP085_Start PROC
;;;85     **************************************/
;;;86     void BMP085_Start()
000000  f7ffbffe          B.W      IIC_Start
;;;87     {
;;;88     	IIC_Start();
;;;89     }
;;;90     
                          ENDP


                          AREA ||i.BMP085_Stop||, CODE, READONLY, ALIGN=1

                  BMP085_Stop PROC
;;;93     **************************************/
;;;94     void BMP085_Stop()
000000  f7ffbffe          B.W      IIC_Stop
;;;95     {
;;;96     	IIC_Stop(); 
;;;97     }
;;;98     
                          ENDP


                          AREA ||i.BMP085_get_process||, CODE, READONLY, ALIGN=2

                  BMP085_get_process PROC
;;;687    //*********************************************************
;;;688    void BMP085_get_process(void)
000000  480b              LDR      r0,|L8.48|
;;;689    { 
000002  b500              PUSH     {lr}
;;;690    	if(bmp_mode_type == BMP180_TYPE)
000004  7800              LDRB     r0,[r0,#0]  ; bmp_mode_type
000006  b089              SUB      sp,sp,#0x24           ;689
000008  b158              CBZ      r0,|L8.34|
;;;691    	{
;;;692    		bmp085Convert();
;;;693    		ConvAltitude();
;;;694    	}
;;;695    	else
;;;696    	{
;;;697    		bmp280_read_pressure_tempreature(bmp);
00000a  2224              MOVS     r2,#0x24
00000c  4909              LDR      r1,|L8.52|
00000e  4668              MOV      r0,sp
000010  f7fffffe          BL       __aeabi_memcpy4
000014  4807              LDR      r0,|L8.52|
000016  3810              SUBS     r0,r0,#0x10
000018  c80f              LDM      r0,{r0-r3}
00001a  f7fffffe          BL       bmp280_read_pressure_tempreature
;;;698    	}	
;;;699    } 
00001e  b009              ADD      sp,sp,#0x24
000020  bd00              POP      {pc}
                  |L8.34|
000022  f7fffffe          BL       bmp085Convert
000026  b009              ADD      sp,sp,#0x24           ;693
000028  f85deb04          POP      {lr}                  ;693
00002c  f7ffbffe          B.W      ConvAltitude
                          ENDP

                  |L8.48|
                          DCD      ||.data||
                  |L8.52|
                          DCD      ||.bss||+0x10

                          AREA ||i.ConvAltitude||, CODE, READONLY, ALIGN=2

                  ConvAltitude PROC
;;;448    *****************************************************************/
;;;449    void ConvAltitude(void)
000000  b510              PUSH     {r4,lr}
;;;450    {
;;;451    
;;;452        extern u8 guji_mode;
;;;453    
;;;454        if((guji_mode > RECORED_IDLE)&&(gpsx->fixmode != 3))
000002  4812              LDR      r0,|L9.76|
000004  4c12              LDR      r4,|L9.80|
000006  7800              LDRB     r0,[r0,#0]  ; guji_mode
000008  b120              CBZ      r0,|L9.20|
00000a  6820              LDR      r0,[r4,#0]  ; gpsx
00000c  f8900073          LDRB     r0,[r0,#0x73]
000010  2803              CMP      r0,#3
000012  d113              BNE      |L9.60|
                  |L9.20|
;;;455            return;    
;;;456    
;;;457    	Altitude = BMP085_Get_Altitude();
000014  f7fffffe          BL       BMP085_Get_Altitude
000018  490e              LDR      r1,|L9.84|
;;;458    
;;;459        if(system_flag_table->ajust_Arr_flag == 1)
00001a  4a0f              LDR      r2,|L9.88|
00001c  6208              STR      r0,[r1,#0x20]  ; Altitude
00001e  6812              LDR      r2,[r2,#0]  ; system_flag_table
000020  f8923028          LDRB     r3,[r2,#0x28]
000024  2b01              CMP      r3,#1
000026  d00a              BEQ      |L9.62|
;;;460        {
;;;461            Altitude = Altitude - (system_flag_table->ajust_arr*10);
;;;462        }
;;;463        else
;;;464        {
;;;465         	  if(system_flag_table->run_mode == 1)
000028  7810              LDRB     r0,[r2,#0]
00002a  2801              CMP      r0,#1
00002c  d106              BNE      |L9.60|
;;;466        	  {
;;;467        	      if(gpsx->fixmode == 3)  
00002e  6820              LDR      r0,[r4,#0]  ; gpsx
000030  f8902073          LDRB     r2,[r0,#0x73]
000034  2a03              CMP      r2,#3
000036  d101              BNE      |L9.60|
;;;468        	      {
;;;469      		          Altitude = gpsx->altitude;
000038  6fc0              LDR      r0,[r0,#0x7c]
                  |L9.58|
00003a  6208              STR      r0,[r1,#0x20]         ;461  ; Altitude
                  |L9.60|
;;;470        	      }
;;;471        	  }
;;;472      
;;;473        }
;;;474    	  		  	
;;;475    #if 0
;;;476    	if(gpsx->fixmode == 3)  
;;;477    		{
;;;478    		if((gpsx->speed/1000>400)||((gpsx->altitude/10)>8000))	  
;;;479    			Altitude = (gpsx->altitude/10)*100;
;;;480    		}
;;;481    #endif	
;;;482    	//v1000_debug("system_flag_table->ajust_arr: %d m \n\n",system_flag_table->ajust_arr);
;;;483    	//Altitude=(Altitude+BMP085_Get_Altitude())/2;
;;;484    /**************ȡ10�β���ֵ��ƽ��ֵ��Ϊ�����o�������㷨���ڼ���Ч��*************/
;;;485    
;;;486    #if 0
;;;487    		conversion(Altitude);
;;;488    		v1000_debug("\r\n H: %ld m \n\n",Altitude);
;;;489    		if(flag ==0)
;;;490    			sprintf((char *)dtbuf_jian,"H: +%c%c%c%c.%cm",wan,qian,bai,shi,ge);	//�õ������ַ���		
;;;491    		else	
;;;492    			sprintf((char *)dtbuf_jian,"H: -%c%c%c%c.%cm",wan,qian,bai,shi,ge);	//�õ������ַ���		
;;;493    		OLED_ShowString(0,32,dtbuf_jian);
;;;494    
;;;495    	AltitudeTempFlag++;									//��־�Լ�
;;;496    	if(AltitudeTempFlag>=10)
;;;497    		{
;;;498    		AltitudeTempFlag=0;		
;;;499    		Tempnum/=10;//�����ƽ��ֵ
;;;500    		conversion(Tempnum);	
;;;501    		v1000_debug("\r\n H: %ld m \n\n",Tempnum);
;;;502    		Tempnum = 0;
;;;503    		if(flag ==0)
;;;504    			sprintf((char *)dtbuf_jian,"H: +%c%c%c.%c%cm",wan,qian,bai,shi,ge);	//�õ������ַ���		
;;;505    		else	
;;;506    			sprintf((char *)dtbuf_jian,"H: -%c%c%c.%c%cm",wan,qian,bai,shi,ge);	//�õ������ַ���		
;;;507    		}
;;;508    	
;;;509    		Tempnum+=Altitude;			//���ݱ�־�������ݵ�����
;;;510    
;;;511    #endif
;;;512    
;;;513    
;;;514    
;;;515    }
00003c  bd10              POP      {r4,pc}
                  |L9.62|
00003e  6a52              LDR      r2,[r2,#0x24]         ;461
000040  4252              RSBS     r2,r2,#0              ;461
000042  eb020282          ADD      r2,r2,r2,LSL #2       ;461
000046  eb000042          ADD      r0,r0,r2,LSL #1       ;461
00004a  e7f6              B        |L9.58|
;;;516    
                          ENDP

                  |L9.76|
                          DCD      guji_mode
                  |L9.80|
                          DCD      gpsx
                  |L9.84|
                          DCD      ||.data||
                  |L9.88|
                          DCD      system_flag_table

                          AREA ||i.Init_BMP085||, CODE, READONLY, ALIGN=2

                  Init_BMP085 PROC
;;;300    //��ʼ��BMP085��������Ҫ��ο�pdf�����޸�**************
;;;301    void Init_BMP085(void)
000000  b510              PUSH     {r4,lr}
;;;302    {
;;;303    
;;;304    //	delay_ms(50);
;;;305    //	v1000_debug("\nInit_BMP085!\n");
;;;306    	ac1 = Multiple_read(0xAA);
000002  20aa              MOVS     r0,#0xaa
000004  f7fffffe          BL       Multiple_read
000008  4c15              LDR      r4,|L10.96|
00000a  8060              STRH     r0,[r4,#2]
;;;307    	ac2 = Multiple_read(0xAC);
00000c  20ac              MOVS     r0,#0xac
00000e  f7fffffe          BL       Multiple_read
000012  80a0              STRH     r0,[r4,#4]
;;;308    	ac3 = Multiple_read(0xAE);
000014  20ae              MOVS     r0,#0xae
000016  f7fffffe          BL       Multiple_read
00001a  80e0              STRH     r0,[r4,#6]
;;;309    	ac4 = Multiple_read(0xB0);
00001c  20b0              MOVS     r0,#0xb0
00001e  f7fffffe          BL       Multiple_read
000022  8120              STRH     r0,[r4,#8]
;;;310    	ac5 = Multiple_read(0xB2);
000024  20b2              MOVS     r0,#0xb2
000026  f7fffffe          BL       Multiple_read
00002a  8160              STRH     r0,[r4,#0xa]
;;;311    	ac6 = Multiple_read(0xB4);
00002c  20b4              MOVS     r0,#0xb4
00002e  f7fffffe          BL       Multiple_read
000032  81a0              STRH     r0,[r4,#0xc]
;;;312    	b1 =  Multiple_read(0xB6);
000034  20b6              MOVS     r0,#0xb6
000036  f7fffffe          BL       Multiple_read
00003a  81e0              STRH     r0,[r4,#0xe]
;;;313    	b2 =  Multiple_read(0xB8);
00003c  20b8              MOVS     r0,#0xb8
00003e  f7fffffe          BL       Multiple_read
000042  8220              STRH     r0,[r4,#0x10]
;;;314    	mb =  Multiple_read(0xBA);
000044  20ba              MOVS     r0,#0xba
000046  f7fffffe          BL       Multiple_read
00004a  8260              STRH     r0,[r4,#0x12]
;;;315    	mc =  Multiple_read(0xBC);
00004c  20bc              MOVS     r0,#0xbc
00004e  f7fffffe          BL       Multiple_read
000052  82a0              STRH     r0,[r4,#0x14]
;;;316    	md =  Multiple_read(0xBE);
000054  20be              MOVS     r0,#0xbe
000056  f7fffffe          BL       Multiple_read
00005a  82e0              STRH     r0,[r4,#0x16]
;;;317    
;;;318    //	v1000_debug("\r\nBMP085   ac1 :%d,ac2 :%d,ac3 :%d,ac4 :%d,ac5 :%d,ac6 :%d,b1 :%d,b2 :%d, mb :%d, mc :%d, md :%d!\n",
;;;319    //		ac1,ac2,ac3,ac4,ac5,ac6,b1,b2,mb,mc,md);
;;;320    }
00005c  bd10              POP      {r4,pc}
;;;321    
                          ENDP

00005e  0000              DCW      0x0000
                  |L10.96|
                          DCD      ||.data||

                          AREA ||i.Multiple_read||, CODE, READONLY, ALIGN=1

                  Multiple_read PROC
;;;242    //*********************************************************
;;;243    short Multiple_read(u8 REG_Address)
000000  b570              PUSH     {r4-r6,lr}
;;;244    {   
000002  4604              MOV      r4,r0
000004  f7fffffe          BL       IIC_Start
;;;245    	u8 msb, lsb;
;;;246    	short _data;
;;;247        BMP085_Start();                          //��ʼ�ź�
;;;248        BMP085_SendByte(BMP085_SlaveAddress);    //�����豸��ַ+д�ź�
000008  20ee              MOVS     r0,#0xee
00000a  f7fffffe          BL       BMP085_SendByte
;;;249        BMP085_SendByte(REG_Address);             //���ʹ洢��Ԫ��ַ
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       BMP085_SendByte
000014  f7fffffe          BL       IIC_Start
;;;250        BMP085_Start();                          //��ʼ�ź�
;;;251        BMP085_SendByte(BMP085_SlaveAddress+1);         //�����豸��ַ+���ź�
000018  20ef              MOVS     r0,#0xef
00001a  f7fffffe          BL       BMP085_SendByte
00001e  f7fffffe          BL       IIC_Read_Byte
000022  4604              MOV      r4,r0
;;;252    
;;;253        msb = BMP085_RecvByte();                 //BUF[0]�洢
;;;254        BMP085_SendACK(0);                       //��ӦACK
000024  2000              MOVS     r0,#0
000026  f7fffffe          BL       BMP085_SendACK
00002a  f7fffffe          BL       IIC_Read_Byte
;;;255        lsb = BMP085_RecvByte();     
00002e  4605              MOV      r5,r0
;;;256    	BMP085_SendACK(1);                       //���һ��������Ҫ��NOACK
000030  2001              MOVS     r0,#1
000032  f7fffffe          BL       BMP085_SendACK
000036  f7fffffe          BL       IIC_Stop
;;;257    
;;;258        BMP085_Stop();                           //ֹͣ�ź�
;;;259    	delay_ms(5);
00003a  2005              MOVS     r0,#5
00003c  f7fffffe          BL       delay_ms
;;;260        _data = msb << 8;
000040  0220              LSLS     r0,r4,#8
000042  b201              SXTH     r1,r0
;;;261    	_data |= lsb;	
000044  ea410005          ORR      r0,r1,r5
;;;262    	return _data;
;;;263    }
000048  bd70              POP      {r4-r6,pc}
;;;264    //********************************************************************
                          ENDP


                          AREA ||i.arry_Read||, CODE, READONLY, ALIGN=1

                  arry_Read PROC
;;;220    //���ֽڶ�ȡBMP085�ڲ�����********************************
;;;221    int8_t arry_Read(int8_t Slave_Address,int8_t REG_Address,uint8_t * REG_data,uint16_t REG_LEN)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;222    {  
000004  461e              MOV      r6,r3
000006  4690              MOV      r8,r2
000008  460f              MOV      r7,r1
00000a  4605              MOV      r5,r0
;;;223    	uint16_t i = 0;
00000c  2400              MOVS     r4,#0
00000e  f7fffffe          BL       IIC_Start
;;;224    
;;;225    	BMP085_Start();                          //��ʼ�ź�
;;;226    	BMP085_SendByte(Slave_Address);           //�����豸��ַ+д�ź�
000012  b2e8              UXTB     r0,r5
000014  f7fffffe          BL       BMP085_SendByte
;;;227    	BMP085_SendByte(REG_Address);            //���ʹ洢��Ԫ��ַ	
000018  b2f8              UXTB     r0,r7
00001a  f7fffffe          BL       BMP085_SendByte
00001e  f7fffffe          BL       IIC_Start
000022  1c6d              ADDS     r5,r5,#1
;;;228    	BMP085_Start();                          //��ʼ�ź�
;;;229    	BMP085_SendByte(Slave_Address+1);         //�����豸��ַ+���ź�
000024  b2e8              UXTB     r0,r5
000026  f7fffffe          BL       BMP085_SendByte
;;;230    	for(i = 0;i<REG_LEN; i++)
00002a  e008              B        |L12.62|
                  |L12.44|
00002c  f7fffffe          BL       IIC_Read_Byte
;;;231    	{
;;;232    		REG_data[i]=BMP085_RecvByte();              //�����Ĵ�������
000030  f8080004          STRB     r0,[r8,r4]
;;;233    		BMP085_SendACK(0);   
000034  2000              MOVS     r0,#0
000036  f7fffffe          BL       BMP085_SendACK
00003a  1c64              ADDS     r4,r4,#1
00003c  b2a4              UXTH     r4,r4                 ;230
                  |L12.62|
00003e  42b4              CMP      r4,r6                 ;230
000040  d3f4              BCC      |L12.44|
;;;234    	}
;;;235    	BMP085_SendACK(1);   
000042  2001              MOVS     r0,#1
000044  f7fffffe          BL       BMP085_SendACK
000048  f7fffffe          BL       IIC_Stop
;;;236    	BMP085_Stop();                           //ֹͣ�ź�
;;;237    	return 0; 
00004c  2000              MOVS     r0,#0
;;;238    }
00004e  e8bd81f0          POP      {r4-r8,pc}
;;;239    
                          ENDP


                          AREA ||i.arry_Write||, CODE, READONLY, ALIGN=1

                  arry_Write PROC
;;;203    
;;;204    void arry_Write(int8_t SlaveAddress,int8_t REG_Address,uint8_t * REG_data,uint16_t REG_LEN)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;205    {
000004  461d              MOV      r5,r3
000006  4690              MOV      r8,r2
000008  460e              MOV      r6,r1
00000a  4607              MOV      r7,r0
;;;206    	uint16_t i = 0;
00000c  2400              MOVS     r4,#0
00000e  f7fffffe          BL       IIC_Start
;;;207    
;;;208    	BMP085_Start();                  //��ʼ�ź�
;;;209    	BMP085_SendByte(SlaveAddress);   //�����豸��ַ+д�ź�
000012  b2f8              UXTB     r0,r7
000014  f7fffffe          BL       BMP085_SendByte
;;;210    	BMP085_SendByte(REG_Address);    //�ڲ��Ĵ�����ַ
000018  b2f0              UXTB     r0,r6
00001a  f7fffffe          BL       BMP085_SendByte
;;;211    	for(i = 0;i>REG_LEN;i++)
00001e  e005              B        |L13.44|
                  |L13.32|
;;;212    	{
;;;213    		BMP085_SendByte(REG_data[i]);       //�ڲ��Ĵ�������
000020  f8180004          LDRB     r0,[r8,r4]
000024  f7fffffe          BL       BMP085_SendByte
000028  1c64              ADDS     r4,r4,#1
00002a  b2a4              UXTH     r4,r4                 ;211
                  |L13.44|
00002c  42ac              CMP      r4,r5                 ;211
00002e  d8f7              BHI      |L13.32|
000030  e8bd41f0          POP      {r4-r8,lr}            ;211
000034  f7ffbffe          B.W      IIC_Stop
;;;214    	}
;;;215    
;;;216    	BMP085_Stop();                   //����ֹͣ�ź�
;;;217    }
;;;218    
                          ENDP


                          AREA ||i.bmp085Convert||, CODE, READONLY, ALIGN=2

                  bmp085Convert PROC
;;;327    
;;;328    void bmp085Convert(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;329    {
;;;330    	long ut;
;;;331    	long up;
;;;332    	long x1, x2, b5, b6, x3, b3, p;
;;;333    	unsigned long b4, b7;
;;;334    	long pressure_new;
;;;335    
;;;336    //	u8 dtbuf_jian[50];  
;;;337    	
;;;338    	ut = bmp085ReadTemp();
000004  f7fffffe          BL       bmp085ReadTemp
000008  4605              MOV      r5,r0
;;;339    	//ut = bmp085ReadTemp();	   // ��ȡ�¶�
;;;340    	up = bmp085ReadPressure();
00000a  f7fffffe          BL       bmp085ReadPressure
;;;341    //	up = bmp085ReadPressure();  // ��ȡѹǿ
;;;342    	
;;;343    	x1 = ((long)ut - ac6) * ac5 >> 15;
00000e  4c43              LDR      r4,|L14.284|
000010  4607              MOV      r7,r0                 ;340
000012  89a0              LDRH     r0,[r4,#0xc]  ; ac6
000014  8961              LDRH     r1,[r4,#0xa]  ; ac5
000016  1a28              SUBS     r0,r5,r0
000018  4348              MULS     r0,r1,r0
;;;344    	x2 = ((long) mc << 11) / (x1 + md);
00001a  f9b41014          LDRSH    r1,[r4,#0x14]  ; mc
00001e  f9b42016          LDRSH    r2,[r4,#0x16]  ; md
000022  13c0              ASRS     r0,r0,#15             ;343
000024  02c9              LSLS     r1,r1,#11
000026  4402              ADD      r2,r2,r0
000028  fb91f1f2          SDIV     r1,r1,r2
;;;345    	b5 = x1 + x2;
00002c  1845              ADDS     r5,r0,r1
;;;346    
;;;347    //	 if(temperature == 0xffffffff)	 	
;;;348        temperature = (b5 + 8) >> 4;
00002e  f1050008          ADD      r0,r5,#8
;;;349    
;;;350    
;;;351        if(system_flag_table->run_mode == 1)
000032  493b              LDR      r1,|L14.288|
000034  1100              ASRS     r0,r0,#4              ;348
000036  61a0              STR      r0,[r4,#0x18]  ; temperature
000038  6809              LDR      r1,[r1,#0]  ; system_flag_table
00003a  7809              LDRB     r1,[r1,#0]
00003c  2901              CMP      r1,#1
00003e  d040              BEQ      |L14.194|
;;;352        {
;;;353        	temperature = temperature-(temperature*0.22);
;;;354        }
;;;355        else
;;;356        {
;;;357        	temperature = temperature-(temperature*0.1);
000040  f7fffffe          BL       __aeabi_i2d
000044  4688              MOV      r8,r1
000046  4606              MOV      r6,r0
000048  4a36              LDR      r2,|L14.292|
00004a  4b37              LDR      r3,|L14.296|
                  |L14.76|
00004c  f7fffffe          BL       __aeabi_dmul
000050  4632              MOV      r2,r6
000052  4643              MOV      r3,r8
000054  f7fffffe          BL       __aeabi_drsub
000058  f7fffffe          BL       __aeabi_d2iz
;;;358        }
;;;359    
;;;360    //	 else
;;;361    	 	{
;;;362    	//	temperature = (temperature +((b5 + 8) >> 4))/2;
;;;363    		// temperature = (temperature+temperature_new)/2;
;;;364    	 	}
;;;365    #if 0
;;;366    	 //*************
;;;367    
;;;368    	 conversion(temperature);
;;;369    	v1000_debug("\r\ntemperature : %ld \n\n",temperature);
;;;370    	 sprintf((char *)dtbuf_jian,"T:  %c%c.%cC",bai,shi,ge);	//�õ������ַ���
;;;371    	 OLED_ShowString(0,16,dtbuf_jian);	 	
;;;372         //*************
;;;373     #endif
;;;374    	
;;;375    	b6 = b5 - 4000;
;;;376    	x1 = (b2 * (b6 * b6 >> 12)) >> 11;
00005c  61a0              STR      r0,[r4,#0x18]  ; temperature
00005e  f5a5657a          SUB      r5,r5,#0xfa0          ;357
000062  fb05f005          MUL      r0,r5,r5
000066  f9b41010          LDRSH    r1,[r4,#0x10]  ; b2
00006a  1300              ASRS     r0,r0,#12
;;;377    	x2 = ac2 * b6 >> 11;
00006c  f9b42004          LDRSH    r2,[r4,#4]  ; ac2
000070  4341              MULS     r1,r0,r1              ;376
000072  12c9              ASRS     r1,r1,#11             ;376
000074  436a              MULS     r2,r5,r2
;;;378    	x3 = x1 + x2;
000076  eb0121e2          ADD      r1,r1,r2,ASR #11
;;;379    	b3 = (((long)ac1 * 4 + x3) + 2)/4;
00007a  f9b42002          LDRSH    r2,[r4,#2]  ; ac1
;;;380    	x1 = ac3 * b6 >> 13;
;;;381    	x2 = (b1 * (b6 * b6 >> 12)) >> 16;
00007e  f9b4300e          LDRSH    r3,[r4,#0xe]  ; b1
000082  eb010182          ADD      r1,r1,r2,LSL #2       ;379
000086  1c89              ADDS     r1,r1,#2              ;379
000088  17ca              ASRS     r2,r1,#31             ;379
00008a  eb017192          ADD      r1,r1,r2,LSR #30      ;379
00008e  108a              ASRS     r2,r1,#2              ;379
000090  f9b41006          LDRSH    r1,[r4,#6]            ;380  ; ac3
000094  4358              MULS     r0,r3,r0
000096  4369              MULS     r1,r5,r1              ;380
000098  1349              ASRS     r1,r1,#13             ;380
;;;382    	x3 = ((x1 + x2) + 2) >> 2;
00009a  eb014020          ADD      r0,r1,r0,ASR #16
00009e  1c80              ADDS     r0,r0,#2
0000a0  1080              ASRS     r0,r0,#2
;;;383    	b4 = (ac4 * (unsigned long) (x3 + 32768)) >> 15;
0000a2  8921              LDRH     r1,[r4,#8]  ; ac4
0000a4  f5004000          ADD      r0,r0,#0x8000
0000a8  4341              MULS     r1,r0,r1
;;;384    	b7 = ((unsigned long) up - b3) * (50000 >> OSS);
0000aa  1ab8              SUBS     r0,r7,r2
0000ac  f24c3250          MOV      r2,#0xc350
0000b0  0bc9              LSRS     r1,r1,#15             ;383
0000b2  4350              MULS     r0,r2,r0
;;;385    	if( b7 < 0x80000000)
0000b4  f1b04f00          CMP      r0,#0x80000000
0000b8  d20a              BCS      |L14.208|
;;;386    	     p = (b7 * 2) / b4 ;
0000ba  0040              LSLS     r0,r0,#1
0000bc  fbb0f0f1          UDIV     r0,r0,r1
0000c0  e009              B        |L14.214|
                  |L14.194|
0000c2  f7fffffe          BL       __aeabi_i2d
0000c6  4688              MOV      r8,r1                 ;353
0000c8  4606              MOV      r6,r0                 ;353
0000ca  4a18              LDR      r2,|L14.300|
0000cc  4b18              LDR      r3,|L14.304|
0000ce  e7bd              B        |L14.76|
                  |L14.208|
;;;387               else  
;;;388    		    p = (b7 / b4) * 2;
0000d0  fbb0f0f1          UDIV     r0,r0,r1
0000d4  0040              LSLS     r0,r0,#1
                  |L14.214|
;;;389    	x1 = (p >> 8) * (p >> 8);
0000d6  1201              ASRS     r1,r0,#8
0000d8  4349              MULS     r1,r1,r1
;;;390    	x1 = (x1 * 3038) >> 16;
0000da  f64032de          MOV      r2,#0xbde
0000de  4351              MULS     r1,r2,r1
0000e0  140a              ASRS     r2,r1,#16
;;;391    	x2 = (-7357 * p) >> 16;
0000e2  4914              LDR      r1,|L14.308|
0000e4  4341              MULS     r1,r0,r1
0000e6  140b              ASRS     r3,r1,#16
;;;392    	 if(pressure == 0xffffffff)	 
0000e8  69e1              LDR      r1,[r4,#0x1c]  ; pressure
0000ea  1c4d              ADDS     r5,r1,#1
0000ec  d00f              BEQ      |L14.270|
;;;393    	 	pressure = p + ((x1 + x2 + 3791) >> 4);
;;;394    	 else
;;;395    	{
;;;396    	 	pressure_new = (pressure +(p + ((x1 + x2 + 3791) >> 4)))/2;	 	
0000ee  441a              ADD      r2,r2,r3
0000f0  f60262cf          ADD      r2,r2,#0xecf
0000f4  eb001022          ADD      r0,r0,r2,ASR #4
0000f8  4408              ADD      r0,r0,r1
0000fa  eb0070d0          ADD      r0,r0,r0,LSR #31
;;;397    		pressure = (pressure+pressure_new)/2;
0000fe  eb010060          ADD      r0,r1,r0,ASR #1
000102  eb0070d0          ADD      r0,r0,r0,LSR #31
000106  1040              ASRS     r0,r0,#1
                  |L14.264|
000108  61e0              STR      r0,[r4,#0x1c]         ;393  ; pressure
;;;398    	}
;;;399    //	 conversion(pressure);
;;;400    
;;;401    //	  v1000_debug("\r\n 2: %ld!\n\n",pressure);
;;;402    //	 sprintf((char *)dtbuf_jian,"P: %c%c%c%c.%c%chpa",shiwan,wan,qian,bai,shi,ge);	//�õ������ַ���
;;;403    //	 OLED_ShowString(0,48,dtbuf_jian);	 	
;;;404    	
;;;405    }
00010a  e8bd81f0          POP      {r4-r8,pc}
                  |L14.270|
00010e  18d1              ADDS     r1,r2,r3              ;393
000110  f60161cf          ADD      r1,r1,#0xecf          ;393
000114  eb001021          ADD      r0,r0,r1,ASR #4       ;393
000118  e7f6              B        |L14.264|
;;;406    
                          ENDP

00011a  0000              DCW      0x0000
                  |L14.284|
                          DCD      ||.data||
                  |L14.288|
                          DCD      system_flag_table
                  |L14.292|
                          DCD      0x9999999a
                  |L14.296|
                          DCD      0x3fb99999
                  |L14.300|
                          DCD      0xc28f5c29
                  |L14.304|
                          DCD      0x3fcc28f5
                  |L14.308|
                          DCD      0xffffe343

                          AREA ||i.bmp085ReadPressure||, CODE, READONLY, ALIGN=1

                  bmp085ReadPressure PROC
;;;279    //*************************************************************
;;;280    long bmp085ReadPressure(void)
000000  b510              PUSH     {r4,lr}
000002  f7fffffe          BL       IIC_Start
;;;281    {
;;;282    	long pressure = 0;
;;;283    
;;;284        BMP085_Start();                   //��ʼ�ź�
;;;285        BMP085_SendByte(BMP085_SlaveAddress);   //�����豸��ַ+д�ź�
000006  20ee              MOVS     r0,#0xee
000008  f7fffffe          BL       BMP085_SendByte
;;;286        BMP085_SendByte(0xF4);	          // write register address
00000c  20f4              MOVS     r0,#0xf4
00000e  f7fffffe          BL       BMP085_SendByte
;;;287        BMP085_SendByte(0x34);       	  // write register data for pressure
000012  2034              MOVS     r0,#0x34
000014  f7fffffe          BL       BMP085_SendByte
000018  f7fffffe          BL       IIC_Stop
;;;288        BMP085_Stop();                    //����ֹͣ�ź�
;;;289    	delay_ms(5);    	                  // max time is 4.5ms
00001c  2005              MOVS     r0,#5
00001e  f7fffffe          BL       delay_ms
;;;290    	
;;;291    	pressure = Multiple_read(0xF6);
000022  20f6              MOVS     r0,#0xf6
000024  f7fffffe          BL       Multiple_read
;;;292    	pressure &= 0x0000FFFF;
000028  b280              UXTH     r0,r0
;;;293    	
;;;294    	return pressure;	
;;;295    	//return (long) bmp085ReadShort(0xF6);
;;;296    }
00002a  bd10              POP      {r4,pc}
;;;297    
                          ENDP


                          AREA ||i.bmp085ReadTemp||, CODE, READONLY, ALIGN=1

                  bmp085ReadTemp PROC
;;;264    //********************************************************************
;;;265    long bmp085ReadTemp(void)
000000  b510              PUSH     {r4,lr}
000002  f7fffffe          BL       IIC_Start
;;;266    {
;;;267    long temp = 0;
;;;268        BMP085_Start();                  //��ʼ�ź�
;;;269        BMP085_SendByte(BMP085_SlaveAddress);   //�����豸��ַ+д�ź�
000006  20ee              MOVS     r0,#0xee
000008  f7fffffe          BL       BMP085_SendByte
;;;270        BMP085_SendByte(0xF4);	          // write register address
00000c  20f4              MOVS     r0,#0xf4
00000e  f7fffffe          BL       BMP085_SendByte
;;;271        BMP085_SendByte(0x2E);       	// write register data for temp
000012  202e              MOVS     r0,#0x2e
000014  f7fffffe          BL       BMP085_SendByte
000018  f7fffffe          BL       IIC_Stop
;;;272        BMP085_Stop();                   //����ֹͣ�ź�
;;;273    	delay_ms(5);  	// max time is 4.5ms
00001c  2005              MOVS     r0,#5
00001e  f7fffffe          BL       delay_ms
;;;274    	temp = Multiple_read(0xF6);
000022  20f6              MOVS     r0,#0xf6
000024  f7fffffe          BL       Multiple_read
;;;275    //	v1000_debug("\r\n temp : %x \n\n",temp);
;;;276    	temp &= 0x0000FFFF;
000028  b280              UXTH     r0,r0
;;;277    	return temp;
;;;278    }
00002a  bd10              POP      {r4,pc}
;;;279    //*************************************************************
                          ENDP


                          AREA ||i.bmp280_read_pressure_tempreature||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  bmp280_read_pressure_tempreature PROC
;;;601    
;;;602    void bmp280_read_pressure_tempreature(struct bmp280_dev bmp)
000000  b40f              PUSH     {r0-r3}
;;;603    {
000002  b500              PUSH     {lr}
000004  b085              SUB      sp,sp,#0x14
;;;604    	int32_t temp32;
;;;605    	uint32_t pre32;
;;;606    	int8_t rslt;
;;;607    	struct bmp280_uncomp_data ucomp_data;
;;;608    
;;;609    	/* Reading the raw data from sensor */
;;;610    	rslt = bmp280_get_uncomp_data(&ucomp_data, &bmp);
000006  a906              ADD      r1,sp,#0x18
000008  a801              ADD      r0,sp,#4
00000a  f7fffffe          BL       bmp280_get_uncomp_data
;;;611    
;;;612    	/* Getting the compensated pressure using 32 bit precision */
;;;613    	rslt = bmp280_get_comp_pres_32bit(&pre32, ucomp_data.uncomp_press, &bmp);
00000e  aa06              ADD      r2,sp,#0x18
000010  a804              ADD      r0,sp,#0x10
000012  9902              LDR      r1,[sp,#8]
000014  f7fffffe          BL       bmp280_get_comp_pres_32bit
;;;614    	/* Getting the 32 bit compensated temperature */
;;;615    	rslt = bmp280_get_comp_temp_32bit(&temp32, ucomp_data.uncomp_temp, &bmp);
000018  aa06              ADD      r2,sp,#0x18
00001a  a803              ADD      r0,sp,#0xc
00001c  9901              LDR      r1,[sp,#4]
00001e  f7fffffe          BL       bmp280_get_comp_temp_32bit
;;;616    
;;;617    	temperature =(int)(temp32&0xffff);
000022  9b03              LDR      r3,[sp,#0xc]
000024  4806              LDR      r0,|L17.64|
000026  b299              UXTH     r1,r3
;;;618    	pressure = (long)pre32;
000028  6181              STR      r1,[r0,#0x18]  ; temperature
00002a  9904              LDR      r1,[sp,#0x10]
;;;619    	
;;;620    	printf("UT: %d, UP: %d,,T32: %d, P32: %d, \r\n", ucomp_data.uncomp_temp,ucomp_data.uncomp_press, temp32, pre32);
00002c  61c1              STR      r1,[r0,#0x1c]  ; pressure
00002e  9100              STR      r1,[sp,#0]
000030  e9dd1201          LDRD     r1,r2,[sp,#4]
000034  a003              ADR      r0,|L17.68|
000036  f7fffffe          BL       __2printf
;;;621              
;;;622    }
00003a  b005              ADD      sp,sp,#0x14
00003c  f85dfb14          LDR      pc,[sp],#0x14
;;;623    
                          ENDP

                  |L17.64|
                          DCD      ||.data||
                  |L17.68|
000044  55543a20          DCB      "UT: %d, UP: %d,,T32: %d, P32: %d, \r\n",0
000048  25642c20
00004c  55503a20
000050  25642c2c
000054  5433323a
000058  2025642c
00005c  20503332
000060  3a202564
000064  2c200d0a
000068  00      
000069  00                DCB      0
00006a  00                DCB      0
00006b  00                DCB      0

                          AREA ||i.bmp_moudle_preinit||, CODE, READONLY, ALIGN=2

                  bmp_moudle_preinit PROC
;;;623    
;;;624    int bmp_moudle_preinit(void)
000000  b57c              PUSH     {r2-r6,lr}
;;;625    {
;;;626        int8_t rslt;
;;;627        struct bmp280_config conf;
;;;628    	
;;;629        /* Map the delay function pointer with the function responsible for implementing the delay */
;;;630        bmp.delay_ms = delay_ms;
000002  481f              LDR      r0,|L18.128|
000004  491d              LDR      r1,|L18.124|
;;;631    
;;;632        /* Assign device I2C address based on the status of SDO pin (GND for PRIMARY(0x76) & VDD for SECONDARY(0x77)) */
;;;633        bmp.dev_id = BMP280_I2C_ADDR_V1000;
;;;634    
;;;635        /* Select the interface mode as I2C */
;;;636        bmp.intf = BMP280_I2C_INTF;
000006  2401              MOVS     r4,#1
000008  60c1              STR      r1,[r0,#0xc]          ;633  ; bmp
00000a  21ee              MOVS     r1,#0xee              ;633
00000c  7041              STRB     r1,[r0,#1]            ;633
00000e  7084              STRB     r4,[r0,#2]
;;;637    
;;;638        /* Map the I2C read & write function pointer with the functions responsible for I2C bus transfer */
;;;639        bmp.read = i2c_reg_read;
000010  491c              LDR      r1,|L18.132|
;;;640        bmp.write = i2c_reg_write;
000012  6041              STR      r1,[r0,#4]  ; bmp
000014  491c              LDR      r1,|L18.136|
;;;641    
;;;642        /* To enable SPI interface: comment the above 4 lines and uncomment the below 4 lines */
;;;643    
;;;644        /*
;;;645         * bmp.dev_id = 0;
;;;646         * bmp.read = spi_reg_read;
;;;647         * bmp.write = spi_reg_write;
;;;648         * bmp.intf = BMP280_SPI_INTF;
;;;649         */
;;;650        rslt = bmp280_init(&bmp);
000016  6081              STR      r1,[r0,#8]  ; bmp
000018  f7fffffe          BL       bmp280_init
;;;651        if (rslt != BMP280_OK)
;;;652    	{
;;;653    		print_rslt(" bmp280_init status", rslt);
;;;654    		bmp_mode_type = BMP180_TYPE;
00001c  4d1b              LDR      r5,|L18.140|
00001e  0001              MOVS     r1,r0                 ;650
000020  d007              BEQ      |L18.50|
000022  a01b              ADR      r0,|L18.144|
000024  f7fffffe          BL       print_rslt
000028  2000              MOVS     r0,#0
00002a  7028              STRB     r0,[r5,#0]
;;;655    		Init_BMP085();
00002c  f7fffffe          BL       Init_BMP085
000030  e021              B        |L18.118|
                  |L18.50|
;;;656    	}        
;;;657        else
;;;658        {       
;;;659    		rslt = bmp280_get_config(&conf, &bmp);
000032  4913              LDR      r1,|L18.128|
000034  4668              MOV      r0,sp
000036  f7fffffe          BL       bmp280_get_config
;;;660    		printf(" bmp280 init OK");
00003a  a01a              ADR      r0,|L18.164|
00003c  f7fffffe          BL       __2printf
;;;661    
;;;662    		/* configuring the temperature oversampling, filter coefficient and output data rate */
;;;663    		/* Overwrite the desired settings */
;;;664    		conf.filter = BMP280_FILTER_COEFF_2;
000040  f88d4003          STRB     r4,[sp,#3]
;;;665    
;;;666    		/* Pressure oversampling set at 4x */
;;;667    		conf.os_pres = BMP280_OS_4X;
000044  2003              MOVS     r0,#3
000046  f88d0001          STRB     r0,[sp,#1]
;;;668    		conf.os_temp = BMP280_OS_4X;
00004a  f88d0000          STRB     r0,[sp,#0]
;;;669    		/* Setting the output data rate as 1HZ(1000ms) */
;;;670    		conf.odr = BMP280_ODR_1000_MS;
00004e  2005              MOVS     r0,#5
000050  f88d0002          STRB     r0,[sp,#2]
;;;671    		rslt = bmp280_set_config(&conf, &bmp);
000054  490a              LDR      r1,|L18.128|
000056  4668              MOV      r0,sp
000058  f7fffffe          BL       bmp280_set_config
00005c  4601              MOV      r1,r0
;;;672    		print_rslt(" bmp280_set_config status", rslt);
00005e  a015              ADR      r0,|L18.180|
000060  f7fffffe          BL       print_rslt
;;;673    
;;;674    		/* Always set the power mode after setting the configuration */
;;;675    		rslt = bmp280_set_power_mode(BMP280_NORMAL_MODE, &bmp);
000064  4906              LDR      r1,|L18.128|
000066  2003              MOVS     r0,#3
000068  f7fffffe          BL       bmp280_set_power_mode
00006c  4601              MOV      r1,r0
;;;676    		print_rslt(" bmp280_set_power_mode status", rslt);	
00006e  a018              ADR      r0,|L18.208|
000070  f7fffffe          BL       print_rslt
;;;677    
;;;678    		bmp_mode_type = BMP280_TYPE;	
000074  702c              STRB     r4,[r5,#0]
                  |L18.118|
;;;679        }
;;;680        
;;;681    
;;;682        return 0;
000076  2000              MOVS     r0,#0
;;;683    }
000078  bd7c              POP      {r2-r6,pc}
;;;684    
                          ENDP

00007a  0000              DCW      0x0000
                  |L18.124|
                          DCD      delay_ms
                  |L18.128|
                          DCD      ||.bss||
                  |L18.132|
                          DCD      i2c_reg_read
                  |L18.136|
                          DCD      i2c_reg_write
                  |L18.140|
                          DCD      ||.data||
                  |L18.144|
000090  20626d70          DCB      " bmp280_init status",0
000094  3238305f
000098  696e6974
00009c  20737461
0000a0  74757300
                  |L18.164|
0000a4  20626d70          DCB      " bmp280 init OK",0
0000a8  32383020
0000ac  696e6974
0000b0  204f4b00
                  |L18.180|
0000b4  20626d70          DCB      " bmp280_set_config status",0
0000b8  3238305f
0000bc  7365745f
0000c0  636f6e66
0000c4  69672073
0000c8  74617475
0000cc  7300    
0000ce  00                DCB      0
0000cf  00                DCB      0
                  |L18.208|
0000d0  20626d70          DCB      " bmp280_set_power_mode status",0
0000d4  3238305f
0000d8  7365745f
0000dc  706f7765
0000e0  725f6d6f
0000e4  64652073
0000e8  74617475
0000ec  7300    
0000ee  00                DCB      0
0000ef  00                DCB      0

                          AREA ||i.conversion||, CODE, READONLY, ALIGN=1

                  conversion PROC
;;;63     //*********************************************************
;;;64     void conversion(long temp_data)  
000000  4770              BX       lr
;;;65     {  
;;;66     #ifdef NEED_TO_LEDSHOW    
;;;67         shiwan=temp_data/100000+0x30 ;
;;;68         temp_data=temp_data%100000;   
;;;69         wan=temp_data/10000+0x30 ;
;;;70         temp_data=temp_data%10000;   
;;;71     	qian=temp_data/1000+0x30 ;
;;;72         temp_data=temp_data%1000;    
;;;73         bai=temp_data/100+0x30   ;
;;;74         temp_data=temp_data%100;     
;;;75         shi=temp_data/10+0x30    ;
;;;76         temp_data=temp_data%10;      
;;;77         ge=temp_data+0x30;
;;;78     #endif 	
;;;79     }
;;;80     
                          ENDP


                          AREA ||i.i2c_reg_read||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_x
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_longlong_hex
                  i2c_reg_read PROC
;;;552     */
;;;553    int8_t i2c_reg_read(uint8_t i2c_addr, uint8_t reg_addr, uint8_t *reg_data, uint16_t length)
000000  b5f8              PUSH     {r3-r7,lr}
;;;554    {
000002  460c              MOV      r4,r1
000004  4605              MOV      r5,r0
000006  461f              MOV      r7,r3
000008  4616              MOV      r6,r2
;;;555    	
;;;556    	arry_Read(i2c_addr,reg_addr,reg_data,length);
00000a  b249              SXTB     r1,r1
00000c  b240              SXTB     r0,r0
00000e  f7fffffe          BL       arry_Read
;;;557    	printf("i2c read :  i2c_addr=%x  ,reg_addr=%x length =%d data =%x \r\n", i2c_addr,reg_addr,length,reg_data[0]);
000012  7830              LDRB     r0,[r6,#0]
000014  9000              STR      r0,[sp,#0]
000016  463b              MOV      r3,r7
000018  4622              MOV      r2,r4
00001a  4629              MOV      r1,r5
00001c  a002              ADR      r0,|L20.40|
00001e  f7fffffe          BL       __2printf
;;;558    	/* Implement the I2C read routine according to the target machine. */
;;;559    	return 0;
000022  2000              MOVS     r0,#0
;;;560    }
000024  bdf8              POP      {r3-r7,pc}
;;;561    
                          ENDP

000026  0000              DCW      0x0000
                  |L20.40|
000028  69326320          DCB      "i2c read :  i2c_addr=%x  ,reg_addr=%x length =%d data ="
00002c  72656164
000030  203a2020
000034  6932635f
000038  61646472
00003c  3d257820
000040  202c7265
000044  675f6164
000048  64723d25
00004c  78206c65
000050  6e677468
000054  203d2564
000058  20646174
00005c  61203d  
00005f  2578200d          DCB      "%x \r\n",0
000063  0a00    
000065  00                DCB      0
000066  00                DCB      0
000067  00                DCB      0

                          AREA ||i.i2c_reg_write||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_x
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_longlong_hex
                  i2c_reg_write PROC
;;;531     */
;;;532    int8_t i2c_reg_write(uint8_t i2c_addr, uint8_t reg_addr, uint8_t *reg_data, uint16_t length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;533    {
000004  4617              MOV      r7,r2
000006  460c              MOV      r4,r1
;;;534    	printf("i2c write :  i2c_addr=%x  ,reg_addr=%x length =%d \r\n", i2c_addr,reg_addr,length);
000008  460a              MOV      r2,r1
00000a  4605              MOV      r5,r0                 ;533
00000c  4601              MOV      r1,r0
00000e  461e              MOV      r6,r3                 ;533
000010  a005              ADR      r0,|L21.40|
000012  f7fffffe          BL       __2printf
;;;535        /* Implement the I2C write routine according to the target machine. */\
;;;536    	arry_Write(i2c_addr,reg_addr,reg_data,length);
000016  4633              MOV      r3,r6
000018  463a              MOV      r2,r7
00001a  b261              SXTB     r1,r4
00001c  b268              SXTB     r0,r5
00001e  f7fffffe          BL       arry_Write
;;;537        return 0;
000022  2000              MOVS     r0,#0
;;;538    }
000024  e8bd81f0          POP      {r4-r8,pc}
;;;539    
                          ENDP

                  |L21.40|
000028  69326320          DCB      "i2c write :  i2c_addr=%x  ,reg_addr=%x length =%d \r\n",0
00002c  77726974
000030  65203a20
000034  20693263
000038  5f616464
00003c  723d2578
000040  20202c72
000044  65675f61
000048  6464723d
00004c  2578206c
000050  656e6774
000054  68203d25
000058  64200d0a
00005c  00      
00005d  00                DCB      0
00005e  00                DCB      0
00005f  00                DCB      0

                          AREA ||i.print_rslt||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  print_rslt PROC
;;;570     */
;;;571    void print_rslt(const char api_name[], int8_t rslt)
000000  b510              PUSH     {r4,lr}
;;;572    {
000002  000c              MOVS     r4,r1
000004  d01c              BEQ      |L22.64|
;;;573        if (rslt != BMP280_OK)
;;;574        {
;;;575            printf("%s\t", api_name);
000006  4601              MOV      r1,r0
000008  a00e              ADR      r0,|L22.68|
00000a  f7fffffe          BL       __2printf
;;;576            if (rslt == BMP280_E_NULL_PTR)
00000e  1c60              ADDS     r0,r4,#1
000010  d00b              BEQ      |L22.42|
;;;577            {
;;;578                printf("Error [%d] : Null pointer error\r\n", rslt);
;;;579            }
;;;580            else if (rslt == BMP280_E_COMM_FAIL)
000012  1d20              ADDS     r0,r4,#4
000014  d00c              BEQ      |L22.48|
;;;581            {
;;;582                printf("Error [%d] : Bus communication failed\r\n", rslt);
;;;583            }
;;;584            else if (rslt == BMP280_E_IMPLAUS_TEMP)
000016  1de0              ADDS     r0,r4,#7
000018  d00d              BEQ      |L22.54|
;;;585            {
;;;586                printf("Error [%d] : Invalid Temperature\r\n", rslt);
;;;587            }
;;;588            else if (rslt == BMP280_E_DEV_NOT_FOUND)
00001a  1ca0              ADDS     r0,r4,#2
;;;589            {
;;;590                printf("Error [%d] : Device not found\r\n", rslt);
;;;591            }
;;;592            else
;;;593            {
;;;594                /* For more error codes refer "*_defs.h" */
;;;595                printf("Error [%d] : Unknown error code\r\n", rslt);
00001c  4621              MOV      r1,r4
00001e  d00d              BEQ      |L22.60|
000020  a009              ADR      r0,|L22.72|
                  |L22.34|
000022  e8bd4010          POP      {r4,lr}
000026  f7ffbffe          B.W      __2printf
                  |L22.42|
00002a  4621              MOV      r1,r4                 ;578
00002c  a00f              ADR      r0,|L22.108|
00002e  e7f8              B        |L22.34|
                  |L22.48|
000030  4621              MOV      r1,r4                 ;582
000032  a017              ADR      r0,|L22.144|
000034  e7f5              B        |L22.34|
                  |L22.54|
000036  4621              MOV      r1,r4                 ;586
000038  a01f              ADR      r0,|L22.184|
00003a  e7f2              B        |L22.34|
                  |L22.60|
00003c  a027              ADR      r0,|L22.220|
00003e  e7f0              B        |L22.34|
                  |L22.64|
;;;596            }
;;;597        }
;;;598    }
000040  bd10              POP      {r4,pc}
;;;599    
                          ENDP

000042  0000              DCW      0x0000
                  |L22.68|
000044  25730900          DCB      "%s\t",0
                  |L22.72|
000048  4572726f          DCB      "Error [%d] : Unknown error code\r\n",0
00004c  72205b25
000050  645d203a
000054  20556e6b
000058  6e6f776e
00005c  20657272
000060  6f722063
000064  6f64650d
000068  0a00    
00006a  00                DCB      0
00006b  00                DCB      0
                  |L22.108|
00006c  4572726f          DCB      "Error [%d] : Null pointer error\r\n",0
000070  72205b25
000074  645d203a
000078  204e756c
00007c  6c20706f
000080  696e7465
000084  72206572
000088  726f720d
00008c  0a00    
00008e  00                DCB      0
00008f  00                DCB      0
                  |L22.144|
000090  4572726f          DCB      "Error [%d] : Bus communication failed\r\n",0
000094  72205b25
000098  645d203a
00009c  20427573
0000a0  20636f6d
0000a4  6d756e69
0000a8  63617469
0000ac  6f6e2066
0000b0  61696c65
0000b4  640d0a00
                  |L22.184|
0000b8  4572726f          DCB      "Error [%d] : Invalid Temperature\r\n",0
0000bc  72205b25
0000c0  645d203a
0000c4  20496e76
0000c8  616c6964
0000cc  2054656d
0000d0  70657261
0000d4  74757265
0000d8  0d0a00  
0000db  00                DCB      0
                  |L22.220|
0000dc  4572726f          DCB      "Error [%d] : Device not found\r\n",0
0000e0  72205b25
0000e4  645d203a
0000e8  20446576
0000ec  69636520
0000f0  6e6f7420
0000f4  666f756e
0000f8  640d0a00

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  bmp
                          %        52

                          AREA ||.data||, DATA, ALIGN=2

                  bmp_mode_type
000000  00                DCB      0x00
                  ||cy||
000001  00                DCB      0x00
                  ac1
000002  0000              DCB      0x00,0x00
                  ac2
000004  0000              DCB      0x00,0x00
                  ac3
000006  0000              DCB      0x00,0x00
                  ac4
000008  0000              DCB      0x00,0x00
                  ac5
00000a  0000              DCB      0x00,0x00
                  ac6
00000c  0000              DCB      0x00,0x00
                  ||b1||
00000e  0000              DCB      0x00,0x00
                  ||b2||
000010  0000              DCB      0x00,0x00
                  ||mb||
000012  0000              DCB      0x00,0x00
                  ||mc||
000014  0000              DCB      0x00,0x00
                  ||md||
000016  0000              DCB      0x00,0x00
                  temperature
                          DCD      0x0000ffff
                  pressure
                          DCD      0xffffffff
                  Altitude
                          DCD      0x0000ffff

;*** Start embedded assembler ***

#line 1 "..\\src\\HARDWARE\\BMP\\BMP085.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_BMP085_c_be4e2a6c____REV16|
#line 114 "..\\..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___8_BMP085_c_be4e2a6c____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_BMP085_c_be4e2a6c____REVSH|
#line 128
|__asm___8_BMP085_c_be4e2a6c____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
