; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm32l152-eval\myadc.o --asm_dir=.\STM32L152-EVAL\ --list_dir=.\STM32L152-EVAL\ --depend=.\stm32l152-eval\myadc.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32L1xx\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32L1xx_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM32L152_EVAL -I..\src\user -I..\src\user\include -I..\src\SYSTEM\delay -I..\src\SYSTEM\sys -I..\src\SYSTEM\usart -I..\src\HARDWARE\ADC -I..\src\HARDWARE\BMP -I..\src\HARDWARE\DMA -I..\src\HARDWARE\FLASH -I..\src\HARDWARE\GPS -I..\src\HARDWARE\KEY -I..\src\HARDWARE\PWM -I..\src\HARDWARE\RTC -I..\src\HARDWARE\SPI -I..\src\HARDWARE\USART2 -I..\src\HARDWARE\TIMER -I..\src\EX -I..\src\USMART -I..\..\..\Libraries\CMSIS\Include -I..\src\ff11a\src -I..\src\ff11a\src\option -I..\src\HARDWARE\LED -I..\src\HARDWARE\OLED -I..\src\ff11a\src -I..\src\ff11a\src\option -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.1.0\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32L1xx -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32L1XX_MD -DUSE_STM32L152_EVAL ..\src\HARDWARE\ADC\myadc.c]
                          THUMB

                          AREA ||i.ADC_Config||, CODE, READONLY, ALIGN=2

                  ADC_Config PROC
;;;212      */
;;;213    void ADC_Config(void)
000000  b510              PUSH     {r4,lr}
;;;214    {
000002  b088              SUB      sp,sp,#0x20
;;;215    
;;;216    ADC_InitTypeDef ADC_InitStructure;
;;;217    GPIO_InitTypeDef GPIO_InitStructure;
;;;218    
;;;219    
;;;220      /* Enable The HSI (16Mhz) */
;;;221      RCC_HSICmd(ENABLE);
000004  2001              MOVS     r0,#1
000006  f7fffffe          BL       RCC_HSICmd
;;;222      
;;;223      /* Enable the GPIOF or GPIOA Clock */
;;;224      RCC_AHBPeriphClockCmd(IDD_MEASUREMENT_GPIO_CLK, ENABLE);
00000a  2101              MOVS     r1,#1
00000c  2002              MOVS     r0,#2
00000e  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;225      /* Configure PF.11 (ADC Channel11) or PA.05 (ADC Channe5) in analog mode */
;;;226      GPIO_InitStructure.GPIO_Pin =  IDD_MEASUREMENT_PIN;
000012  f44f4000          MOV      r0,#0x8000
;;;227      GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AN;
000016  9006              STR      r0,[sp,#0x18]
000018  2003              MOVS     r0,#3
00001a  f88d001c          STRB     r0,[sp,#0x1c]
;;;228      GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
00001e  2400              MOVS     r4,#0
000020  f88d401f          STRB     r4,[sp,#0x1f]
;;;229      GPIO_Init(IDD_MEASUREMENT_GPIO, &GPIO_InitStructure);
000024  a906              ADD      r1,sp,#0x18
000026  4825              LDR      r0,|L1.188|
000028  f7fffffe          BL       GPIO_Init
;;;230    
;;;231      /* ADC1 Configuration ------------------------------------------------------*/
;;;232      
;;;233      /* Enable ADC1 clock */
;;;234      RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
00002c  2101              MOVS     r1,#1
00002e  0248              LSLS     r0,r1,#9
000030  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;235      
;;;236    #if 1//def USE_STM32L152D_EVAL
;;;237      /* Select ADC Bank channel */
;;;238      //ADC_BankSelection(ADC1, ADC_Bank_B);
;;;239    #endif
;;;240      
;;;241      ADC_StructInit(&ADC_InitStructure);
000034  4668              MOV      r0,sp
000036  f7fffffe          BL       ADC_StructInit
;;;242      ADC_InitStructure.ADC_Resolution = ADC_Resolution_12b;
;;;243      ADC_InitStructure.ADC_ScanConvMode = DISABLE;
00003a  9400              STR      r4,[sp,#0]
00003c  f88d4004          STRB     r4,[sp,#4]
;;;244      ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;
000040  2001              MOVS     r0,#1
;;;245      ADC_InitStructure.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
;;;246      ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
000042  9402              STR      r4,[sp,#8]
;;;247      ADC_InitStructure.ADC_NbrOfConversion = 1;
000044  9404              STR      r4,[sp,#0x10]
;;;248      ADC_Init(ADC1, &ADC_InitStructure);
000046  4c1e              LDR      r4,|L1.192|
000048  f88d0005          STRB     r0,[sp,#5]            ;244
00004c  f88d0014          STRB     r0,[sp,#0x14]         ;247
000050  4669              MOV      r1,sp
000052  4620              MOV      r0,r4
000054  f7fffffe          BL       ADC_Init
;;;249    
;;;250      /* ADC1 regular channel5 or channel1 configuration */
;;;251      ADC_RegularChannelConfig(ADC1, IDD_MEASUREMENT_ADC_CHANNEL, 1, ADC_SampleTime_96Cycles);
000058  2305              MOVS     r3,#5
00005a  2201              MOVS     r2,#1
00005c  2115              MOVS     r1,#0x15
00005e  4620              MOV      r0,r4
000060  f7fffffe          BL       ADC_RegularChannelConfig
;;;252    
;;;253      /* Define delay between ADC1 conversions */
;;;254      ADC_DelaySelectionConfig(ADC1, ADC_DelayLength_Freeze);
000064  2110              MOVS     r1,#0x10
000066  4620              MOV      r0,r4
000068  f7fffffe          BL       ADC_DelaySelectionConfig
;;;255      
;;;256      /* Enable ADC1 Power Down during Delay */
;;;257      ADC_PowerDownCmd(ADC1, ADC_PowerDown_Idle_Delay, ENABLE);
00006c  2201              MOVS     r2,#1
00006e  f44f3140          MOV      r1,#0x30000
000072  4620              MOV      r0,r4
000074  f7fffffe          BL       ADC_PowerDownCmd
;;;258      
;;;259      /* Enable ADC1 */
;;;260      ADC_Cmd(ADC1, ENABLE);
000078  2101              MOVS     r1,#1
00007a  4620              MOV      r0,r4
00007c  f7fffffe          BL       ADC_Cmd
;;;261    	v1000_debug("\r\n ADC_Cmd(ADC1, ENABLE)");
000080  a010              ADR      r0,|L1.196|
000082  f7fffffe          BL       __2printf
                  |L1.134|
;;;262      /* Wait until ADC1 ON status */
;;;263      while (ADC_GetFlagStatus(ADC1, ADC_FLAG_ADONS) == RESET)
000086  2140              MOVS     r1,#0x40
000088  4620              MOV      r0,r4
00008a  f7fffffe          BL       ADC_GetFlagStatus
00008e  2800              CMP      r0,#0
000090  d0f9              BEQ      |L1.134|
;;;264      {
;;;265      }
;;;266    	v1000_debug("\r\n ADC_FLAG_ADONS");
000092  a013              ADR      r0,|L1.224|
000094  f7fffffe          BL       __2printf
;;;267      /* Start ADC1 Software Conversion */
;;;268      ADC_SoftwareStartConv(ADC1);
000098  4620              MOV      r0,r4
00009a  f7fffffe          BL       ADC_SoftwareStartConv
;;;269    	v1000_debug("\r\n ADC_SoftwareStartConv");
00009e  a015              ADR      r0,|L1.244|
0000a0  f7fffffe          BL       __2printf
                  |L1.164|
;;;270      /* Wait until ADC Channel 5 or 1 end of conversion */
;;;271      while (ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC) == RESET)
0000a4  2102              MOVS     r1,#2
0000a6  4620              MOV      r0,r4
0000a8  f7fffffe          BL       ADC_GetFlagStatus
0000ac  2800              CMP      r0,#0
0000ae  d0f9              BEQ      |L1.164|
;;;272      {
;;;273      }
;;;274      	v1000_debug("\r\n ADC_GetFlagStatus");
0000b0  a017              ADR      r0,|L1.272|
0000b2  f7fffffe          BL       __2printf
;;;275    }
0000b6  b008              ADD      sp,sp,#0x20
0000b8  bd10              POP      {r4,pc}
;;;276    
                          ENDP

0000ba  0000              DCW      0x0000
                  |L1.188|
                          DCD      0x40020400
                  |L1.192|
                          DCD      0x40012400
                  |L1.196|
0000c4  0d0a2041          DCB      "\r\n ADC_Cmd(ADC1, ENABLE)",0
0000c8  44435f43
0000cc  6d642841
0000d0  4443312c
0000d4  20454e41
0000d8  424c4529
0000dc  00      
0000dd  00                DCB      0
0000de  00                DCB      0
0000df  00                DCB      0
                  |L1.224|
0000e0  0d0a2041          DCB      "\r\n ADC_FLAG_ADONS",0
0000e4  44435f46
0000e8  4c41475f
0000ec  41444f4e
0000f0  5300    
0000f2  00                DCB      0
0000f3  00                DCB      0
                  |L1.244|
0000f4  0d0a2041          DCB      "\r\n ADC_SoftwareStartConv",0
0000f8  44435f53
0000fc  6f667477
000100  61726553
000104  74617274
000108  436f6e76
00010c  00      
00010d  00                DCB      0
00010e  00                DCB      0
00010f  00                DCB      0
                  |L1.272|
000110  0d0a2041          DCB      "\r\n ADC_GetFlagStatus",0
000114  44435f47
000118  6574466c
00011c  61675374
000120  61747573
000124  00      
000125  00                DCB      0
000126  00                DCB      0
000127  00                DCB      0

                          AREA ||i.DisplayIDDrunmV||, CODE, READONLY, ALIGN=2

                  DisplayIDDrunmV PROC
;;;87     
;;;88     void DisplayIDDrunmV(uint32_t IDDmeas)
000000  b570              PUSH     {r4-r6,lr}
;;;89     { 
;;;90       static int ddrunmv = 0;
;;;91       /* x  current value*/
;;;92       static u8 ddrunmv_cnt = 0;
;;;93     
;;;94     
;;;95     
;;;96         ddrunmv += IDDmeas;
000002  4c28              LDR      r4,|L2.164|
000004  6861              LDR      r1,[r4,#4]  ; ddrunmv
000006  4401              ADD      r1,r1,r0
;;;97         if(ddrunmv_cnt<10)
000008  6061              STR      r1,[r4,#4]  ; ddrunmv
00000a  7820              LDRB     r0,[r4,#0]  ; ddrunmv_cnt
00000c  280a              CMP      r0,#0xa
00000e  d202              BCS      |L2.22|
000010  1c40              ADDS     r0,r0,#1              ;89
;;;98         {
;;;99             ddrunmv_cnt++;         
000012  7020              STRB     r0,[r4,#0]
;;;100            return;
;;;101        }
;;;102        else
;;;103        {
;;;104            ddrunmv = ddrunmv/11;
;;;105            ddrunmv_cnt = 0;
;;;106    
;;;107    
;;;108        }
;;;109        //v1000_debug("IDDRUNMV: %d  \r\n",ddrunmv);
;;;110        if(IsBatteryPoweroff(ddrunmv))
;;;111        {
;;;112            //  headsetPowerOff(getApp());system_flag_table->batt_Status
;;;113            system_flag_table->batt_Status = 0xFF;
;;;114            if(KEY2 == 0)		 
;;;115                Choose_power_mode(MCU_STBY);
;;;116        }			  
;;;117    
;;;118        else
;;;119        {
;;;120    
;;;121            if (IsBatteryFull(ddrunmv))
;;;122            {
;;;123                if(system_flag_table->charger_connected == 1)
;;;124                {
;;;125                    if(system_flag_table->batt_change_ok_cnt == 0)
;;;126                    {
;;;127                        system_flag_table->batt_change_ok_cnt = 30*60*100;//ms
;;;128                        //system_flag_table->batt_Status  =  BATT_CHARG_OK;
;;;129                    }
;;;130                }
;;;131                else
;;;132                {
;;;133                    system_flag_table->batt_Status  = BATT_HIGH;
;;;134                }
;;;135    
;;;136            }                    
;;;137    
;;;138            else if (IsBatteryHIGH(ddrunmv))
;;;139            {
;;;140                if((system_flag_table->charger_connected == 1)&&(system_flag_table->batt_Status  ==  BATT_CHARG_OK))
;;;141                    ;
;;;142                else	
;;;143                    system_flag_table->batt_Status  =  BATT_HIGH;
;;;144    
;;;145            }       
;;;146            else if (IsBatteryMid(ddrunmv))
;;;147            {                        
;;;148                system_flag_table->batt_Status  =  BATT_MID;
;;;149            }
;;;150            else  if (IsBatteryLow(ddrunmv))
;;;151            {                                	           
;;;152                system_flag_table->batt_Status  =  BATT_LOW;
;;;153            }
;;;154            else if (IsBatteryDead(ddrunmv))
;;;155            {                        
;;;156                system_flag_table->batt_Status  = BATT_EMPTY;
;;;157            }
;;;158    
;;;159        }  
;;;160    
;;;161        ddrunmv = 0;
;;;162    	
;;;163    }
000014  bd70              POP      {r4-r6,pc}
                  |L2.22|
000016  200b              MOVS     r0,#0xb               ;104
000018  fb91f0f0          SDIV     r0,r1,r0              ;104
00001c  6060              STR      r0,[r4,#4]            ;105  ; ddrunmv
00001e  b281              UXTH     r1,r0                 ;110
000020  4821              LDR      r0,|L2.168|
000022  2500              MOVS     r5,#0                 ;105
000024  7025              STRB     r5,[r4,#0]            ;105
000026  6800              LDR      r0,[r0,#0]            ;113
000028  f5b16f48          CMP      r1,#0xc80             ;110
00002c  d80a              BHI      |L2.68|
00002e  21ff              MOVS     r1,#0xff              ;113
000030  f880102c          STRB     r1,[r0,#0x2c]         ;113
000034  481d              LDR      r0,|L2.172|
000036  f8d00234          LDR      r0,[r0,#0x234]        ;114
00003a  b9f8              CBNZ     r0,|L2.124|
00003c  2006              MOVS     r0,#6                 ;115
00003e  f7fffffe          BL       Choose_power_mode
000042  e02c              B        |L2.158|
                  |L2.68|
000044  f2410304          MOV      r3,#0x1004            ;121
000048  2203              MOVS     r2,#3                 ;133
00004a  4299              CMP      r1,r3                 ;121
00004c  d308              BCC      |L2.96|
00004e  f890102d          LDRB     r1,[r0,#0x2d]         ;123
000052  2901              CMP      r1,#1                 ;123
000054  d110              BNE      |L2.120|
000056  6c01              LDR      r1,[r0,#0x40]         ;125
000058  b981              CBNZ     r1,|L2.124|
00005a  4915              LDR      r1,|L2.176|
00005c  6401              STR      r1,[r0,#0x40]         ;127
00005e  e01e              B        |L2.158|
                  |L2.96|
000060  f640730a          MOV      r3,#0xf0a             ;138
000064  4299              CMP      r1,r3                 ;138
000066  d90a              BLS      |L2.126|
000068  f890102d          LDRB     r1,[r0,#0x2d]         ;140
00006c  2901              CMP      r1,#1                 ;140
00006e  d103              BNE      |L2.120|
000070  f890102c          LDRB     r1,[r0,#0x2c]         ;140
000074  2905              CMP      r1,#5                 ;140
000076  d012              BEQ      |L2.158|
                  |L2.120|
000078  f880202c          STRB     r2,[r0,#0x2c]         ;143
                  |L2.124|
00007c  e00f              B        |L2.158|
                  |L2.126|
00007e  f6406288          MOV      r2,#0xe88             ;146
000082  4291              CMP      r1,r2                 ;146
000084  d901              BLS      |L2.138|
000086  2102              MOVS     r1,#2                 ;148
000088  e004              B        |L2.148|
                  |L2.138|
00008a  f640622e          MOV      r2,#0xe2e             ;150
00008e  4291              CMP      r1,r2                 ;150
000090  d903              BLS      |L2.154|
000092  2101              MOVS     r1,#1                 ;152
                  |L2.148|
000094  f880102c          STRB     r1,[r0,#0x2c]         ;152
000098  e001              B        |L2.158|
                  |L2.154|
00009a  f880502c          STRB     r5,[r0,#0x2c]         ;156
                  |L2.158|
00009e  6065              STR      r5,[r4,#4]            ;161  ; ddrunmv
0000a0  bd70              POP      {r4-r6,pc}
;;;164    
                          ENDP

0000a2  0000              DCW      0x0000
                  |L2.164|
                          DCD      ||.data||
                  |L2.168|
                          DCD      system_flag_table
                  |L2.172|
                          DCD      0x42410000
                  |L2.176|
                          DCD      0x0002bf20

                          AREA ||i.vddmv_adc_proess||, CODE, READONLY, ALIGN=2

                  vddmv_adc_proess PROC
;;;173      */
;;;174    void vddmv_adc_proess(void)
000000  b508              PUSH     {r3,lr}
;;;175    {
;;;176      /*!< At this stage the microcontroller clock setting is already configured, 
;;;177           this is done through SystemInit() function which is called from startup
;;;178           file (startup_stm32l1xx_xx.s) before to branch to application main.
;;;179           To reconfigure the default setting of SystemInit() function, refer to
;;;180           system_stm32l1xx.c file
;;;181         */
;;;182        /* Read ADC conversion result */
;;;183    __IO uint16_t ADCdata = 0;
000002  2000              MOVS     r0,#0
000004  f8ad0000          STRH     r0,[sp,#0]
;;;184    __IO uint32_t VDDmV = 0;
;;;185    
;;;186    
;;;187        ADCdata = ADC_GetConversionValue(ADC1);
000008  9000              STR      r0,[sp,#0]
00000a  4809              LDR      r0,|L3.48|
00000c  f7fffffe          BL       ADC_GetConversionValue
000010  f8ad0000          STRH     r0,[sp,#0]
;;;188    //  v1000_debug("ADCdata: %d  \r\n",ADCdata);
;;;189        /* Calculate voltage value*/
;;;190        VDDmV = (uint32_t)((uint32_t)ADCdata *6000/4095);
000014  f8bd0000          LDRH     r0,[sp,#0]
000018  f2417170          MOV      r1,#0x1770
00001c  4348              MULS     r0,r1,r0
00001e  f64071ff          MOV      r1,#0xfff
000022  fbb0f0f1          UDIV     r0,r0,r1
;;;191        
;;;192    #ifdef USE_STM32L152_EVAL 
;;;193        /* Calculate the current consumption */
;;;194    //    IDDrunuA = (uint32_t) ((uint32_t)(((VDDmV * EVAL_RESISTOR_RATIO) / EVAL_MAX9938_GAIN))\
;;;195     //                          / (uint32_t)(EVAL_RESISTOR_R36));
;;;196    #elif defined USE_STM32L152D_EVAL
;;;197        /* Calculate the current consumption */
;;;198        IDDrunuA = (uint32_t) ((uint32_t)(((VDDmV * EVAL_RESISTOR_RATIO) / EVAL_MAX9938_GAIN))\
;;;199                               / (uint32_t)(EVAL_RESISTOR_R62));
;;;200    
;;;201    #endif    
;;;202    
;;;203        /* Display the IDD measured Value On the LCD Glass (mA) */
;;;204        DisplayIDDrunmV(VDDmV);
000026  9000              STR      r0,[sp,#0]
000028  e8bd4008          POP      {r3,lr}
00002c  f7ffbffe          B.W      DisplayIDDrunmV
;;;205    
;;;206    }
;;;207    
                          ENDP

                  |L3.48|
                          DCD      0x40012400

                          AREA ||.data||, DATA, ALIGN=2

                  ddrunmv_cnt
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  ddrunmv
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\src\\HARDWARE\\ADC\\myadc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_myadc_c_73fec6c7____REV16|
#line 114 "..\\..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___7_myadc_c_73fec6c7____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_myadc_c_73fec6c7____REVSH|
#line 128
|__asm___7_myadc_c_73fec6c7____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
